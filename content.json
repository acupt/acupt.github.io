{"meta":{"title":"一杯82年的JAVA","subtitle":null,"description":null,"author":"ACUPT","url":"https://acupt.github.io"},"pages":[{"title":"","date":"2018-09-21T10:01:16.566Z","updated":"2018-09-21T10:01:16.566Z","comments":true,"path":"README.html","permalink":"https://acupt.github.io/README.html","excerpt":"","text":"sourcemy hexo source"},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"gallery/index.html","permalink":"https://acupt.github.io/gallery/index.html","excerpt":"","text":""},{"title":"about me","date":"2018-05-20T08:00:00.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"about/index.html","permalink":"https://acupt.github.io/about/index.html","excerpt":"","text":"I’m fine, fuck you."},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2018-09-21T10:01:16.688Z","comments":true,"path":"work/index.html","permalink":"https://acupt.github.io/work/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2018-09-21T10:01:16.687Z","comments":true,"path":"tag/index.html","permalink":"https://acupt.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"跨域Access-Control-Allow-Origin解决方案","slug":"access-control-allow-origin","date":"2019-07-31T11:00:00.000Z","updated":"2019-07-31T15:19:43.301Z","comments":true,"path":"2019/07/31/access-control-allow-origin/","link":"","permalink":"https://acupt.github.io/2019/07/31/access-control-allow-origin/","excerpt":"","text":"前端访问其它域名的资源往往会失败，那是因为浏览器出于安全考虑禁止了不同源的资源。 同源策略 同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。 同源：协议 + 域名 + 端口 既然是浏览器的策略，则说明资源请求是可以正常返回的，只是浏览器不给用。 跨域报错本地启动了一个web服务，地址为 127.0.0.1:8882 ，然后通过一个本地静态页面去请求这个接口。虽然在同一台电脑，但依然是跨域的。 上面也说了这个限制是浏览器做的，看看接口，其实已经请求成功了，后端是执行了相关代码的。 后端修改Response支持跨域从上面控制台的输出可以看到，错误原因是请求的资源（接口）的header中没有”Access-Control-Allow-Origin“，那我们可以给它加上。在哪加？既然说是请求的资源没有，那当然是在请求的资源上加，也就是服务端。 1234567891011121314151617181920212223@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public Object test(HttpServletRequest request, HttpServletResponse response) &#123; // 跨域支持 response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST,GET,PUT,DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"*\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); return map; &#125;&#125; 再看看浏览器，已经可以正常访问接口了。 如果觉得每个接口里面都要配置一下response很麻烦，可以在一个拦截器里面做这个事情。 springboot支持跨域测试用例是一个springboot项目，可以用更简单的方式。通过一个继承了WebMvcConfigurerAdapter的bean，重写addCorsMappings方法，在方法里配置。 1234567891011121314151617181920212223242526@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public Object test(HttpServletRequest request, HttpServletResponse response) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); return map; &#125; // 跨域支持 @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\") .maxAge(3600); &#125; jsonp支持跨域有前端经验的童鞋知道，有时我们会在自己的代码里直接引入其它域名的js、css等静态文件。为啥这些静态文件没被浏览器限制呢？通常为了减轻web服务器的压力，我们会把js、css，img等静态资源分离到另一台独立域名的服务器上，使其和前端分离开。基于这个原因，浏览器并没有限制这类静态资源的跨域访问。 我们可以动态地创建一个script，让浏览器以为我们要获取静态资源，从而网开一面。而服务器端也需要做一点改变，不能直接返回json，而是返回一个立即执行的函数，而前端请求的结果就作为函数的参数。 后端接口返回12345678910111213141516171819@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public String test(HttpServletRequest request, HttpServletResponse response, String callback) throws IOException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); // 返回值如下： // callback(&#123;\"msg\":\"我来自服务端\",\"success\":true&#125;); return String.format(\"%s(%s);\", callback, JsonUtil.toJson(map)); &#125; js原生实现jsonp12345678910111213141516function test() &#123; // 外部域名，参数是和后端接口约定的callback指定接口返回后的回调函数 url = \"http://localhost:8882/test?callback=_ajax_callback\"; // 创建一个script元素 var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; document.head.appendChild(script);&#125;// 接口回调function _ajax_callback(res) &#123; console.log(\"被回调了\"); console.log(res);&#125; 接口返回： 回调函数执行： jQuery实现jsonp一般我们会使用jQuery来做ajax请求，这样需要增加一个jQuery的引用。 12345678// 没测，懒得测$.ajax(&#123; url: 'http://localhost:8882/test', type: 'get', dataType: 'jsonp', // 请求方式 jsonpCallback: \"_ajax_callback\", // 回调函数名 data: &#123;&#125;&#125;); vue.js实现jsonp现在前端vue.js用的也很多，再记录一个vue.js的用法。 1234567// 没测，懒得测this.$http.jsonp('http://localhost:8882/test', &#123; params: &#123;&#125;, jsonp: '_ajax_callback'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) jsonp缺点只能实现get请求。 其它方式支持跨域 nginx反向代理：前端访问相同域名，nginx再根据需要把请求转发到外部域名； 后端代理：在后端接口里先请求外部资源（比如用HttpClient），然后把结果返回给前端，这样就不是跨域了； 其它：借助iframe、postMessage等也可实现跨域。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://acupt.github.io/tags/跨域/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}]},{"title":"探索JAVA并发 - 线程池详解","slug":"concurrent-thread-pool","date":"2019-07-30T13:55:00.000Z","updated":"2019-07-31T15:09:38.818Z","comments":true,"path":"2019/07/30/concurrent-thread-pool/","link":"","permalink":"https://acupt.github.io/2019/07/30/concurrent-thread-pool/","excerpt":"","text":"线程池是并发编程中必不可少的一种工具，也是面试高频话题。 线程池，即管理着若干线程的资源池（字面意思）。相比于为每个任务分配一个线程，在线程池中执行任务优势更多： 线程复用：线程池中的线程是可以复用的，省去了创建、销毁线程的开销，提高了资源利用率（创建、销毁等操作都是要消耗系统资源的）和响应速度（任务提交过来线程已存在就不用等待线程创建了）； 合理利用资源：通过调整线程池大小，让所有处理器尽量保持忙碌，又能防止过多线程产生过多竞争浪费资源； 常用的线程池主要是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor(定时任务线程池，继承ThreadPoolExecutor)。 Executor框架 在JAVA中，任务执行的主要抽象不是Thread，而是Executor。Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。 所谓Executor框架，其实就是定义了一个接口，我们常用的线程池ThreadPoolExecutor就是对这个接口的一种实现。 12345678910111213public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command 可执行的任务 * @throws RejectedExecutionException 任务可能被拒绝（当Executor处理不了的时候） * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; Executors与常用线程池 Executors其实就是Executor(加s) Executors是一个Executor的工厂，有很多定义好的工厂方法，可以帮助懒惰的开发者快速创建一个线程池。下面是几个常用的工厂方法： newFixedThreadPool 固定长度线程池，每次提交任务都会创建一个新线程，直到线程数量达到指定阈值则不再创建新的； newCachedThreadPool 可缓存线程池，每次提交任务都会创建一个新线程（理论上无限制），部分任务执行完后如果没有新的任务，导致某些线程无用武之地，它们将被终结； newSingleThreadExecutor 只有一个线程的线程池； newScheduledThreadPool 可以延时或者定时执行任务的线程池。 12345678910111213141516171819202122232425public class Executors &#123; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;&#125; 如果查看上述工厂方法的源码，会发现只是new了一个线程池对象返回给调用者而已，没什么花里胡哨的东西。不过看看构造参数还真不少，通过这种方式比起我们自己new一个线程池要简单多了（才怪）。 线程池构造参数了解线程池构造参数的意义，能让我们更清楚程序执行逻辑。 int corePoolSize : 核心线程数，有新任务来时，如果当前线程小于核心线程，则新建一个线程来执行该任务 int maximumPoolSize : 最大线程数，线程池最多拥有的线程数 long keepAliveTime : 空闲线程存活时间 TimeUnit unit : 空闲线程存活时间的单位 BlockingQueue workQueue : 存放待执行任务的阻塞队列，新任务来时，若当前线程数&gt;=最大核心线程数，则放到这个队列 ThreadFactory threadFactory : 创建新线程的工厂，一般用来给线程取个名字方便排查问题 RejectedExecutionHandler handler : 任务被拒绝后的处理器，默认的处理器会直接抛出异常，建议重新实现 配合源码，效果更佳： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ThreadPoolExecutor extends AbstractExecutorService &#123; // 构造函数 public ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 空闲线程存活时间 TimeUnit unit, // 空闲线程存活时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, // 存放待执行任务的阻塞队列 ThreadFactory threadFactory, // 创建新线程的工厂 RejectedExecutionHandler handler // 任务被拒绝后的处理器 ) &#123; // ... &#125; // 提交任务 public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * 没翻，懒得翻 * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ // 当前状态值 int c = ctl.get(); // 当前线程数 = workerCountOf(c) 小于 核心线程数 的上限时 // 直接创建一个线程来执行任务 if (workerCountOf(c) &lt; corePoolSize) &#123; // 并发提交场景下可能会失败 if (addWorker(command, true)) return; // 新增成功就可以结束了 // 失败就更新下线程池状态 c = ctl.get(); &#125; // 不能创建核心线程来执行，并不会直接创建非核心线程，而是把任务暂存到阻塞队列 // isRunning(c)判断线程池是否还在运行 // workQueue.offer(command)返回值表示是否成功提交到队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 成功放到队列里了，再检查一下线程池状态 int recheck = ctl.get(); // 如果线程池已经没有运行了，则尝试把新增的任务从队列移除 // remove(command)返回值表示是否移除成功 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 移除成功后，执行拒绝策略 // 检查下当前线程数是否为0，如果是的话新建一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 线程池没有运行，或者放入队列失败（比如队列已满） // 则创建非核心线程去执行任务，这也失败就只能拒绝了 else if (!addWorker(command, false)) reject(command); &#125; 当对线程池的构造参数和任务处理逻辑有了以上大致的了解后，回想Executors提供的几个工厂方法，或许会感到所谓提供便利性的方法并不那么便利。因为从方法的名字上来看很难和线程池的配置准确关联，想要清除地知道这些方法创建的线程池如何运作，就需要知道他们用了怎样的构造参数，那为什么不直接使用构造方法呢？ 所以尽量使用构造方法是更好的编程习惯，这样不管是作者还是其他开发者，只要看看传了什么参数，就知道这个线程池是怎么运作的了。 线程池创建示例1234567891011121314151617181920212223242526272829303132import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; AtomicInteger threadCount = new AtomicInteger(); ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, // 核心线程数 10, // 最大线程数 1, // 空闲线程存活时间 TimeUnit.MINUTES, // 空闲线程存活时间单位 new ArrayBlockingQueue&lt;&gt;(100), // 一个指定上限的阻塞队列，存放待执行任务 new ThreadFactory() &#123; // 自定义一个线程工厂来给线程池里的线程取名字 @Override public Thread newThread(Runnable r) &#123; return new Thread(r, \"pool-thread-\" + threadCount.incrementAndGet()); &#125; &#125;, new RejectedExecutionHandler() &#123; // 自定义一个拒绝处理策略，安慰被线程池拒之门外的小可怜 @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.out.println(\"线程池拒绝了任务: \" + r); &#125; &#125; ); &#125;&#125; 有返回值的提交方式submitThreadPoolExecutor.execute()方法是没有返回值的，也就是说把任务提交给线程池后，我们就失去了它的消息，除非你还保留着它的引用，并且在里面有维护状态。如果不想这么麻烦，可以使用ThreadPoolExecutor.submit()来提交任务，这个方法会返回一个Future对象，通过这个对象可以知道任务何时被执行完。 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 线程池定义 // ... Future&lt;?&gt; future = executor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"我要关注: 一杯82年的JAVA\"); &#125; &#125;); Object r = future.get(); System.out.println(\"返回：\" + r); executor.shutdown(); &#125;&#125;/* 输出: 我要关注: 一杯82年的JAVA返回：null*/ 可以看到Future.get()是有返回值的，但是上面的例子返回了null，因为任务是一个Runnable实现，run方法没有返回值。 submit Callable如果想任务有返回值，可以使用Callable作为任务定义。 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 线程池定义 // ... Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"I'm fine, and you?\"); return \"我要关注: 一杯82年的JAVA\"; &#125; &#125;); String r = future.get(); System.out.println(\"返回：\" + r); executor.shutdown(); &#125;&#125;/* 返回:I'm fine, and you?返回：我要关注: 一杯82年的JAVA*/ submit实现原理为什么submit就可以让用户等待、获取任务返回？从源码讲起： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public abstract class AbstractExecutorService implements ExecutorService &#123; public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); // 把任务用一个RunnableFuture又给包装了一下 RunnableFuture&lt;T&gt; ftask = newTaskFor(task); // 最后还是调用了没有返回值的execute execute(ftask); return ftask; &#125; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125;&#125;// 看看这个包装类public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; private Callable&lt;V&gt; callable; private volatile int state; // 也是Runable的一种实现，所以能在线程池中被执行 public void run() &#123; // 有个表示状态的标识 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 执行用户的逻辑，获得返回值 // 这个步骤可能需要点时间 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; // 获取执行结果，阻塞直到状态改变 public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); &#125;&#125; 小结：submit时用一个FutureTask把用户提交的Callable包装起来，再把FutureTask提交给线程池执行，FutureTask.run运行时会执行Callable中的业务代码，并且过程中FutureTask会维护一个状态标识，根据状态标识，可以知道任务是否执行完成，也可以阻塞到状态为完成获取返回值。 关闭线程池为什么需要关闭线程池？ 如果线程池里的线程一直存活，而且这些线程又不是守护线程，那么会导致虚拟机无法正常退出； 如果直接粗暴地结束应用，线程池中的任务可能没执行完，业务将处于未知状态； 线程中有些该释放的资源没有被释放。 怎么关闭线程池？ shutdown 停止接收新任务（继续提交会被拒绝，执行拒绝策略），但已提交的任务会继续执行，全部完成后线程池彻底关闭； shutdownNow 立即停止线程池，并尝试终止正在进行的线程（通过中断），返回没执行的任务集合； awaitTermination 阻塞当前线程，直到全部任务执行完，或者等待超时，或者被中断。 由于shutdownNow的终止线程是通过中断，这个方式并不能保证线程会提前停止。（关于中断: 如何处理线程中断） 一般先调用shutdown让线程池停止接客，然后调用awaitTermination等待正在工作的线程完事。 123456// 你的池子对我打了烊executor.shutdown();// 等待一首歌的时间（bei~bei~~）// 如果超时还没结束返回false，你可以选择再等一首长点的歌，或者不等了boolean ok = executor.awaitTermination(4, TimeUnit.SECONDS); 扩展线程池线程池提供了一些扩展的方法，通过重写这些方法可以添加前置、后置操作，让使用更灵活。如beforeExecute、afterExecute、terminated … 总结线程池很好用，但使用不当会造成严重的后果，了解它各个属性表示的含义以及执行的流程能帮助我们少踩坑。 举个例子：如果设置了核心线程 &lt; 最大线程数不等（一般都这么设置），但是又设置了一个很大的阻塞队列，那么很可能只有几个核心线程在工作，普通线程一直没机会被创建，因为核心线程满了会优先放到队列里，而不是创建普通线程。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.github.io/tags/线程/"},{"name":"线程池","slug":"线程池","permalink":"https://acupt.github.io/tags/线程池/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}]},{"title":"源码分析 - JVM关闭钩子的注册和调用","slug":"jvm-shutdown-hook","date":"2019-07-29T14:00:00.000Z","updated":"2019-07-29T15:22:52.264Z","comments":true,"path":"2019/07/29/jvm-shutdown-hook/","link":"","permalink":"https://acupt.github.io/2019/07/29/jvm-shutdown-hook/","excerpt":"","text":"通过关闭钩子，我们可以在应用关闭时做一些自定义的操作，让程序更优雅的结束。 JAVA程序运行在虚拟机上(JVM)，JAVA程序执行完成，JVM也随之关闭。关闭的方式有多种，根据其行为的文明程度可大概分为两种： 正常关闭 所有普通线程（非守护线程）执行完毕 System.exit(status) Ctrl - C … 强行关闭 kill进程 Runtime.halt(status) … JVM关闭钩子DEMO123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws Exception &#123; Runtime.getRuntime().addShutdownHook(new MyHook()); System.out.println(\"结束吧\"); &#125; public static class MyHook extends Thread &#123; @Override public void run() &#123; System.out.println(\"你先走，我垫后\"); &#125; &#125;&#125;/* 输出:结束吧你先走，我垫后*/ 自定义钩子如何注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Runtime &#123; // 钩子对象必须是一个Thread（或其子类） public void addShutdownHook(Thread hook) &#123; // 看起来是个权限检查 SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkPermission(new RuntimePermission(\"shutdownHooks\")); &#125; // 真正的注册逻辑在这个类里面 ApplicationShutdownHooks.add(hook); &#125;&#125;class ApplicationShutdownHooks &#123; // 钩子集合 private static IdentityHashMap&lt;Thread, Thread&gt; hooks; // 注册一个钩子 static synchronized void add(Thread hook) &#123; if(hooks == null) throw new IllegalStateException(\"Shutdown in progress\"); // 看来注册前不能让Thread跑起来 if (hook.isAlive()) throw new IllegalArgumentException(\"Hook already running\"); // 同一个钩子不能重复注册 if (hooks.containsKey(hook)) throw new IllegalArgumentException(\"Hook previously registered\"); // 放进集合就算注册成功了？继续往下看 hooks.put(hook, hook); &#125; // 初始化，本来在最前面，为了跟随我的节奏被我移到后面了 static &#123; try &#123; // 看来这个类也不是真正实现钩子回调的地方 // 又在Shutdown注册了一个“钩子”，通过这个“钩子”来执行用户自定义的钩子 Shutdown.add(1 /* shutdown hook invocation order */, false /* not registered if shutdown in progress */, new Runnable() &#123; public void run() &#123; runHooks(); &#125; &#125; ); hooks = new IdentityHashMap&lt;&gt;(); &#125; catch (IllegalStateException e) &#123; // application shutdown hooks cannot be added if // shutdown is in progress. hooks = null; &#125; &#125; // 执行用户钩子的钩子函数 static void runHooks() &#123; Collection&lt;Thread&gt; threads; synchronized(ApplicationShutdownHooks.class) &#123; threads = hooks.keySet(); hooks = null; &#125; for (Thread hook : threads) &#123; hook.start(); &#125; for (Thread hook : threads) &#123; while (true) &#123; try &#123; hook.join(); break; &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125;&#125; 简单追踪了一下注册钩子的源码，发现是通过在Shutdown注册一个钩子来执行用户的钩子。那么Shutdown又是怎么在关闭时执行钩子的呢？ 钩子如何被调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package java.lang;class Shutdown &#123; /* Shutdown state */ private static final int RUNNING = 0; private static final int HOOKS = 1; private static final int FINALIZERS = 2; private static int state = RUNNING; /* Should we run all finalizers upon exit? */ private static boolean runFinalizersOnExit = false; // The system shutdown hooks are registered with a predefined slot. // The list of shutdown hooks is as follows: // (0) Console restore hook // (1) Application hooks // (2) DeleteOnExit hook // 钩子集合容量，有点小，但是看注释目前就3个，倒是足够了，不知道有没有没列出来的 private static final int MAX_SYSTEM_HOOKS = 10; // 钩子集合 private static final Runnable[] hooks = new Runnable[MAX_SYSTEM_HOOKS]; // 注册一个钩子 static void add(int slot, boolean registerShutdownInProgress, Runnable hook) &#123; synchronized (lock) &#123; if (hooks[slot] != null) throw new InternalError(\"Shutdown hook at slot \" + slot + \" already registered\"); if (!registerShutdownInProgress) &#123; if (state &gt; RUNNING) throw new IllegalStateException(\"Shutdown in progress\"); &#125; else &#123; if (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook)) throw new IllegalStateException(\"Shutdown in progress\"); &#125; // 刚才ApplicationShutdownHooks传的是：(1) Application hooks hooks[slot] = hook; &#125; &#125; // 除了add，这是唯一引用hooks的地方了 // 可以看出是顺序执行3种钩子 private static void runHooks() &#123; for (int i=0; i &lt; MAX_SYSTEM_HOOKS; i++) &#123; try &#123; Runnable hook; synchronized (lock) &#123; // acquire the lock to make sure the hook registered during // shutdown is visible here. currentRunningHook = i; hook = hooks[i]; &#125; if (hook != null) hook.run(); &#125; catch(Throwable t) &#123; if (t instanceof ThreadDeath) &#123; ThreadDeath td = (ThreadDeath)t; throw td; &#125; &#125; &#125; &#125; // 执行钩子的地方 private static void sequence() &#123; synchronized (lock) &#123; /* Guard against the possibility of a daemon thread invoking exit * after DestroyJavaVM initiates the shutdown sequence */ if (state != HOOKS) return; &#125; runHooks();//执行钩子 boolean rfoe; synchronized (lock) &#123; state = FINALIZERS; rfoe = runFinalizersOnExit; &#125; if (rfoe) runAllFinalizers(); &#125; // 下面两个方法是我们触发应用关闭的途径，均可执行钩子 /* Invoked by Runtime.exit, which does all the security checks. * Also invoked by handlers for system-provided termination events, * which should pass a nonzero status code. */ // 强行翻译：通过Runtime.exit调用 // 这是我们可以在程序中调用到的 static void exit(int status) &#123; boolean runMoreFinalizers = false; synchronized (lock) &#123; if (status != 0) runFinalizersOnExit = false; switch (state) &#123; case RUNNING: /* Initiate shutdown */ state = HOOKS; break; case HOOKS: /* Stall and halt */ break; case FINALIZERS: if (status != 0) &#123; /* Halt immediately on nonzero status */ halt(status); &#125; else &#123; /* Compatibility with old behavior: * Run more finalizers and then halt */ runMoreFinalizers = runFinalizersOnExit; &#125; break; &#125; &#125; if (runMoreFinalizers) &#123; runAllFinalizers(); halt(status); &#125; synchronized (Shutdown.class) &#123; /* Synchronize on the class object, causing any other thread * that attempts to initiate shutdown to stall indefinitely */ sequence();//执行钩子 halt(status); &#125; &#125; /* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon * thread has finished. Unlike the exit method, this method does not * actually halt the VM. */ // 强行翻译：最后一个非守护线程结束后通过本地接口（JNI）调用。和exit方法不同，此方法没有真正停止虚拟机 // 这个方法没有找到调用的代码 static void shutdown() &#123; synchronized (lock) &#123; switch (state) &#123; case RUNNING: /* Initiate shutdown */ state = HOOKS; break; case HOOKS: /* Stall and then return */ case FINALIZERS: break; &#125; &#125; synchronized (Shutdown.class) &#123; sequence();// 执行钩子 &#125; &#125; 简单的看了下源码，知道了exit和shutdown时都会通过某种流程和规则去执行到用户定义的钩子。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.github.io/tags/jvm/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}]},{"title":"JAVA泛型与类型擦除","slug":"java-generics-type-erasure","date":"2019-07-28T14:30:00.000Z","updated":"2019-07-28T16:00:10.665Z","comments":true,"path":"2019/07/28/java-generics-type-erasure/","link":"","permalink":"https://acupt.github.io/2019/07/28/java-generics-type-erasure/","excerpt":"","text":"泛型的本质是参数化类型，这种参数类型可以用在类、接口和方法的创建中。泛型是在JAVA 1.5版本中才引入的，它能和以前的版本兼容的原因是泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，即类型擦除。 泛型的定义与使用根据使用情况可以分为以下三种： 泛型类 泛型方法 泛型接口 下面是一个常用的泛型类： 1234567891011121314151617181920212223242526// 一个泛型类，可以根据需要包装不同结果的返回值public class Result&lt;T&gt; &#123; private boolean success; private String message; private T data; // 一个泛型方法 // 返回值类型定义前的&lt;T&gt;是必须的，用来声明一个类型持有者名称，然后就可以把T当作一个类型代表来声明成员、参数和返回值类型。 public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.success = true; r.data = data; return r; &#125; public static &lt;T&gt; Result&lt;T&gt; error(String message) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.message = message; return r; &#125; // getter &amp; setter&#125; 类型参数上面尖括号中的T即类型参数，代指任何类，使用时可以替换成任意类，如： 12345678public class Main &#123; public static void main(String[] args) &#123; Result&lt;Date&gt; r1 = Result.success(new Date()); Result&lt;List&lt;String&gt;&gt; r2 = Result.success(Arrays.asList(\"s1\", \"s2\")); &#125;&#125; 为什么要用T而不是其它字母？事实上是可以任意字符串（如Result&lt; something &gt;），但是为了显得专业，一般约定几个大写字母在不同场景使用。 T 最常用，一般代指任意类，不知道用啥就用它 E 代表Element，一般用在集合的泛型场景 K 代表Key，一般和Value一起出现在键值对场景（如Entry&lt;K,V&gt;） V 代表Value，一般和Key一起出现在键值对场景（如Entry&lt;K,V&gt;） 还有些不太常见的如S，U… 泛型通配符如果在某些场景下我们不关注（或者不那么关注）泛型对象的类型参数，可以使用泛型通配符。 &lt;?&gt; 无限制的通配符，表示操作和类型无关 &lt;? extends T&gt; 类型参数必须是T或者T的子类 &lt;? super T&gt; 类型参数必须是T或者T的父类 123456789101112131415161718import java.util.Date;public class Main &#123; public static void main(String[] args) &#123; // 由于这里只需要知道方法是否成功，不需要处理返回的对象，所以可以使用通配符，这样就算以后返回值改了这里也不用改 Result&lt;?&gt; r1 = checkDate(); System.out.println(r1.isSuccess() ? \"成功\" : \"失败\"); &#125; private static Result&lt;Date&gt; checkDate() &#123; if (Math.random() &gt; 0.5) &#123; return Result.success(new Date()); &#125; return Result.error(\"system error\"); &#125;&#125; 类型擦除 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 12345678910111213141516171819202122232425import java.lang.reflect.Field;import java.util.Date;public class Main &#123; public static void main(String[] args) throws NoSuchFieldException &#123; Result&lt;Date&gt; r1 = Result.success(new Date()); Result&lt;Number&gt; r2 = Result.success(2.333); dataType(r1); dataType(r2); &#125; private static void dataType(Result&lt;?&gt; result) throws NoSuchFieldException &#123; Field field = result.getClass().getDeclaredField(\"data\"); System.out.println(field.getType().toString()); &#125;&#125;/* 输出:class java.lang.Objectclass java.lang.Object*/ 通过反射我们在运行时得到了data的类型，发现都是Object，证明代码编译后所谓泛型都没了，这就是泛型擦除。 但并不是任何时候都是Obejct，如果用了带限制的泛型又将不一样，大概这么个意思： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Result&lt;T extends Number&gt; &#123; private boolean success; private String message; private T data; public static &lt;T extends Number&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.success = true; r.data = data; return r; &#125; public static &lt;T extends Number&gt; Result&lt;T&gt; error(String message) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.message = message; return r; &#125; // getter &amp; setter&#125;public class Main &#123; public static void main(String[] args) throws NoSuchFieldException &#123; Result&lt;Double&gt; r1 = Result.success(2.333); Result&lt;Long&gt; r2 = Result.success(Long.MAX_VALUE); dataType(r1); dataType(r2); &#125; private static void dataType(Result&lt;?&gt; result) throws NoSuchFieldException &#123; Field field = result.getClass().getDeclaredField(\"data\"); System.out.println(field.getType().toString()); &#125;&#125;/* 输出:class java.lang.Numberclass java.lang.Number*/ 通过反射绕过泛型限制从上面例子可以感受到，所谓泛型，不过是编译过程及其之前才有的概念，主要还是为了方便开发。 最后搞个骚操作，通过反射绕过泛型限制。 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //正规途径 list.add(1); //反射大法 Method m = list.getClass().getMethod(\"add\", Object.class); m.invoke(list, 2); m.invoke(list, 3.21); m.invoke(list, \"对不起，我是字符串\"); m.invoke(list, new Date()); for (Integer x : list) &#123; System.out.println(x.getClass().getName() + \":\\t\" + x); &#125; &#125;&#125;/* 输出:java.lang.Integer: 1java.lang.Integer: 2Exception in thread \"main\" java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer at Main.main(Main.java:20)*/ 竟然报错了（当然是故意的，真的），看看错误信息，因为要把Double转为Integer导致异常。但我们发现前面的两个输出是成功的，证明程序能编译成功并运行。 略作调整： 1234567891011121314151617181920212223242526272829303132import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //正规途径 list.add(1); //反射大法 Method m = list.getClass().getMethod(\"add\", Object.class); m.invoke(list, 2); m.invoke(list, 3.21); m.invoke(list, \"对不起，我是字符串\"); m.invoke(list, new Date()); for (Object x : list) &#123; System.out.println(x.getClass().getName() + \":\\t\" + x); &#125; &#125;&#125;/* 输出:java.lang.Integer: 1java.lang.Integer: 2java.lang.Double: 3.21java.lang.String: 对不起，我是字符串java.util.Date: Sun Jul 28 23:49:34 CST 2019*/ 总结","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://acupt.github.io/tags/泛型/"},{"name":"类型擦除","slug":"类型擦除","permalink":"https://acupt.github.io/tags/类型擦除/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}]},{"title":"探索JAVA并发 - 如何处理线程中断","slug":"concurrent-interrupt","date":"2019-07-25T14:40:00.000Z","updated":"2019-07-25T16:00:22.032Z","comments":true,"path":"2019/07/25/concurrent-interrupt/","link":"","permalink":"https://acupt.github.io/2019/07/25/concurrent-interrupt/","excerpt":"","text":"中断是一种协作机制，通过这种机制可以要求指定线程在可以暂停的地方停止当前任务，但这个要求可以无视，我们也经常这么做（虽然不好），那应该这么对待其它线程发来的中断要求呢？ 在上一篇如何优雅地取消线程任务中提到了通过中断可以取消线程正在进行的任务，现在针对中断这件事情再来简单聊聊。 阻塞库如何抛出中断JAVA中有很多带阻塞方法的工具类，这种方法往往会声明一个受检查的异常InterruptedException，如果被中断，它会尝试提前结束阻塞状态，并抛给调用者一个InterruptedException异常，让对方决定何去何从。 用ArrayBlockingQueue.offer(E, long, TimeUnit)为例。 1234567891011121314151617181920212223242526public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; // 这里可能抛出中断异常： // 获取锁时如果线程已中断 or 等待锁时线程被中断 lock.lockInterruptibly(); try &#123; while (count == items.length) &#123; if (nanos &lt;= 0) return false; // 这里可能抛出中断异常：如果当前线程被中断 nanos = notFull.awaitNanos(nanos); &#125; enqueue(e); return true; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 传递中断如果捕获到一个中断异常不知道怎么处理它，那么可以考虑把这个烫手山芋扔出去，扔给你的上级（调用者），即传递中断。 传递方式1: 不捕获中断异常只要在方法上添加一个InterruptedException的声明，就能轻松把这个锅甩给调用者，因为此时你也成为了可中断大军的一员。既然解决不了，那就加入。 12345678910import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); queue.offer(new Object(), 1L, TimeUnit.MINUTES); &#125;&#125; 传递方式2: 捕获再抛出如果希望发生中断时自己可以做点扫尾操作，那么可以捕获中断异常，做点小动作后再抛出这个异常（你也可以抛出其它自定义异常）。 123456789101112131415import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); try &#123; queue.offer(new Object(), 1L, TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; System.out.println(\"有人想中断我，我从了\"); throw e; &#125; &#125;&#125; 恢复中断当我们捕获到中断异常的时候，如果再去调用Thread.isInterrupted()往往得到的是false，因为这件事只有一个人来处理就够了，所以抛出异常后会清除中断状态，比如Thread,sleep()。 123456789public class Thread implements Runnable &#123; /** * 强行翻译: 算了不翻译了，上篇写过 * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException; 因此，线程不方便抛出异常的时候（比如在实现Runnable，我们知道run()方法没有声明异常），我们可以捕获到中断异常后再次把线程状态置为中断。这件事我管不了， 谁爱管谁管。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(\"可有人想中断我？\" + isInterrupted()); sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(\"有人想中断我，我拒绝\"); System.out.println(isInterrupted()); interrupt(); &#125; &#125; &#125; &#125;; thread.start(); Thread.sleep(3000); thread.interrupt(); &#125;&#125;/* 输出可有人想中断我？false可有人想中断我？false可有人想中断我？false // 虽然下一步就捕获到中断，但这里依然是false，证明是在sleep时才被中断的有人想中断我，我拒绝false // 捕获到异常后，当前线程状态是“非中断”，但被我设为中断了可有人想中断我？true // 因为已经被我设为中断了有人想中断我，我拒绝 // 那人就是你自己啊false // 无限模式启动可有人想中断我？true有人想中断我，我拒绝false(略...)*/ 总结 线程处于中断状态表明有人想让它赶紧结束，但得到这个信号的线程可以做出自己的选择； 不要捕获到它却冷漠的不做任何响应（可以不爱，莫要伤害）。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.github.io/tags/线程/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}]},{"title":"探索JAVA并发 - 如何优雅地取消线程任务","slug":"concurrent-thread-cancel","date":"2019-07-24T14:00:00.000Z","updated":"2019-07-24T16:06:01.840Z","comments":true,"path":"2019/07/24/concurrent-thread-cancel/","link":"","permalink":"https://acupt.github.io/2019/07/24/concurrent-thread-cancel/","excerpt":"","text":"通过线程启动一个异步的任务很容易，但想让它提前安全且快速地结束确并不简单。如果线程外部的代码可以提前把目标线程置为“完成”状态，那么这个目标线程就是可取消的。 线程任务取消的原因一般有如下几种： 用户请求取消: 比如用户发起一个耗时操作后，不想等了，就点击了取消按钮，此时我们应该把还在执行的任务叫停； 时间限制: 某些流程可能很费时，我们要控制等待时间，当超时后需要取消掉任务； 程序事件: 某些线程之间可能正在配合完成某项工作，其中一个达到目标后告诉其它同事可以提前下班了； 系统异常: 如果由于依赖的服务或资源发生异常，导致工作干不下去了，那么可以提前取消； 程序关闭: 比如系统要重启，那么还在进行的任务应该取消。 取消标志一种常用的方法是在任务代码中加入一个“是否取消”的标志，任务定期去查看这个标志是否改变，如果被改变了就取消剩下的任务，此时如果想取消这个任务只需要修改它的标志，然后安静地等待其退出即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Worker worker = new Worker(); worker.start(); Thread.sleep(3000); worker.cancel(); &#125; public static class Worker extends Thread &#123; private volatile boolean cancelled; @Override public void run() &#123; while (!cancelled) &#123; System.out.println(\"搬砖五分钟，划水两小时\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; // 注意这里，后面会提到 e.printStackTrace(); &#125; &#125; System.out.println(\"溜了溜了\"); &#125; /** * 取消任务 */ public void cancel() &#123; cancelled = true; &#125; &#125;&#125;/* 输出:搬砖五分钟，划水两小时搬砖五分钟，划水两小时搬砖五分钟，划水两小时溜了溜了*/ 这种方式最为简单，而且非常安全，因为我们可以自己在代码中控制什么时候可以取消（如示例中每次执行一个循环都可以取消）。 缺点：调用取消的方法后线程并不能保证很快就退出，这取决于一个循环的执行速度，更可怕的是，如果里面有个阻塞操作，它可能永远无法退出。 解决：对于阻塞操作设置超时等待，防止永远阻塞。 中断线程中断是一种协作机制，通过这个机制通知某个线程，让它可以在合适的或可能的情况下停止任务。那么什么是合适/可能的情况呢？ 线程有个“interrupted”（被打断/中断）的状态，通过Thread的以下方法可以查看/修改这个状态 12345678910111213141516171819202122232425public class Thread implements Runnable &#123; // 中断目标线程 public void interrupt() &#123; //... &#125; // 返回是否中断 public boolean isInterrupted() &#123; return isInterrupted(false); &#125; // 清除中断状态，并返回在此之前是否中断 // 如果返回true，证明有人想中断这个线程，你需要正式这个问题: // 1.无视这个人的请求 // 2.帮他继续这个请求(再次调用interrupt恢复为中断状态) // 3.其它处理方式 // PS: 注意这是个static方法 public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; // 返回是否中断，参数为是否清除中断状态 private native boolean isInterrupted(boolean ClearInterrupted);&#125; 调用中断方法 interrupt() 并不会让目标线程立即停止任务，只是传递一个“可以停止”的信息给它。 当线程调用wait、sleep、join等会抛出InterruptedException的方法时，就是可以响应中断信号的时刻（因此这些时刻也被称为取消点） 12345678910111213public class Thread implements Runnable &#123; /** * 学渣强行翻译： * 如果任意线程中断了当前线程就会抛出此异常； * 这个异常抛出后当前线程的“中断”状态会被清空，即捕获异常后再调用isInterrupted()返回false * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException;&#125; 因此我们可以在程序中适当使用“取消点”方法，并对中断异常进行处理，回到上面的代码，线程每次输出一句话后都会sleep一秒，针对sleep方法抛出的异常，线程补捕获到后并没有做任何处理，而是把它吃了，现在我要充分利用它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Worker worker = new Worker(); worker.start(); Thread.sleep(3000); worker.interrupt(); &#125; public static class Worker extends Thread &#123; private volatile boolean cancelled; @Override public void run() &#123; while (!cancelled) &#123; System.out.println(\"搬砖五分钟，划水两小时\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(\"老板让我提前下班咯\"); break; &#125; &#125; System.out.println(\"溜了溜了\"); &#125; /** * 取消任务 */ public void cancel() &#123; cancelled = true; &#125; &#125;&#125;/* 输出: 搬砖五分钟，划水两小时搬砖五分钟，划水两小时搬砖五分钟，划水两小时老板让我提前下班咯溜了溜了*/ 使用了中断，我们的程序似乎提升了些许逼格，但阻塞操作带来的问题依然没有解决。不过我们还是建议使用中断来取消线程，甚至说通常情况下，中断是实现取消的最合理方式。 为什么这么说，因为很多包含阻塞操作的库函数实现了和中断机制的交互，简单说就是很多阻塞操作本身就会抛出InterruptedException异常。 举个例子，阻塞队列，它的阻塞方法定义了抛出异常InterruptedException，通过注释知道在等待时如果被中断了就会抛出这个异常。 12345678910111213public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; /** * (去掉无关注释) * * Inserts the specified element into this queue, waiting up to the * specified wait time if necessary for space to become available. * * @throws InterruptedException if interrupted while waiting */ boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;&#125; 让我们善用线程中断机制吧~","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.github.io/tags/线程/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}]},{"title":"探索JAVA并发 - 同步工具类","slug":"concurrent-sync-tool","date":"2019-07-23T14:00:00.000Z","updated":"2019-07-23T16:36:58.325Z","comments":true,"path":"2019/07/23/concurrent-sync-tool/","link":"","permalink":"https://acupt.github.io/2019/07/23/concurrent-sync-tool/","excerpt":"","text":"同步工具类是个笼统的概念，它可以根据自身状态来协调线程的控制流，了解JAVA中常用的同步工具能帮助开发者写出更好的并发代码。 闭锁 CountDownLatch闭锁的作用相当于一扇门，在这扇门没打开前，任何线程执行到这里都会被无情扣押，直到有人打开了这扇门，那些阻塞在门外的线程才会继续进行门后的流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.CountDownLatch;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; //第一扇门，需要1次触发即可打开 CountDownLatch firstDoor = new CountDownLatch(1); //第二扇门，需要3次触发才可打开 CountDownLatch lastDoor = new CountDownLatch(3); //启动3个线程 for (int i = 1; i &lt;= 3; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; System.out.println(id + \"号靓仔到达第一扇门前\"); firstDoor.await(); Thread.sleep((long) (Math.random() * 5000));//随机休息一会 System.out.println(id + \"号靓仔到达第二扇门前并触发\"); lastDoor.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; Thread.sleep(1000); //主线程打开第一扇门，让其他线程可以通过 firstDoor.countDown(); //等待其他线程合力打开第二扇门 lastDoor.await(); System.out.println(\"bye~\"); &#125;&#125;/* 输出:1号靓仔到达第一扇门前3号靓仔到达第一扇门前2号靓仔到达第一扇门前1号靓仔到达第二扇门前并触发2号靓仔到达第二扇门前并触发3号靓仔到达第二扇门前并触发bye~*/ 闭锁 FutureTaskFutureTask也可以用作闭锁，常与线程池一起使用，提交到线程池后，主线程（提交任务的线程）调用get()方法阻塞线程直到异步任务执行完毕或超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.concurrent.Callable;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 方式1：传入一个Callable，即业务代码执行完直接return FutureTask&lt;Liangzai&gt; callableTask = new FutureTask&lt;&gt;(new Callable&lt;Liangzai&gt;() &#123; @Override public Liangzai call() throws Exception &#123; Thread.sleep(1000); Liangzai liangzai = new Liangzai(); liangzai.name = \"callable\"; return liangzai; &#125; &#125;); // 方式2：传入一个runnable和一个存储结果的对象，在runnable中修改结果对象 Liangzai runableLiangzai = new Liangzai(); FutureTask&lt;Liangzai&gt; runableTask = new FutureTask&lt;&gt;(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); runableLiangzai.name = \"runable\"; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, runableLiangzai); // 异步给靓仔取名 new Thread(callableTask).start(); // 等待名字确定完毕 Liangzai liangzai = callableTask.get(); System.out.println(liangzai); // 异步给靓仔取名 new Thread(runableTask).start(); // 等待名字确定完毕 liangzai = runableTask.get(); System.out.println(liangzai); &#125; public static class Liangzai &#123; String name; @Override public String toString() &#123; return \"Liangzai&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125; &#125;&#125;/* 输出:Liangzai&#123;name='callable'&#125;Liangzai&#123;name='runable'&#125;*/ 信号量 Semaphore信号量用来控制同时“访问资源”或“执行操作”的线程数量，也可以用来实现资源池等。它管理着一组虚拟的“许可”，每当线程想访问某个特殊资源，需要先向它申请一个许可，用完后再返还许可，许可不足时将阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 初始化2个许可 Semaphore semaphore = new Semaphore(2); // 不想用线程池，用这个实现主线程等待所有子线程执行完毕 int n = 10; CountDownLatch countDownLatch = new CountDownLatch(n); for (int i = 1; i &lt;= n; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; // 申请一个许可 System.out.println(id + \"号想要1个许可\"); semaphore.acquire(); System.out.println(id + \"号得到1个许可\"); // 持有许可一段时间 Thread.sleep((long) (Math.random() * 10000)); // 归还许可 semaphore.release(); System.out.println(id + \"号归还1个许可\"); // 此线程完毕 countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:1号想要1个许可2号想要1个许可1号得到1个许可2号得到1个许可3号想要1个许可4号想要1个许可5号想要1个许可6号想要1个许可7号想要1个许可8号想要1个许可9号想要1个许可10号想要1个许可2号归还1个许可3号得到1个许可1号归还1个许可4号得到1个许可3号归还1个许可5号得到1个许可4号归还1个许可6号得到1个许可5号归还1个许可7号得到1个许可6号归还1个许可8号得到1个许可7号归还1个许可9号得到1个许可9号归还1个许可10号得到1个许可10号归还1个许可8号归还1个许可done~*/ 上面的代码，由于只有两个许可，所有前两个线程一说想要马上就得到了，第三个开始就开始了不算漫长的等待，下一次有线程得到许可是在有一个线程归还许可之后。 栅栏 CyclicBarrierCyclicBarrier类似于CountDownLatch，也是阻塞一组线程直到某个时间点，区别如下。 闭锁 CountDownLatch：等待一组线程全部完成某个任务，然后等待线程继续执行后续动作。结束后状态不会再改变 栅栏 CyclicBarrier：等待一组线程全部到达某个位置，然后该组线程继续执行后续动作，该组线程互相等待。状态可以重置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 定义一个栅栏，等待3个人到达后一起嗨皮 int n = 3; CyclicBarrier barrier = new CyclicBarrier(n, new Runnable() &#123; @Override public void run() &#123; // 全部人就绪后执行的操作 System.out.println(\"大家都到齐了，开始happy去\"); &#125; &#125;); // 不想用线程池，用这个实现主线程等待所有子线程执行完毕 CountDownLatch countDownLatch = new CountDownLatch(n); for (int i = 1; i &lt;= n; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; // 每个人出门打扮需要的时间都是不同的 Thread.sleep((long) (Math.random() * 5000)); // 等待其他人到达这里 System.out.println(id + \": 我到地方了\"); barrier.await(); System.out.println(id + \": let's go\"); // 此线程完毕 countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:3: 我到地方了2: 我到地方了1: 我到地方了大家都到齐了，开始happy去1: let's go3: let's go2: let's godone~*/ 栅栏 ExchangerExchanger是一种两方的栅栏，用于两方之间交换数据，一方发出消息后会阻塞直到对方接受到消息并返回一个消息，达到一人一句的和谐交流。当两方的操作不对称时很有用，比如一个线程往缓冲区写数据，一个线程从缓冲区读数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); CountDownLatch countDownLatch = new CountDownLatch(2); new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep((long) (Math.random() * 5000)); String fromKun = exchanger.exchange(\"我是小菜，No.\" + i); System.out.println(\"小菜收到消息：\" + fromKun); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;).start(); new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep((long) (Math.random() * 5000)); String fromKun = exchanger.exchange(\"我是阿坤，No.\" + i); System.out.println(\"阿坤收到消息：\" + fromKun); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;).start(); countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:小菜收到消息：我是阿坤，No.0阿坤收到消息：我是小菜，No.0阿坤收到消息：我是小菜，No.1小菜收到消息：我是阿坤，No.1阿坤收到消息：我是小菜，No.2小菜收到消息：我是阿坤，No.2小菜收到消息：我是阿坤，No.3阿坤收到消息：我是小菜，No.3阿坤收到消息：我是小菜，No.4小菜收到消息：我是阿坤，No.4done~*/ 总结所谓同步工具类并不特指实现某种功能的类，它们主要的价值就在于能帮助多线程之间更好地相互配合完成工作，只要对自己的需求清晰，对JAVA自带的类熟悉，就能选择合适的同步工具类，甚至实现自己需要的同步工具类。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.github.io/tags/线程/"},{"name":"并发","slug":"并发","permalink":"https://acupt.github.io/tags/并发/"},{"name":"同步","slug":"同步","permalink":"https://acupt.github.io/tags/同步/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}]},{"title":"探索JAVA并发 - ThreadLocal","slug":"concurrent_threadlocal","date":"2019-07-22T14:00:00.000Z","updated":"2019-07-22T16:30:10.048Z","comments":true,"path":"2019/07/22/concurrent_threadlocal/","link":"","permalink":"https://acupt.github.io/2019/07/22/concurrent_threadlocal/","excerpt":"","text":"使用ThreadLocal可以维持线程封闭性，使线程中的某个值与保存值的对象关联，防止对可变的单例变量或全局变量进行共享，但使用不当也会造成内存泄漏，先了解它，再使用它​。​ 从SimpleDateFormat说起SimpleDateFormat是我们常用的日期格式化工具，但熟悉的朋友都知道它是线程不安全的。 SimpleDateFormat用法1234567public class Acuptest &#123; public static void main(String[] args) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); System.out.println(sdf.format(new Date())); &#125;&#125; SimpleDateFormat线程不安全场景上面的用法完全没有问题，但现在spring无处不在，很多类都是以bean的形式存在于spring容器被各种共享，一不小心就会写成下面这种样子。 12345678public class Acuptest &#123; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); public String format(Date date) &#123; return sdf.format(date); &#125;&#125; 只是这样还看不出什么问题，但既然提到了SimpleDateFormat是线程不安全的，那么就看看为什么不安全。 SimpleDateFormat线程不安全分析进入源码，只看关键部分。 1234567891011121314151617181920212223242526272829303132333435public abstract class DateFormat extends Format &#123; // 一个成员变量 protected Calendar calendar; // 一个抽象方法 public abstract StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); // 提供给外部使用的方法 public final String format(Date date)&#123; return format(date, new StringBuffer(), DontCareFieldPosition.INSTANCE).toString(); &#125;&#125;public class SimpleDateFormat extends DateFormat &#123; // 实现了父类的抽象方法 @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)&#123; pos.beginIndex = pos.endIndex = 0; return format(date, toAppendTo, pos.getFieldDelegate()); &#125; private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // 到这里就能发现问题了，竟然给成员变量设置成了传进来的参数 // 在并发情况下calendar的值就不可信了，可能线程A前脚刚设置完准备执行下一条语句，线程B紧随其后就把值给改了 // Convert input date to time field list calendar.setTime(date); boolean useDateFormatSymbols = useDateFormatSymbols(); // 略 &#125;&#125; SimpleDateFormat线程安全用法使用局部变量只要不让多线程访问同一个对象，每次要用就new一个对象即可。 使用ThreadLocal很多时候某些对象往往不适合频繁创建、销毁，但它又像SimpleDateFormat那样线程不安全。这时候ThreadLocal就有用武之地了。 1234567891011121314public class Acuptest &#123; // 为每个线程单独分配一个SimpleDateFormat，线程内部可以复用，线程之间不能共享。 private ThreadLocal&lt;SimpleDateFormat&gt; sdf = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; // get()方法获取不到当前线程的SimpleDateFormat对象时，会调用此方法创建一个并绑定到线程 return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); &#125; &#125;; public String format(Date date) &#123; return sdf.get().format(date); &#125; ThreadLocal源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocal&lt;T&gt; &#123; //... // 获取当前线程绑定的对象，如果没有，将调用initialValue生成一个并绑定 public T get() &#123; // 获取当前线程 Thread t = Thread.currentThread(); // 从当前线程中取到一个MAP // key: ThreadLocal // value: ThreadLocal的泛型 &lt;T&gt; ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; // Thread对象可能还没创建ThreadLocalMap成员变量 // 或者ThreadLocalMap里没有当前ThreadLocal对象对应的&lt;T&gt;值 // 此时需要设置初始值 return setInitialValue(); &#125; // 获取线程里的MAP ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; // 设置初始值 private T setInitialValue() &#123; // 创建一个新的对象 T value = initialValue(); // 重新获取当前线程，因为没有参数接收线程信息 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); // 设置初始值 else createMap(t, value); // 创建MAP并设置初始值 return value; &#125; // 初始化一个对象，默认返回null，可在使用时重写此方法 protected T initialValue() &#123; return null; &#125; // ...&#125; Thread源码分析上面的源码中看到ThreadLocal多次使用Thread中的成员变量threadLocals，于是对Thread对象的结构再做个简单了解。 123456789101112131415161718192021222324252627282930313233343536public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // 略&#125;public class ThreadLocal&lt;T&gt; &#123; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; &#125;&#125; threadLocals和inheritableThreadLocals从Thread源码中可以看到ThreadLocal.ThreadLocalMa类型的成员变量有两个，有个是之前没有见过的inheritableThreadLocals，这个变量不是给ThreadLocal用的，而是给另一个类似的工具InheritableThreadLocal用的。 1234567891011121314public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125;&#125; 从源码上看，InheritableThreadLocal继承了ThreadLocal，然后使用的MAP换了，其他就没什么特别的。 但InheritableThreadLocal有着特殊的功能：它可以使用父线程的inheritableThreadLocals变量，实现父子线程共享变量。 InheritableThreadLocal为什么可以让子线程使用父线程的变量，关键的地方不在它，而在Thread类的初始化流程，Thread初始化时， 123456789101112131415161718public class Thread implements Runnable &#123; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; // 略 Thread parent = currentThread(); // 略 // inheritThreadLocals默认为true // 父线程inheritableThreadLocals不为空则复制一份 // 值复制，非引用复制 // 只是复制父线程当前拥有的对象 if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); // 略 &#125;&#125; ThreadLocal中的弱引用(WeakReference)从上面的源码中注意到: ThreadLocal.ThreadLocalMap.Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; Entry的key是ThreadLocal&lt;?&gt;，是个弱引用（被GC扫描到就回收）。如果不这样，当ThreadLocal&lt;?&gt;用完了，但线程还没结束，因此Thread里面还持有着ThreadLocal&lt;?&gt;的强引用，那么它永远不会被回收，可以认为内存泄漏了。 ThreadLocal的内存泄漏就算是使用了弱引用，依然存在内存泄漏的可能。因为弱引用仅仅是Entry的key(ThreadLocal)，value（泛型T）并不是弱引用。最终可能出现的结果就是，ThreadLocal被回收了，Thread里的MAP中KEY就没了，但value还在，这样一来这个value永远不会被get()方法返回，确又存在于内存不愿消散。 内部实现尽量避免内存泄漏： 在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。 如果没有调用这些方法去触发这个过程，依然会内存泄漏，所以在线程用完这个对象后，可以显示调用remove方法使其清除。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.github.io/tags/线程/"},{"name":"并发","slug":"并发","permalink":"https://acupt.github.io/tags/并发/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.github.io/categories/并发编程/"}]},{"title":"死锁的四大条件与处理策略","slug":"deadlock","date":"2019-07-21T14:40:00.000Z","updated":"2019-07-21T15:33:08.997Z","comments":true,"path":"2019/07/21/deadlock/","link":"","permalink":"https://acupt.github.io/2019/07/21/deadlock/","excerpt":"","text":"死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 比如：两个线程A、B各自持有一个无法共享的资源，并且他们都需要获取对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取，于是A等待B，B也在等待A。如此这般，死锁就产生了。 产生死锁的四个条件死锁的发生必须具备以下四个必要条件 互斥条件（Mutual exclusion）资源不能被共享，只能由一个进程使用。 请求与保持条件（Hold and wait）已经得到资源的进程可以再次申请新的资源。 不可剥夺条件（No pre-emption）已经分配的资源不能从相应的进程中被强制地剥夺。 环路/循环等待条件（Circular wait）系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。 了解四个必要条件后再来看看开始的例子： 两个线程各自持有一个无法共享(互斥条件)的资源，并且他们都需要获取（请求与保持条件）对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取(不可剥夺条件)，于是A等待B，B也在等待A（环路等待条件）。如此这般，死锁就产生了。 预防死锁通过破坏四个必要条件中的一个或多个，使死锁永远无法满足。实现简单，但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 预先资源分配法一次性申请所有需要的资源，只要有一种资源不满足要求，哪怕其它需要的资源都足够，也不做任何分配。这样一来就没有“保持”资源的状态，只有“请求”资源的状态，破坏了请求与保持条件。 有序资源分配法在申请不同类资源时，必须按指定顺序申请，破坏了环路等待条件。 正例：线程A、B申请资源顺序均为R1-&gt;R2； 反例：A申请顺序为R1-&gt;R2，B申请顺序为R2-&gt;R1。 避免死锁也是预发死锁，但不会事先去破坏死锁的必要条件，只是有人请求资源时，用某种方法防止系统进入不安全的状态（死锁），从而避免发生死锁。 银行家算法基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。 检测死锁和解除不采取措施防止死锁产生，允许系统产生死锁，但是可以通过一些手段检测出死锁，然后将死锁解除。 检测方法： 定时检测 效率低时检测 进程等待时检测 解除死锁方法： 根据具体业务场景，可以撤销或挂起死锁的进程/线程，使资源释放。","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"死锁","slug":"死锁","permalink":"https://acupt.github.io/tags/死锁/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"JAVA中的String真的不可变吗","slug":"java-string","date":"2019-07-17T15:00:00.000Z","updated":"2019-07-18T16:19:15.719Z","comments":true,"path":"2019/07/17/java-string/","link":"","permalink":"https://acupt.github.io/2019/07/17/java-string/","excerpt":"","text":"String是不可变的吗？是的！真想变？也行~ 我们都知道，String是不可变对象，即一旦创建，那么就不能改变它的状态。对此，我们来分析一波。 String的内部构造小心翼翼进入String的内部，我们可以看到它是一个final类，那么没人能继承它，很好，很丁克。 然后直接看向它的灵魂，一个char数组，也是final，于是我们知道它怎么不可变了。 1234567891011121314public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; // 略...&#125; 创建对象直接用常量给String变量赋值，不管在几个地方，几次，它们都是用的同一个数据。 除非new一个新的String。 123456789101112public class StringTest &#123; public static void main(String[] args) &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 123两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 利用反射修改值上面的代码后面再加点东西，尝试修改s1的值。 123456789101112131415161718192021222324252627282930313233public class StringTest &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); // 通过反射得到被String藏起来的value字段 Field f = String.class.getDeclaredField(\"value\"); // 让它敞开心扉 f.setAccessible(true); // 获取s1的内部value数组 char[] v = (char[]) f.get(s1); // 改掉它第一个字母 v[0] = 'x'; System.out.println(\"改变过后...\"); System.out.println(\"s1 = \" + s1); System.out.println(\"s2 = \" + s2); System.out.println(\"s3 = \" + s3); System.out.println(\"s4 = \" + s4); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 1234567891011两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false改变过后...s1 = xbcds2 = xbcds3 = xbcds4 = xbcd两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 总结1、String内部的value通过反射真的可以改变2、直接改动value会导致其它相同值的String对象也被改变（所以可以猜测底层实际上用的同一份数据？）3、虽然值都改变了，但作为对象，4个变量的关系依然没有改变（new的两个String和其他两个依然不等）4、这样做很危险5、这样做很无聊","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://acupt.github.io/tags/java/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}]},{"title":"CPU占用高如何排查","slug":"interview-cup-thread","date":"2019-07-17T14:30:00.000Z","updated":"2019-07-17T14:59:39.306Z","comments":true,"path":"2019/07/17/interview-cup-thread/","link":"","permalink":"https://acupt.github.io/2019/07/17/interview-cup-thread/","excerpt":"","text":"程序里少不了运算，如果不是环境太恶劣，CPU基本是能支撑应用运行的。但如果发现CPU居高不下，就需要思考是否程序有问题。 当服务器CPU居高不下，可以从下面几个方面入手定位问题。 找到JAVA进程 pid方法一: jps那个jar就是我的一个java程序 123456[root@iZba13i1mo82ot7a3lhq5oZ ~]# jps17616 Jps26016 jar9353 Bootstrap26028 Bootstrap16812 Bootstrap 方法二: ps -ef|grep 应用关键词和方法一找到的pid是相同的，26016 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -ef|grep acupjavaroot 17638 17550 0 22:34 pts/0 00:00:00 grep --color=auto acupjavaroot 26016 1 0 7月08 ? 00:05:11 java -jar acupjava-1.0-SNAPSHOT.jar 找到进程中CPU高的线程 tid打印出线程线程基本信息，找到cpu百分比高的一个或几个线程，记住它们的tid。 PS：栗子质量不好，全是0.0%，不要在意~ 123456789[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -mp 26016 -o THREAD,tid,timeUSER %CPU PRI SCNT WCHAN USER SYSTEM TID TIMEroot 0.0 - - - - - - 00:05:11root 0.0 19 - futex_ - - 26016 00:00:00root 0.0 19 - futex_ - - 26017 00:00:02root 0.0 19 - futex_ - - 26018 00:00:00root 0.0 19 - futex_ - - 26019 00:00:00root 0.0 19 - futex_ - - 26020 00:00:11(略...) 打印线程栈选择一个线程，把tid从10进制转为16进制 12[root@iZba13i1mo82ot7a3lhq5oZ ~]# printf \"%x\\n\" 2601765a1 为了方便查看可以把线程栈打印到文件里，jstack pid &gt;&gt; 文件名 使用ls查看文件已经存在 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# jstack 26016 &gt;&gt; stack.txt[root@iZba13i1mo82ot7a3lhq5oZ ~]# lstest stack.txt 找到占用CPU高的线程打开文件，搜索tid所在位置，可以看到线程栈，由此分析定位可能有问题的代码。 12345\"http-nio-9527-AsyncTimeout\" #29 daemon prio=5 os_prio=0 tid=0x00007fbf68973800 nid=0x65a1 waiting on condition [0x00007fbf48ab0000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1200) at java.lang.Thread.run(Thread.java:748) 如此这般，CPU高的问题基本就能定位出来了。（PS: 以上数据做了些许脱敏处理）","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"https://acupt.github.io/tags/cpu/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"内存泄漏如何排查","slug":"interview-oom-check","date":"2019-07-16T13:45:00.000Z","updated":"2019-07-16T15:00:32.013Z","comments":true,"path":"2019/07/16/interview-oom-check/","link":"","permalink":"https://acupt.github.io/2019/07/16/interview-oom-check/","excerpt":"","text":"JAVA的垃圾回收机制给了程序猿便利，我们可以不需要显式释放资源。但想高枕无忧却是不能，OOM像个隐藏在暗处的幽(hua)灵(nong)，威胁着可怜、弱小又漂亮的程序猿。 一般来说，一个健康的程序，它是不应该出现OOM的。内存里的对象从生到死，井然有序。但由于一些人为的失误，往往会让一些对象逃过GC的制裁，跳出GC外，不在垃圾中。这个时候，内存泄漏就发生了。 内存泄露，是指程序在申请内存并且用完这块内存后（对象不再需要了），没有释放已申请的内存空间。少数偶然的内存泄漏，虽然不太好，但问题不大，我们也不至于对那点内存抠抠搜搜的。但如果是内存不断泄漏，直到新的对象没有足够的空间生成，就会导致OOM。 什么时候可能内存泄漏抛出OOM异常当程序抛出OutOfMemoryError，如果你自认不是太抠，给了这个程序足够的空间，那么可以怀疑有内存泄漏 内存持续上升一个健康的程序应该有平稳的新陈代谢，内存占用应该维持在一定范围。但如果内存持续飙升，甚至到达了一个危险的值，那么可以怀疑有内存泄漏。 查看GC情况首先获取到应用的pid，可以使用java的jps命令，或者ps -ef|grep 应用名关键词 1234567891011121314151617/** * 启动个应用，持续造对象 */public class AcuptMain &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;Liangzai&gt; liangzais = new ArrayList&lt;&gt;(); while (true) &#123; liangzais.add(new Liangzai()); Thread.sleep(1000); &#125; &#125; private static class Liangzai &#123; byte[] body = new byte[1024 * 1024]; &#125;&#125; 1234567// 执行命令jps查看java进程➜ ~ jps11617 Launcher11618 AcuptMain1353 RemoteMavenServer1322 11627 Jps 123// 根据关键词查看，进程id为 11618 ，和jps查到的一致➜ ~ ps -ef|grep acupt 501 11618 1322 0 10:44下午 ?? 0:00.39 /Library/Java/JavaVirtualMachines... 123456789101112131415# 查看gc总体情况，各个区的使用率变化，3秒更新一次➜ ~ jstat -gcutil 11618 3000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 56.20 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 60.89 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 65.58 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 70.26 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 74.95 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 79.64 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 84.33 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 89.01 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 93.70 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 98.39 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 98.48 5.02 26.91 79.14 82.73 1 0.021 0 0.000 0.021 (以下略...) 可以看到Eden(E)持续造对象，并且满了之后，老年代(O)增加，E区腾空后继续造对象。（程序多执行一段时间，或者造对象速度提快点，最终会抛出OOM） 查看存活对象1234567891011121314// 查看存活对象，可以看到排名第一的是byte数组，而且多观察会会发现其数量也是一直在增加➜ ~ jmap -histo:live 11618 num #instances #bytes class name---------------------------------------------- 1: 644 103949616 [B 2: 4342 416736 [C 3: 4326 103824 java.lang.String 4: 721 82056 java.lang.Class 5: 746 49224 [Ljava.lang.Object; 6: 738 29520 java.util.LinkedHashMap$Entry 7: 609 19488 java.util.HashMap$Node 8: 303 19392 java.net.URL 9: 303 13560 [Ljava.lang.String; 根据存活对象的不正常增长情况，分析程序中哪些地方用到了这种对象，也可以大致推断出可能的内存泄漏处。","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.github.io/tags/jvm/"},{"name":"oom","slug":"oom","permalink":"https://acupt.github.io/tags/oom/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"JAVA GC 简析","slug":"interview-gc","date":"2019-07-15T15:00:00.000Z","updated":"2019-07-16T13:47:33.758Z","comments":true,"path":"2019/07/15/interview-gc/","link":"","permalink":"https://acupt.github.io/2019/07/15/interview-gc/","excerpt":"","text":"作为一个落魄的JAVA开发，在面试中常被问道：你是什么垃圾？哦不，是你对JAVA的垃圾回收机制有了解吗？ 接下来就对GC做一个全方位的总结，希望下次可以自信地回答面试官：我是可以被贵公司回收的那种。 GC的时机首先，根据内存区域不同，JVM工作模式不同，GC也有一些差别。 新生代（minor GC/young GC） PS: 新生代的内存空间可分为3个，Eden区(产生新生命的伊甸园)，from区和to区（GC时倒腾对象用的两个盘子） 当JVM无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以如果程序疯狂造对象，就会频繁触发GC。 老年代/永久代（major GC）/整个堆（full GC） 当一个对象经历了太多GC而不死，它会突破旧规则的束缚，飞升到老年代/永久代，成为新的存在，但并不代表着它可以不死，没有谁可以不死，尤其是新的地方也缺少资源的时候。而Major GC通常是跟full GC是等价的，收集整个GC堆。 升到永久代的对象大于永久代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc。 其它GC时机： 在程序中调用System.gc()函数，建议JVM做GC（注意只是建议，JVM有权无视程序猿的建议） 调参控制进入老年代/永久代的年龄（如果我记得肯定会写出来的，没搜，懒得搜） OOM之前（在放弃治疗抛出异常前总要做最后的努力吧） GC的目标 - 不使用的对象 当然是不使用的对象，还在使用的对象给回收了谁知道程序会跑成什么样子 那么什么是不使用的对象呢？ 超出作用域的对象/引用计数为空 引用计数法: 有人引用+1，被人抛弃-1。 优点：一旦没有引用即可释放内存，不需要等待特定时机，回收的时机也比较平均。 缺点：维护计数消耗资源（但问题不大），循环引用（大） 可达性分析，有gc root无法到达的对象 通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，无法到达的对象就是没用的。可以被当做root的对象，如：线程对象、本地变量、全局变量等。 这里又引入了引用的概念，强度从强到弱依次如下： 强引用：最常见的如 Object a = new Object()，即使OOM也不回收 软引用（SoftReference）：内存不够时回收 弱引用（WeakReference）：正常gc，被扫描到就回收 幻想引用（PhantomReference）：不可以获取/复活对象, 在垃圾回收时得到通知 GC的行为简单的说就是删除对象，回收空间。根据算法不同，具体的行为也有所不同，快没电了，就不写了（主要也没准备） 举个栗子： 1、停止其他线程，标记对象2、清理对象2.1、新生代-复制清理： Eden和from的存活对象复制到to，然后from和to交换，存活对象年龄+1，年龄到达阈值进入老年代/永久代2.2、老年代-标记清理/整理： 标记清理速度快，但有内存碎片 标记整理会移动存活对象，排除内存碎片","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.github.io/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"https://acupt.github.io/tags/gc/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"从0.5到1写个rpc框架 - 7:网关支持(gateway)","slug":"acuprpc-7","date":"2019-07-13T08:15:00.000Z","updated":"2019-07-13T08:39:29.148Z","comments":true,"path":"2019/07/13/acuprpc-7/","link":"","permalink":"https://acupt.github.io/2019/07/13/acuprpc-7/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 微服务除了在内部相互调用，有时某些服务也会提供给外部应用。当然不能让外部应用也加入到“大家庭”里，毕竟知人知面不知源码，我们可以派出一个“前台”去接待它们，这就是“网关”。 网关负责对接外部来宾，因此要做好安全措施，什么登陆、权限该上就上。 流程如下： 网关收到请求 解析请求（服务名，方法，参数等） 选择一个实例（来自注册中心） RPC调用 结果返回给请求方 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api\")public class ApiController &#123; /** * 动态调用rpc服务的关键，在acuprpc-spring-boot-starter中已经生成，可以随时引用 */ private RpcClientManager rpcClientManager; public ApiController(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @RequestMapping(method = RequestMethod.POST, produces = \"application/json\") public Object invoke(@RequestBody RpcRequestDTO requestDTO) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(requestDTO.getApp(), requestDTO.getService()); RpcClient client = rpcClientManager.lookup(serviceInfo);//获取一个可以提供所需服务的连接 RpcRequest request = new RpcRequest(requestDTO.getApp(), requestDTO.getService(), requestDTO.getMethod()); if (requestDTO.getParameters() != null) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); requestDTO.getParameters().forEach((k, v) -&gt; map.put(k, JsonUtil.toJson(v))); request.setNamedParameter(map); &#125; return client.invoke(request);//调用服务获得返回的json字符串 &#125;&#125; 这个demo作为一个子模块（acuprpc-spring-boot-starter-gateway）加入了框架的全家桶，直接引入依赖就能使用这个功能。 基于这个方法，可以实现更加复杂的也无需求，这里就不细讲了，本系列结束。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 6:调用异常节点自动重试","slug":"acuprpc-6","date":"2019-07-13T07:00:00.000Z","updated":"2019-07-13T08:16:36.330Z","comments":true,"path":"2019/07/13/acuprpc-6/","link":"","permalink":"https://acupt.github.io/2019/07/13/acuprpc-6/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc eureka client每隔30s向注册中心发送心跳来给自己续命，当注册中心长时间没收到client的信号，就会认为它挂掉了，把它提出群聊。再加上其它服务也按照一定频率更新本地缓存，因此往往不会那么及时地发现曾经的小伙伴已经下线了。导致的后果就是，会向不再存在的节点发送请求，结果连接异常。 对此，我们可以从框架层面加入一个重试机制，spring里面类似的机制也有，但既然在写自己的框架，那就自己实现一个。 在第一章里已经实现了通过动态代理执行远程调用，那么直接从这里入手，通过判断捕获的异常来判断是否需要重试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public Object invoke(Object proxy, Method method, Object[] args) &#123; if (\"toString\".equals(method.getName()) &amp;&amp; (args == null || args.length == 0)) &#123; return rpcServiceInfo.toString();//debug时老是被ide调用然后抛异常，很烦 &#125; RpcRequest rpcRequest = new RpcRequest(rpcServiceInfo.getAppName(), rpcServiceInfo.getServiceName(), method.getName()); if (args != null &amp;&amp; args.length &gt; 0) &#123; rpcRequest.setOrderedParameter(Arrays.stream(args).map(JsonUtil::toJson).collect(Collectors.toList())); &#125; int n = 3; // 最多重试3次，改成可配置的更好 int i = 0; RpcClient client = null; while (i++ &lt; n) &#123; try &#123; client = getRpcClient(); String res = client.invoke(rpcRequest); return JsonUtil.fromJson(res, TypeFactory.defaultInstance().constructType(method.getGenericReturnType())); &#125; catch (Exception e) &#123; if (client == null) &#123; throw e; &#125; boolean rediscover = needRediscover(e) &amp;&amp; i &lt; n; log.error(\"invoke &#123;&#125;/&#123;&#125; &#123;&#125; &#123;&#125; error=&#123;&#125; msg=&#123;&#125; rediscover=&#123;&#125;\", i, n, rpcRequest.getKey(), client.getNodeInfo(), e.getClass().getName(), e.getMessage(), rediscover); if (rediscover) &#123; try &#123; NodeInfo nodeInfo = rpcClientManager.selectNode(rpcServiceInfo, client.getNodeInfo()); client.reconnect(nodeInfo); continue; &#125; catch (RpcNotFoundException e1) &#123; e.addSuppressed(e1); &#125; &#125; throw e; &#125; &#125; throw new RuntimeException(\"invoke error\"); &#125; /** * 根据异常类型判断是否需要换个实例 */ private boolean needRediscover(Throwable e) &#123; while (e != null) &#123; if (e instanceof HttpStatusException) &#123; // 我自定义的异常类型，这里如果是服务不可用（程序虽然正常但不再提供服务） if (((HttpStatusException) e).getStatus() == NOT_AVAILABLE) &#123; return true; &#125; &#125; else if (e instanceof ConnectException) &#123; // 连接异常，想必是不在了 return true; &#125; e = e.getCause(); &#125; return false; &#125; 有了重试机制，就不怕某些家伙突然掉链子了，当然如果全部掉链子那就没得玩了。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 5:服务监控和管理(actuator)","slug":"acuprpc-5","date":"2018-11-29T06:00:00.000Z","updated":"2019-07-11T14:13:43.500Z","comments":true,"path":"2018/11/29/acuprpc-5/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-5/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc springboot项目中只要引入spring-boot-starter-actuator就可以得到一些管理服务的接口，比如停止服务，获取服务信息等。他用的并不是controller，而是Endpoint，不过主要功能差不多。 借住上节实现的filter机制，可以在不改动框架核心代码的基础上实现这个功能。作为实践写两个功能：获取服务端的统计数据、服务状态控制 新建模块 acuprpc-spring-boot-starter-actuator。 为了统一管理这个框架的endpoint，定义一个父类。所有子类的id默认加上“rpc”前缀 12345678910111213public abstract class AbstractRpcEndpoint&lt;T&gt; extends AbstractEndpoint&lt;T&gt; &#123; private static final String PREFIX = \"rpc\"; public AbstractRpcEndpoint(String id) &#123; super(PREFIX + id); &#125; public AbstractRpcEndpoint(String id, boolean sensitive) &#123; super(PREFIX + id, sensitive); &#125; public AbstractRpcEndpoint(String id, boolean sensitive, boolean enabled) &#123; super(PREFIX + id, sensitive, enabled); &#125;&#125; 数据统计MonitorFilter使用filter拦截请求，统计处理请求的数量。 12345678910111213141516171819202122232425262728293031323334@Getterpublic class MonitorFilter implements RpcFilter &#123; private Map&lt;String, RequestCount&gt; requestCountMap = new ConcurrentHashMap&lt;&gt;(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; RequestCount count = requestCountMap.computeIfAbsent(request.getKey(), RequestCount::new); count.received.increment(); count.invoking.increment(); try &#123; filterChain.doFilter(request, response); count.success.increment(); &#125; catch (Exception e) &#123; count.failed.increment(); throw e; &#125; finally &#123; count.invoking.decrement(); &#125; &#125; @Getter public static class RequestCount &#123; private String key; private LongAdder received = new LongAdder();//已接收 private LongAdder invoking = new LongAdder();//执行中 private LongAdder success = new LongAdder();//处理成功 private LongAdder failed = new LongAdder();//处理失败 public RequestCount(String key) &#123; this.key = key; &#125; &#125;&#125; RpcStatEndpoint提供http接口，通过 /rpcstat 即可获取invoke()的返回值。 1234567891011121314151617public class RpcStatEndpoint extends AbstractRpcEndpoint&lt;Map&lt;String, Object&gt;&gt; &#123; private MonitorFilter filter; public RpcStatEndpoint(MonitorFilter filter) &#123; super(\"stat\"); this.filter = filter; &#125; @Override public Map&lt;String, Object&gt; invoke() &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); Collection&lt;MonitorFilter.RequestCount&gt; counts = filter.getRequestCountMap().values(); result.put(\"counts\", counts); result.put(\"serving\", counts.stream().anyMatch(t -&gt; t.getInvoking().sum() &gt; 0L)); return result; &#125;&#125; 服务管理RejectFilter使用filter拦截请求，并在filter中维护一个下线状态，如果下线了则拒绝所有请求（针对这种返回值，客户端可以重新发现其他节点）。 123456789101112131415@Datapublic class RejectFilter implements RpcFilter &#123; private boolean reject = false; //拒绝请求的处理逻辑也可以自定义 private BiConsumer&lt;RpcRequest, RpcResponse&gt; rejectFunction = (rpcRequest, response) -&gt; response.reject(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; if (reject) &#123; rejectFunction.accept(request, response); return; &#125; filterChain.doFilter(request, response); &#125;&#125; EndpointMvcAdapterEndpoint使用很方便，但是相对controller不是那么灵活，比如我要让接口支持参数，就需要一些其他操作，将Endpoint使用EndpointMvcAdapter包装一次。为了复用，我写了个通用的EndpointMvcAdapter，通过反射去调用参数指定的方法。 1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class ReflectEndpointMvcAdapter extends EndpointMvcAdapter implements RpcCode &#123; private Map&lt;String, Method&gt; methodMap = new HashMap&lt;&gt;(); private Set&lt;String&gt; ipWhiteList = new HashSet&lt;&gt;(); public ReflectEndpointMvcAdapter(Endpoint&lt;?&gt; delegate, String ipWhiteList) &#123; super(delegate); Method[] methods = delegate.getClass().getMethods(); //... &#125; @RequestMapping(value = \"/&#123;name:.*&#125;\", method = RequestMethod.GET, produces = &#123; ActuatorMediaTypes.APPLICATION_ACTUATOR_V1_JSON_VALUE, MediaType.APPLICATION_JSON_VALUE &#125;) @ResponseBody @HypermediaDisabled public Object invoke(HttpServletRequest request, HttpServletResponse response, @PathVariable String name) &#123; if (!checkIp(request)) &#123; //... &#125; Method method = methodMap.get(name); //... try &#123; return method.invoke(getDelegate()); &#125; catch (Exception e) &#123; //... &#125; &#125; private boolean checkIp(HttpServletRequest request) &#123; //... &#125; private String getIp(HttpServletRequest request) &#123; //... &#125;&#125; RpcEndpoint因为要用ReflectEndpointMvcAdapter，invoke方法暂时没想到用什么（ /rpc 时调用），就返回null。 1234567891011121314151617181920212223242526272829public class RpcEndpoint extends AbstractRpcEndpoint&lt;Object&gt; implements RpcCode &#123; private RejectFilter filter; public RpcEndpoint(RejectFilter filter) &#123; super(\"\"); this.filter = filter; &#125; @Override public Object invoke() &#123; return null; &#125; public void online() &#123; filter.setReject(false); &#125; public void offline() &#123; filter.setReject(true); &#125; public int status() &#123; if (filter.isReject()) &#123; throw new HttpStatusException(NOT_AVAILABLE); &#125; return 0; &#125;&#125; 定义bean时包装 123456789@Beanpublic ReflectEndpointMvcAdapter rpcEndpoint(RejectFilter rejectFilter) &#123; return new ReflectEndpointMvcAdapter(process(new RpcEndpoint(rejectFilter)), ipWhiteList);&#125;private &lt;T extends AbstractRpcEndpoint&lt;?&gt;&gt; T process(T endpoint) &#123; endpoint.setSensitive(sensitive); return endpoint;&#125; 现在只要引入acuprpc-spring-boot-starter-actuator就能得到这几个http接口了，借助这几个接口服务可以优雅地重发。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"actuator","slug":"actuator","permalink":"https://acupt.github.io/tags/actuator/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 4:request filter","slug":"acuprpc-4","date":"2018-11-29T05:00:00.000Z","updated":"2019-07-11T14:13:38.714Z","comments":true,"path":"2018/11/29/acuprpc-4/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-4/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 为了后续扩展方便，搞个filter支持，就抄一个servlet的filter吧。 servlet filter 分析在写mvc项目时，经常会用到filter，可以给一个请求做前置或者后置处理。如下： 1234567891011121314151617181920@WebFilter(filterName = \"requestFilter\", urlPatterns = \"/*\")public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"filter init\"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"我进来了\"); chain.doFilter(request, response); System.out.println(\"我要走了\"); &#125; @Override public void destroy() &#123; System.out.println(\"filter destroy\"); &#125;&#125; 这是一种责任链模式的实现，debug看下调用栈可以了解框架是怎么实现的。 每次请求生成一个FilterChain对象，并使其持有所有filter的数组，初始化成员变量pos=0（表示应该执行第几个filter） 从FilterChain.doFilter开始调用整个链路，从第一个filter开始，调用时会把chain本身传给filter，pos自增 某个filter如果不拦截这个请求，则调用FilterChain.doFilter，由于pos已经自增，则会调用下一个filter filter全部调用后（pos=filters.length）,开始真正执行请求 请求返回后会依次再经过之前经过的所有filter（倒序） rpc filter 实现定义filter接口，使用者如果要添加过滤逻辑需要集成这个接口。 123public interface RpcFilter &#123; void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain);&#125; filter持有者 1234567891011121314151617181920212223242526272829public class RpcFilterChain implements RpcCode &#123; private RpcFilter[] filters = new RpcFilter[0]; private int pos; private RpcServiceInfo serviceInfo; private RpcServiceExecutor serviceExecutor;//最终要执行请求的处理器 public RpcFilterChain(List&lt;RpcFilter&gt; filterList, RpcServiceInfo serviceInfo, RpcServiceExecutor serviceExecutor) &#123; if (filterList != null &amp;&amp; !filterList.isEmpty()) &#123; this.filters = new RpcFilter[filterList.size()]; this.filters = filterList.toArray(this.filters); &#125; this.serviceInfo = serviceInfo; this.serviceExecutor = serviceExecutor; &#125; public void doFilter(RpcRequest request, RpcResponse response) &#123; if (pos &lt; filters.length) &#123; RpcFilter filter = filters[pos++]; filter.doFilter(request, response, this); return; &#125; if (serviceExecutor == null) &#123; response.error(SERVICE_NOT_FOUND, \"service not exist: \" + serviceInfo); return; &#125; serviceExecutor.execute(request, response); &#125;&#125; rpc server 接收到请求后先初始化一个责任链，然后触发。 1234567891011public RpcResponse execute(RpcRequest rpcRequest) &#123; RpcServiceInfo rpcServiceInfo = new RpcServiceInfo(rpcRequest.getAppName(), rpcRequest.getServiceName()); RpcFilterChain chain = new RpcFilterChain(filters, rpcServiceInfo, serviceExecutorMap.get(rpcServiceInfo)); RpcResponse rpcResponse = new RpcResponse(); try &#123; chain.doFilter(rpcRequest, rpcResponse); &#125; catch (Exception e) &#123; rpcResponse.error(e); &#125; return rpcResponse;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"filter","slug":"filter","permalink":"https://acupt.github.io/tags/filter/"},{"name":"责任链","slug":"责任链","permalink":"https://acupt.github.io/tags/责任链/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 3:远程服务调用(thrift)","slug":"acuprpc-3","date":"2018-11-29T04:00:00.000Z","updated":"2019-07-11T14:13:32.202Z","comments":true,"path":"2018/11/29/acuprpc-3/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-3/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc thrift是Facebook开源的rpc框架，基于TPC，默认使用二进制。 需要先掌握thrift的基本用法: thrift-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-thrift //基于thrift实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 thrift 通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 resources/service.thrift 123456789101112131415161718namespace java com.acupt.acuprpc.protocol.thrift.protoservice ThriftService&#123; InvokeResponse invokeMethod(1:InvokeRequest invokeRequest)&#125;struct InvokeRequest&#123;1: required string appName;2: required string serviceName;3: required string methodName;4: required list&lt;string&gt; orderedParameter;5: required map&lt;string,string&gt; namedParameter;&#125;struct InvokeResponse&#123;1: required i32 code;2: optional string message;3: optional string result;&#125; thrift-service这个类负责接收 thrift-client 发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给 thrift-client。 123456789101112131415161718192021222324public class ThriftService implements com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface &#123; private RpcServer rpcServer; public ThriftService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public InvokeResponse invokeMethod(InvokeRequest invokeRequest) &#123; RpcRequest rpcRequest = new RpcRequest( invokeRequest.getAppName(), invokeRequest.getServiceName(), invokeRequest.getMethodName(), invokeRequest.getOrderedParameter(), invokeRequest.getNamedParameter()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = new InvokeResponse(); response.setCode(rpcResponse.getCode()); response.setMessage(rpcResponse.getMessage()); response.setResult(rpcResponse.getResultString()); return response; &#125;&#125; thrift-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 由于thrift server 调用serve()方法后会阻塞线程，因此需要另外启动一个线程去开启服务。 123456789101112131415161718192021222324252627282930313233public class ThriftServer extends RpcServer &#123; private static final int nThreads = 100; private TServer server; public ThriftServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @Override protected void startRpc() &#123; new Thread(() -&gt; &#123; TProcessor tprocessor = new com.acupt.acuprpc.protocol.thrift.proto.ThriftService. Processor&lt;com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface&gt;(new ThriftService(this)); TServerTransport serverTransport = null; try &#123; serverTransport = new TServerSocket(getRpcInstance().getRpcConf().getPort()); &#125; catch (TTransportException e) &#123; throw new RpcException(e); &#125; TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.executorService(Executors.newFixedThreadPool(nThreads)); server = new TThreadPoolServer(tArgs); server.serve();//阻塞 &#125;).start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.setShouldStop(true); &#125; &#125;&#125; thrift-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成thrift支持的结构，并调用thrift的请求方法，再把远程服务返回的结果返回给代理类。 thrift client 是线程不安全的，从它提供的方法就能够看出来。 12345678910111213public void send_invokeMethod(InvokeRequest invokeRequest)&#123; //...&#125;public InvokeResponse recv_invokeMethod()&#123; //...&#125;public InvokeResponse invokeMethod(InvokeRequest invokeRequest) throws org.apache.thrift.TException&#123; send_invokeMethod(invokeRequest); return recv_invokeMethod();&#125; 为了简单直接在把方法设为 synchronized ，后续再使用对象池 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ThriftClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;ThriftService.Client&gt; clientRef; public ThriftClient(NodeInfo nodeInfo) &#123; super(nodeInfo); clientRef = new AtomicReference&lt;&gt;(getClient(nodeInfo)); &#125; //todo client线程不安全，使用连接池管理 @Override @SneakyThrows protected synchronized String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest request = new InvokeRequest(); request.setAppName(rpcRequest.getAppName()); request.setServiceName(rpcRequest.getServiceName()); request.setMethodName(rpcRequest.getMethodName()); request.setOrderedParameter(rpcRequest.getOrderedParameter()); InvokeResponse response = clientRef.get().invokeMethod(request); if (response.getCode() != SUCCESS) &#123; throw new HttpStatusException(response.getCode(), response.getMessage()); &#125; return response.getResult(); &#125; @Override protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //... &#125; @Override public void shutdownRpc() &#123; close(clientRef.get()); &#125; private ThriftService.Client getClient(NodeInfo nodeInfo) &#123; //... &#125; private void close(ThriftService.Client client) &#123; //... &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 2:远程服务调用(grpc)","slug":"acuprpc-2","date":"2018-11-29T03:00:00.000Z","updated":"2019-07-11T14:13:29.401Z","comments":true,"path":"2018/11/29/acuprpc-2/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-2/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc gRPC是Google开源的跨语言远程服务调用(RPC)框架，通信协议用的HTTP/2，数据传输默认用的protocol buffers（一种轻便高效的结构化数据存储格式，想比json更小更快，不过没有可读性）。 需要先掌握grpc的基本用法: gRPC-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-grpc //基于grpc实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 grpc通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 1234567891011121314151617181920212223242526syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.acuprpc.protocol.grpc.proto\";option java_outer_classname = \"GrpcServiceProto\";package com.acupt.acuprpc.protocol.grpc.proto;service GrpcService &#123; rpc invokeMethod (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string appName = 1; string serviceName = 2; string methodName = 3; repeated string orderedParameter = 4; map&lt;string, string&gt; namedParameter = 5;&#125;message InvokeResponse &#123; int32 code = 1; string message = 2; string result = 3;&#125; grpc-service这个类负责接收grpc-client发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给grpc-client。 1234567891011121314151617181920212223242526public class GrpcService extends GrpcServiceGrpc.GrpcServiceImplBase &#123; private RpcServer rpcServer; public GrpcService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void invokeMethod(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; RpcRequest rpcRequest = new RpcRequest( request.getAppName(), request.getServiceName(), request.getMethodName(), request.getOrderedParameterList(), request.getNamedParameterMap()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = InvokeResponse.newBuilder() .setCode(rpcResponse.getCode()) .setMessage(rpcResponse.getMessage()) .setResult(rpcResponse.getResultString()) .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; grpc-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 123456789101112131415161718192021222324public class GrpcServer extends RpcServer &#123; private Server server; public GrpcServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @SneakyThrows @Override protected void startRpc() &#123; server = ServerBuilder .forPort(getRpcInstance().getRpcConf().getPort()) .addService(new GrpcService(this)) .build().start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.shutdown(); &#125; &#125;&#125; grpc-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成grpc支持的结构，并调用grpc的请求方法，再把远程服务返回的结果返回给代理类。 12345678910111213141516171819202122232425262728293031323334353637public class GrpcClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;GrpcServiceGrpc.GrpcServiceFutureStub&gt; stubRef; public GrpcClient(NodeInfo nodeInfo) &#123; super(nodeInfo); this.stubRef = new AtomicReference&lt;&gt;(getStub(nodeInfo)); &#125; @Override protected String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest.Builder builder = InvokeRequest.newBuilder() .setAppName(rpcRequest.getAppName()) .setServiceName(rpcRequest.getServiceName()) .setMethodName(rpcRequest.getMethodName()); // ... ListenableFuture&lt;InvokeResponse&gt; future = stubRef.get().invokeMethod(builder.build()); InvokeResponse response = null; //... return response.getResult(); &#125; @Override @SneakyThrows protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //...使用参数中的ip和端口建立新连接，并断开老的连接，可用于重新负载和异常节点重试 &#125; @Override @SneakyThrows public void shutdownRpc() &#123; //...主动断开和服务端的连接 &#125; private GrpcServiceGrpc.GrpcServiceFutureStub getStub(NodeInfo nodeInfo) &#123; //...和服务端建立连接，使用参数中的ip和端口 &#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 1:服务注册/发现(eureka)","slug":"acuprpc-1","date":"2018-11-29T02:00:00.000Z","updated":"2019-07-11T14:13:22.585Z","comments":true,"path":"2018/11/29/acuprpc-1/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-1/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 123- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 Eureka Serverspring-cloud-starter-eureka-server Eureka Client原理就是利用eureka提供的客户端类来向Eureka Server发送注册请求，把自己提供服务的地址和端口（rpc服务端口，不是springboot启动的\bhttp端口）告诉注册中心，这样其他客户端（包括自身）就可以请求Eureka Server获取需要的服务节点信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 在服务中心注册的实例 */@Getter@Slf4jpublic class RpcInstance &#123; private EurekaClient eurekaClient; private ApplicationInfoManager applicationInfoManager; private RpcConf rpcConf; public RpcInstance(RpcConf rpcConf) &#123; RpcEurekaInstanceConfig instanceConfig = new RpcEurekaInstanceConfig(); instanceConfig.setAppGroupName(rpcConf.getAppGroup()); instanceConfig.setAppname(rpcConf.getAppName()); instanceConfig.setNonSecurePort(rpcConf.getPort()); instanceConfig.setIpAddress(IpUtil.INTRANET_IP); instanceConfig.setHostname(IpUtil.HOSTNAME); RpcEurekaClientConfig clientConfig = new RpcEurekaClientConfig(); clientConfig.getServiceUrl().put(\"default\", rpcConf.getDiscoveryServiceUrl()); clientConfig.setRegisterWithEureka(rpcConf.isRegisterWithDiscovery()); InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get(); this.applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo); this.eurekaClient = new DiscoveryClient(applicationInfoManager, clientConfig); this.rpcConf = rpcConf; log.info(\"protocol server -&gt; \" + rpcConf.getRpcServerClass()); log.info(\"protocol client -&gt; \" + rpcConf.getRpcClientClass()); &#125; public void start() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.STARTING); &#125; public void started() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP); &#125; public void shutdown() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN); eurekaClient.shutdown(); &#125; /** * 创建一个rpc server，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcServer newRpcServer() &#123; return rpcConf.getRpcServerClass().getConstructor(RpcInstance.class).newInstance(this); &#125; /** * 创建一个rpc client，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcClient newRpcClient(NodeInfo nodeInfo) &#123; return rpcConf.getRpcClientClass().getConstructor(NodeInfo.class).newInstance(nodeInfo); &#125;&#125; starter构建一个自己的spring boot starter，这样别的项目只需要引入这个依赖，就能使用starter提供的服务了。 1234- resources - META-INF spring.factories // 定义@Configuration类的路径，有了这个声明依赖starter的项目就能获得starter中提供的bean spring-configuration-metadata.json // 配置信息（可选），有了它在IDE中编辑application配置文件可以看到提示信息 rpc server 服务管理作为rpc服务提供者，需要在应用启动时把有注解（@Rpc）的服务管理起来，这样接收到rpc请求后可以快速查询到指定对象，执行指定方法。 实现接口BeanPostProcessor的bean即可得到处理spring中的所有bean（每个bean初始化完成后会调用接口方法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RpcServiceScanner implements BeanPostProcessor &#123; private RpcServer rpcServer; public RpcServiceScanner(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // AOP代理类需要拿到原始的类，不然读不到类上的注解 Class&lt;?&gt; beanClass = AopUtils.isAopProxy(bean) ? AopUtils.getTargetClass(bean) : bean.getClass(); val nrpc = beanClass.getAnnotation(Rpc.class); if (nrpc == null) &#123; return bean; &#125; Method[] methods = beanClass.getDeclaredMethods(); if (methods.length == 0) &#123; return bean; &#125; Map&lt;String, MethodInfo&gt; methodInfoMap = new HashMap&lt;&gt;(); for (Method method : methods) &#123; methodInfoMap.put(method.getName(), new MethodInfo(method)); &#125; Class&lt;?&gt;[] interfaces = beanClass.getInterfaces(); if (interfaces.length == 0) &#123; return bean; &#125; // client是通过接口调用server的，因此并不知道具体实现类的路径，只有接口名，因此把所有接口都注册一遍 for (Class&lt;?&gt; serviceInterface : interfaces) &#123; rpcServer.registerService( new RpcServiceInfo(rpcServer.getRpcInstance().getRpcConf().getAppName(), serviceInterface.getCanonicalName()), bean, serviceInterface, methodInfoMap); &#125; return bean; &#125;&#125; rpc client 远程服务代理作为服务调用者，可以通过接口像调用本地代码一样调用远程服务，原理就是为接口创建一个代理，在代理中进行远程调用。 这里使用主动创建代理的方式。 1234567891011121314151617public class RpcServiceConsumer &#123; private RpcClientManager rpcClientManager; public RpcServiceConsumer(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @SuppressWarnings(\"unchecked\") public &lt;T&gt; T create(String appName, Class&lt;T&gt; serviceInterface) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(appName, serviceInterface.getCanonicalName()); return (T) Proxy.newProxyInstance( serviceInterface.getClassLoader(), new Class&lt;?&gt;[]&#123;serviceInterface&#125;, new RpcInvocationHandler(serviceInfo, rpcClientManager)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class RpcInvocationHandler implements InvocationHandler &#123; private RpcServiceInfo rpcServiceInfo; private RpcServiceManager rpcServiceManager; private RpcClient rpcClient; public RpcInvocationHandler(RpcServiceInfo rpcServiceInfo, RpcServiceManager rpcServiceManager) &#123; this.rpcServiceInfo = rpcServiceInfo; this.rpcServiceManager = rpcServiceManager; tryInitRpcClient(false); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; RpcMethodInfo methodInfo = new RpcMethodInfo(rpcServiceInfo, method.getName(), method.getGenericReturnType()); return tryGetRpcClient().invoke(methodInfo, args); &#125; private RpcClient tryGetRpcClient() &#123; if (rpcClient == null) &#123; tryInitRpcClient(true); &#125; return rpcClient; &#125; private synchronized void tryInitRpcClient(boolean throwError) &#123; if (rpcClient != null) &#123; return; &#125; try &#123; rpcClient = rpcServiceManager.lookup(rpcServiceInfo); &#125; catch (Exception e) &#123; if (throwError) &#123; throw e; &#125; &#125; &#125;&#125; 注册一个ApplicationListener，接收springboot程序准备完后的信号，然后告诉注册中心准备好了。 12345678910111213public class RpcApplicationListener implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123; private RpcServer rpcServer; public RpcApplicationListener(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void onApplicationEvent(ApplicationReadyEvent event) &#123; rpcServer.started(); &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 0:前言","slug":"acuprpc-0","date":"2018-11-29T01:00:00.000Z","updated":"2019-08-01T16:55:58.239Z","comments":true,"path":"2018/11/29/acuprpc-0/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-0/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 最近在新公司开始接触微服务，在此之前并没有微服务的开发经验。对比了spring cloud和公司的rpc框架，对微服务这套东西终于有了一点粗浅的认知，为了加深理解，自己动手写个rpc框架玩玩。顺便记录下来，不然玩过的东西过段时间就忘了。 我的spring cloud的入门读物: 史上最简单的 SpringCloud 教程 我的学习成果: acuprpc 设计方案总的来说就是在现有工具上的二次开发。 服务注册/发现: eureka 这个模块spring cloud已经集成的非常易用了，实在没兴趣再整些骚操作，引入spring-cloud-starter-eureka-server依赖，启动类加个注解@EnableEurekaServer就是一个注册中心了。 远程服务调用: grpc/thrift grpc是Google开源的rpc框架，thrift是Facebook开源的rpc框架，而且他们都支持跨语言，都是很厉害的东西，需要用它们的规则定义数据结构，\b每个\b服务都定义一次是挺累的，如果只定义一个通用的服务，然后在这个服务里面通过Java反射去执行对应方法就可以少很多工作量了（把工作量变成了Java代码编写）。 至于选择这两种，因为都想试试，所以最终设计rpc框架是可以切换通信方式的，把这部分抽出来做成可扩展的即可。 目录// 只要列出来，总有一天会写完。 从0.5到1写个rpc框架 - 1:服务注册/发现(eureka) 从0.5到1写个rpc框架 - 2:远程服务调用(grpc) 从0.5到1写个rpc框架 - 3:远程服务调用(thrift) 从0.5到1写个rpc框架 - 4:request filter 从0.5到1写个rpc框架 - 5:服务监控和管理(actuator) 从0.5到1写个rpc框架 - 6:调用异常节点自动重试 从0.5到1写个rpc框架 - 7:网关支持(gateway)","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"thrift-Java 示例","slug":"thrift-start","date":"2018-11-20T12:00:00.000Z","updated":"2018-11-20T12:05:26.055Z","comments":true,"path":"2018/11/20/thrift-start/","link":"","permalink":"https://acupt.github.io/2018/11/20/thrift-start/","excerpt":"","text":"安装thriftmac brew install thrift 安装完成检查 thrift –version 新建maven项目pom.xml 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;libthrift&lt;/artifactId&gt; &lt;version&gt;0.11.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;thrift-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.10.0&lt;/version&gt; &lt;configuration&gt; &lt;thriftExecutable&gt;/usr/local/bin/thrift&lt;/thriftExecutable&gt; &lt;!--thrift安装路径--&gt; &lt;thriftSourceRoot&gt;src/main/resources&lt;/thriftSourceRoot&gt; &lt;!--thrift配置文件路径--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;thrift-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 定义服务新建文件 src/main/resources/service.thrift 1234namespace java com.acupt.thritf.serviceservice HelloService&#123; string hello(1:string name)&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现thrift远程调用。 target/generated-sources/thrift/com/acupt/thritf/service/HelloService.java 如果在项目中无法直接引用上面的类，IDEA右键\bthrift文件夹 -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 123456789101112131415package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TException;/** * 服务实现类 */public class HelloServiceImpl implements HelloService.Iface &#123; @Override public String hello(String name) throws TException &#123; return \"hello,\" + name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TProcessor;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.server.TServer;import org.apache.thrift.server.TSimpleServer;import org.apache.thrift.transport.TServerSocket;/** * 服务提供方 */public class MyServer &#123; public static void main(String args[]) &#123; try &#123; TProcessor tprocessor = new HelloService.Processor&lt;HelloService.Iface&gt;(new HelloServiceImpl()); TServerSocket serverTransport = new TServerSocket(50005); TServer.Args tArgs = new TServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.protocolFactory(new TBinaryProtocol.Factory()); TServer server = new TSimpleServer(tArgs); System.out.println(\"server starting\"); //定时关闭 new Thread(() -&gt; &#123; try &#123; System.out.println(\"server wait stop\"); Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"server stopping\"); server.stop(); System.out.println(\"server stop\"); &#125;).start(); server.serve();//会阻塞 System.out.println(\"server finish\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.protocol.TProtocol;import org.apache.thrift.transport.TSocket;import org.apache.thrift.transport.TTransport;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; TTransport transport = null; try &#123; transport = new TSocket(\"localhost\", 50005); TProtocol protocol = new TBinaryProtocol(transport); HelloService.Client client = new HelloService.Client(protocol); transport.open(); String result = client.hello(\"tom\"); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != transport) &#123; transport.close(); &#125; &#125; &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient。 和grpc用法\b差不多，gRPC-Java 示例","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"spring rabbitmq 异常重试源码分析","slug":"spring-rabbitmq-retry","date":"2018-11-15T03:00:00.000Z","updated":"2019-07-12T14:14:55.510Z","comments":true,"path":"2018/11/15/spring-rabbitmq-retry/","link":"","permalink":"https://acupt.github.io/2018/11/15/spring-rabbitmq-retry/","excerpt":"","text":"springboot集成rabbitMQ\b发消息123456789@Resourceprivate RabbitTemplate rabbitTemplate;@Value(\"$&#123;my.exchange&#125;\")private String exchange;public void send(Object obj) &#123; rabbitTemplate.convertAndSend(exchange, \"\", JsonUtils.toJson(obj));&#125; 处理消息1234@RabbitListener(queues = \"$&#123;msg.queue.my.exchange&#125;\")public void receive(String msg) &#123; //...&#125; 默认情况下，如果处理消息时抛出了异常，这个消息会一直重复消费（重复调用receive方法），直到没有抛异常。 消息接收/处理流程分析在@RabbitListener注解的方法里打个断点，观察下调用栈。 末端是个实现了Runnable的内部类SimpleMessageListenerContainer$AsyncMessageProcessingConsumer 123456789101112@Overridepublic void run() &#123; //…… //从这里可以看出只要这个消费者（consumer）状态满足会一直轮询去接收消息和消费消息 while (isActive(this.consumer) || this.consumer.hasDelivery() || !this.consumer.cancelled()) &#123; try &#123; boolean receivedOk = receiveAndExecute(this.consumer); // At least one message received //…… &#125; //…… &#125;&#125; 12345678910111213141516171819202122232425private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Throwable &#123; //NOSONAR Channel channel = consumer.getChannel(); for (int i = 0; i &lt; this.txSize; i++) &#123; logger.trace(\"Waiting for message from consumer.\"); Message message = consumer.nextMessage(this.receiveTimeout); if (message == null) &#123;break;&#125; try &#123; //如果获取到了消息就会去消费，这里最终会执行到我们写的listener方法 executeListener(channel, message); &#125; //当我们写的方法抛异常的时候就会来到这里 //发现嫌疑代码：consumer.rollbackOnExceptionIfNecessary(ex) catch (ImmediateAcknowledgeAmqpException e) &#123;/*……*/&#125; catch (Throwable ex) &#123; //NOSONAR if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;/*……*/&#125; if (this.transactionManager != null) &#123;/*没开事务，忽略*/&#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125; return consumer.commitIfNecessary(isChannelLocallyTransacted(channel));&#125; 12345678910111213141516171819202122public void rollbackOnExceptionIfNecessary(Throwable ex) throws Exception &#123; boolean ackRequired = !this.acknowledgeMode.isAutoAck() &amp;&amp; !this.acknowledgeMode.isManual(); try &#123; if (this.transactional) &#123;/*……*/&#125; if (ackRequired) &#123; boolean shouldRequeue = RabbitUtils.shouldRequeue(this.defaultRequeuRejected, ex, logger); for (Long deliveryTag : this.deliveryTags) &#123; // 最终会执行到这里 // With newer RabbitMQ brokers could use basicNack here... this.channel.basicReject(deliveryTag, shouldRequeue); &#125; if (this.transactional) &#123;/*……*/&#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"Application exception overridden by rollback exception\", ex); throw e; &#125; finally &#123; this.deliveryTags.clear(); &#125;&#125; 由上可看出，导致无限重试的两个值： ackRequired: 和ack模式相关 shouldRequeue: 和defaultRequeuRejected以及抛出的异常类型有关 根据需要修改acknowledgeMode或者defaultRequeuRejected即可，在配置文件中根据IDE补全提示可以找到这两个属性。 12spring.rabbitmq.listener.acknowledge-mode=nonespring.rabbitmq.listener.default-requeue-rejected=false 如果只是不想异常时重试，直接在业务代码中try…catch全部代码不让抛异常也行。 PS：验证这两个配置的时候发现不生效，一番debug发现项目里面自定义了一个工厂bean，创建消费者相关对象时用的那个工厂bean，而不是根据配置属性生成。 1234567@Beanpublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(new Jackson2JsonMessageConverter()); return factory;&#125; 注释掉这个bean那两个配置才生效，当然也可以在这个bean里设置那两个属性。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://acupt.github.io/tags/spring/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://acupt.github.io/tags/rabbitmq/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}]},{"title":"spring cloud 自定义配置源及配置刷新","slug":"spring-cloud-source-diy","date":"2018-10-29T07:19:56.000Z","updated":"2018-11-15T09:12:42.075Z","comments":true,"path":"2018/10/29/spring-cloud-source-diy/","link":"","permalink":"https://acupt.github.io/2018/10/29/spring-cloud-source-diy/","excerpt":"","text":"通过自定义配置源可以接入自己的配置服务，配合ContextRefresher可以让应用运行中自动更新配置。 实现PropertySourceLocator123456789101112131415161718/** * 自定义配置源 */public class MyPropertySourceLocator implements PropertySourceLocator &#123; @Override public PropertySource&lt;?&gt; locate(Environment environment) &#123; String msg = new SimpleDateFormat(\"HH:mm:ss\").format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"demo.diy.msg\", msg); System.err.println(\"MyPropertySourceLocator, demo.diy.msg = \" + msg); //spring自带的一个简单的map结构配置集合，也可以继承PropertySource自定义 MapPropertySource source = new MapPropertySource(\"my-source\", map); return source; &#125;&#125; 配置类123456789@Configurationpublic class MyConfigBootstrapConfiguration &#123; @Bean public MyPropertySourceLocator myPropertySourceLocator() &#123; return new MyPropertySourceLocator(); &#125;&#125; 用Java代码声明bean，还需要在resources/META-INF/spring.factories中声明 12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\com.netease.ag.demoweb.MyConfigBootstrapConfiguration Spring中类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 使用自定义配置123456789101112131415@RefreshScope //可更新@Component@Datapublic class ValueConfig &#123; @Value(\"$&#123;demo.copy.msg&#125;\") private String copyMsg; @Value(\"$&#123;demo.diy.msg&#125;\") private String diyMsg; public ValueConfig() &#123; System.err.println(\"ValueConfig init\"); &#125;&#125; application.properties中可以引用自定义配置 1demo.copy.msg=$&#123;demo.diy.msg&#125; springboot应用启动12345678910111213141516171819202122232425262728@SpringBootApplication@RestControllerpublic class DemowebApplication &#123; @Resource private ValueConfig valueConfig; @Resource private ContextRefresher contextRefresher; public DemowebApplication() &#123; System.err.println(\"DemowebApplication init\"); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemowebApplication.class, args); &#125; @RequestMapping(\"/t\") public String t() &#123; return valueConfig.toString(); &#125; //更新bean属性 @RequestMapping(\"/r\") public Object r() &#123; return contextRefresher.refresh(); &#125; 启动日志1234567891011121314 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)MyPropertySourceLocator, demo.diy.msg = 17:18:22...DemowebApplication init...ValueConfig init...Tomcat started on port(s): 8080 (http) 查询，多次请求返回一致 请求：http://localhost:8080/t响应：ValueConfig(copyMsg=17:18:22, diyMsg=17:18:22) 更新 请求：http://localhost:8080/r响应：[“demo.diy.msg”] 日志输出：1MyPropertySourceLocator, demo.diy.msg = 17:27:44 再次调用查询接口，发现值改变，并且输出日志 1ValueConfig init 证明更新字段实际是重新生成了一个bean","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"config","slug":"config","permalink":"https://acupt.github.io/tags/config/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"gRPC-Java 示例","slug":"grpc-start","date":"2018-10-23T12:19:56.000Z","updated":"2018-11-28T07:41:22.877Z","comments":true,"path":"2018/10/23/grpc-start/","link":"","permalink":"https://acupt.github.io/2018/10/23/grpc-start/","excerpt":"","text":"新建maven项目pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-all&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.3.0:exe:$&#123;os.detected.classifier&#125; &lt;/protocArtifact&gt; &lt;pluginId&gt;grpc-java&lt;/pluginId&gt; &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.5.0:exe:$&#123;os.detected.classifier&#125; &lt;/pluginArtifact&gt; &lt;!--*.proto文件目录--&gt; &lt;protoSourceRoot&gt;src/main/resources&lt;/protoSourceRoot&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;compile-custom&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 定义服务新建文件 src/main/resources/test.proto 1234567891011121314151617181920syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.grpc.proto\";option java_outer_classname = \"HelloProto\";package com.acupt.grpc;service HelloService &#123; rpc hello (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string name = 1;&#125;message InvokeResponse &#123; string msg = 1;&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现gRPC远程调用。 但在项目中还无法直接引用上面的类，右键\b -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 1234567891011121314151617181920212223package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.stub.StreamObserver;/** * 服务实现类 */public class HelloService extends HelloServiceGrpc.HelloServiceImplBase &#123; @Override public void hello(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; System.out.println(\"request -&gt; \" + request); String name = request.getName();//自定义的字段名 name InvokeResponse response = InvokeResponse.newBuilder() .setMsg(\"hello,\" + name)//自定义的字段名 msg .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; 12345678910111213141516171819202122232425package com.acupt.grpc;import io.grpc.Server;import io.grpc.ServerBuilder;import java.io.IOException;/** * 服务提供方 * * @author liujie */public class MyServer &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; int port = 50051; Server server = ServerBuilder.forPort(port) .addService(new HelloService()) .build() .start(); System.out.println(\"started\"); Thread.sleep(1000 * 60 * 2); server.shutdown(); System.out.println(\"shutdown\"); &#125;&#125; 123456789101112131415161718192021package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.Channel;import io.grpc.ManagedChannelBuilder;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; InvokeRequest request = InvokeRequest.newBuilder().setName(\"tom\").build(); Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 50051).usePlaintext(true).build(); HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); InvokeResponse response = blockingStub.hello(request); System.out.println(response.getMsg()); &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient 请求方式1.阻塞\b同步请求，接口返回前是阻塞的。 123HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);InvokeResponse response = blockingStub.hello(request);System.out.println(response.getMsg()); 2.Future调用后返回guava包里继承了Future的接口ListenableFuture（增加了listener支持），可以控制超时时间。 12345678910111213141516HelloServiceGrpc.HelloServiceFutureStub futureStub = HelloServiceGrpc.newFutureStub(channel);ListenableFuture&lt;InvokeResponse&gt; future = futureStub.hello(request);future.addListener( () -&gt; System.out.println(\"listener 1\"), command -&gt; &#123; System.out.println(\"execute 1 \" + command); command.run(); &#125;);future.addListener( () -&gt; System.out.println(\"listener 2\"), command -&gt; &#123; System.out.println(\"execute 2 \" + command); command.run(); &#125;);System.out.println(future.get(10, TimeUnit.SECONDS)); 3.回调调用接口传入回调函数，调用后马上返回。 123456789101112131415161718192021222324MyClient.done = false;HelloServiceGrpc.HelloServiceStub stub = HelloServiceGrpc.newStub(channel);stub.hello(request, new StreamObserver&lt;InvokeResponse&gt;() &#123; @Override public void onNext(InvokeResponse value) &#123; System.out.println(\"onNext \" + value); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \" + t.getMessage()); t.printStackTrace(); MyClient.done = true; &#125; @Override public void onCompleted() &#123; System.out.println(\"onCompleted\"); MyClient.done = true; &#125;&#125;);while (!MyClient.done) &#123; Thread.sleep(1000);&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"github+hexo搭建个人主页","slug":"github-hexo-homepage","date":"2018-05-20T07:41:09.000Z","updated":"2019-08-02T04:55:31.782Z","comments":true,"path":"2018/05/20/github-hexo-homepage/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-hexo-homepage/","excerpt":"","text":"作为技术人员，谁不曾想过有一个属于自己的网站。但因为种种原因（没时间、没技术、没钱…），往往只是想想。现在，一套完整的解决方案来帮助彷徨的你实现梦想~ 在下以前也尝试过搭建个人主页，前端+后端+服务器+域名，等这些都弄过一遍后，发现系统设计的太挫没有使用的欲望，也没有写博客的欲望。某天突然醒悟了，别搞那些花里胡哨的，好好找个现成的工具能搭建自己的网站就行，我都能想到，别人肯定早做出来了。 hexo，快速、简洁且高效的博客框架。hexo快速搭建博客（不写代码），基本无缝接入自己的md文档，配合github，服务器和域名也有了。 macOS Sierra github git nodejs hexo github个人主页创建官方教程 新建仓库我的github用户名是acupt，新建仓库，名为 acupt.github.io， git地址为 git@github.com:acupt/acupt.github.io.git github给你的个人主页地址为 https://acupt.github.io 修改主页访问主页地址将展示根目录下的index.html，如果没有的话展示README.md，也没有？告辞！ 这时候可以在index.html里面写主页代码了，不想写的继续往下。 hexo搭建个人主页安装hexo准备工作，请自行安装 nodejs git 开始安装hexo，新建一个文件夹并进入它 123npm install hexo-cli -ghexo initnpm install 启动hexo12hexo g # 生成文件，同 hexo generatehexo s # 启动服务，同 hexo server 启动成功后在浏览器访问 http://localhost:4000 写文章主目录下执行命令可新建一个md文件，也可以自己新建到source/_posts目录下 12345678hexo new &quot;文件名&quot; #新建文章hexo new page &quot;页面名&quot; #新建页面 # 常用简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 修改主题如果默认模板就能满足，此步骤可以跳过，但不找个酷炫的模板还怎么zhuangbility。 下载主题先找到你想象中的滑板鞋（ 官方模板库 ），克隆模板到hexo的themes目录下。 12# 我好不容易找到的酷炫模板git clone https://github.com/miccall/hexo-theme-Mic_Theme.git 但这个项目名不太友好，克隆成功后需要把文件夹重命名为模板名。 1mv hexo-theme-Mic_Theme miccall 主题模板配置编辑hexo主目录下的_config.yml，修改theme参数为新的主题名miccall 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: yiliatheme: miccall 修改模板的配置文件，在模板文件夹内也有个_config.yml，和hexo主目录下的_config.yml负责的东西不一样，hexo的配置管通用属性，模板的配置管个性参数，模板的项目首页一般都有配置教程。 模板可能有些地方不符合自己的需求，如果没法配置的话，除了给作者提issue，还可以自己改模板代码（反正代码在本地，可以为所欲为），比如我把这个模板的group（团队）布局用来展示自己的作品，那我就不需要QQ微信微博，只要个链接就行了，看文档没有相关参数隐藏，去代码里搜索了下，注释掉了那几行代码。 重启服务如果之前启动着，Ctrl+C关闭，后台运行的就kill掉。 123hexo clean # 清除缓存，会删除主目录下的public目录和数据库数据hexo ghexo s hexo发布个人主页到github编辑hexo主目录下的_config.yml，修改deploy配置 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:acupt/acupt.github.io.git branch: master 此配置表示用部署到git上，不过需要再安装一个插件。 1npm install hexo-deployer-git --save 发布 12hexo ghexo d 访问自己的github个人页面（如 https://acupt.github.io/ )，查看效果。 感谢miccall@github提供的酷炫模板，https://github.com/miccall/hexo-theme-Mic_Theme 技术性改进虽然这个主题很酷炫，但不可能每一点都如我所愿，如果主题作者未提供可配置选项，就需要对模板源代码做些改动。 先去主题项目的github主页fork一份到自己的github，再clone到本地。 links布局配置可选此主题的团队页面布局我很喜欢，但我并没有小伙伴想贴上去，那就做成作品展示页面好了。但是这个布局设计之初是为了展示人，所以有QQ、微信等信息配置，但我只想要一个‘链接’属性，其它的显示出来有点碍事。 IDE打开本地代码，全局搜索，就用属性名做关键词，果断在一个page-links.ejs文件中发现。 123456&lt;ul class=&quot;social&quot;&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 网上查一下语法，加个if判断。 1234567891011121314&lt;ul class=&quot;social&quot;&gt; &lt;% if (site.data.links[i].link != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].qq != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].wachat != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].weibo != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ul&gt; 妥了 https站内访问http资源受限部署到github后第二天发现我酷炫的作品展示页面不再酷炫了，样式有点诡异，打开调试界面 显然最上面那两个异常是问题所在（下面那个异常没影响，有空再研究） https协议的网站如果用http访问外部资源，往往会收到这种限制，这种情况最好统一一下，大家用同样的协议即可，显然我不能改github的协议，那只能改主题代码了 还是一波全局搜索，还是那个文件 12&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 改成https即可，但可以再优雅点 12&lt;link href=&quot;//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 发布，验证，搞定，顺便提了个pull request。 氪金项目:绑定自己的域名 友情提示：到了这步，再往下就需要氪金了。。。 虽然博客已经可以用了，但毕竟是个二级域名（acupt.github.io），如果想让自己的博客更有逼格，可以绑定一个自己的域名。 域名一般在阿里云或者腾讯云就可以买，比较方便，而且因为github服务器在国外，可以直接解析你的域名到github页面，无须备案。如果是自己买的国内服务器，那么想绑定域名则需要备案（在哪买服务器在哪备案），比较麻烦。 购买域名：国内玩家首选 阿里云 配置域名解析：购买域名后进入阿里云控制台，添加域名解析，记录类型选择CNAME，记录值为你的博客地址（acupt.github.io） 添加CNAME文件：在acupt.github.io仓库根目录添加一个文件CNAME（没有扩展名），内容是你的域名： 参考 我的 12acupt.cnwww.acupt.cn 我配置了两个域名，一个主域名acupt.cn，一个大家比较熟悉的www.acupt.cn（最后还是被重定向到主域名了），如果访问acupt.github.io也会被重定向到acupt.cn。 HTTPS支持：使用自己的域名后一般会变成http访问，因为你没有SSL证书。这个也是可以支持的，但由于我没操作过，就不写了。但我的网站仍然是https，为何？一开始我的绑定域名后是http，过了一两天有一个页面访问时被重定向成https，令人困惑。又过了几天，全部都是https了。。。网上没找到太多资料，似乎这是github一个没完全开放的功能？ 氪金项目:使用自己的服务器 不氪金，你怎么变强？ github虽好，速度是硬伤，如果想自己的博客访问速度更快，拥有一台服务器很重要。 当然开源中国的码云也提供了个人主页功能，速度虽然快点，但限制颇多，比如绑定自己的域名也要收钱（是的，还要再给开源中国钱，这钱买个服务器岂不快哉）。 推荐几个云服务器选择： 亚马逊：国外的公司，网站不太服务国人习惯，而且反馈问题一般要用英文，不太方便。 亚马逊可以薅羊毛，新用户绑定信用卡后有个最低级的云服务器一年使用权，注意要信用卡。当初搞了个一年的服务器，因为在国外，就趁机搭建了一个翻墙服务器爽了几天。 薅羊毛注意：一年到期不会自动消失，会开始扣费（信用卡），注意提前关闭，或者留意官方的英文提醒邮件，不然。。。（我想静静） 腾讯云：用过，没啥毛病，每天参与秒杀，运气好可以抢到很便宜而且性能不错的服务器。 阿里云：依然是国内玩家首选， 腾讯云和阿里云都有针对学生党的优惠，月租很便宜，相当于一个视频会员，社会人也没关系，新人也是有优惠的，不是新人？都是老相识了该氪就氪吧~ The End这篇帖子是2018年写的了，今天（2019-08-02）我又翻出来编bian辑shi了一下。所以我的博客其实已经换了个低调的主题了（时间会使人成熟）。 改进项目： 新增域名绑定 新增两项氪金项目","categories":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.github.io/categories/实践笔记/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://acupt.github.io/tags/hexo/"}],"keywords":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.github.io/categories/实践笔记/"}]},{"title":"github搭建个人maven仓库","slug":"github-repository","date":"2018-05-20T07:00:00.000Z","updated":"2019-07-24T13:37:13.505Z","comments":true,"path":"2018/05/20/github-repository/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-repository/","excerpt":"","text":"Maven对Java开发者来说是很常见的工具，有了它只需要在pom文件加几行代码就能引入第三方代码。如果想我们自己写的工具类也让别人通过这种方式使用，不妨借助github搭建个免费仓库。 核心原理就是在github上建立一个代码仓库来存储我们发布的jar包，不需要自己买服务器，买域名，这些github都能帮我们实现。 新建仓库 在github新建一个普通的仓库即可，我的仓库地址 https://github.com/acupt/repository.git 克隆到本地 123456789101112➜ github git clone https://github.com/acupt/repository.gitCloning into &apos;repository&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.➜ github cd repository ➜ repository git:(master) lsREADME.md➜ repository git:(master) pwd/Users/acupt/github/repository 发布到本地 用deploy命令发布项目，指定打包的文件输出到上一步克隆的本地仓库，在项目（我们需要发布到仓库的代码/jar包）根目录下执行以下指令 1mvn deploy -DaltDeploymentRepository=acupt-repository::default::file:/Users/acupt/github/repository/ 同步到远程仓库 不想用master可以新建个分支 123git branch snapshotgit push origin snapshotgit checkout snapshot git add/commit/push 12345678910111213141516171819202122232425262728➜ repository git:(snapshot) ✗ git add com/➜ repository git:(snapshot) ✗ git commit -m &quot;acupsession&quot;[snapshot 4409029] acupsession 12 files changed, 74 insertions(+) create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.sha1 create mode 100644 com/acupt/acupsession/maven-metadata.xml create mode 100644 com/acupt/acupsession/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/maven-metadata.xml.sha1 ➜ repository git:(snapshot) ✗ git pushCounting objects: 18, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (18/18), 12.50 KiB | 6.25 MiB/s, done.Total 18 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To https://github.com/acupt/repository.git 3951922..4409029 snapshot -&gt; snapshot➜ repository git:(snapshot) ✗ 测试到这里已经ok了，通过GitHub提供的域名可以下载maven依赖（但无法查看列表），地址： https://raw.github.com/acupt/repository/snapshot 接下来新建一个项目试着引用前面发布的jar包，需要在pom文件中增加远程仓库地址，当然也可以在maven配置文件中做全局配置。 新建maven项目 修改pom.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;acupt-repository&lt;/id&gt; &lt;url&gt;https://raw.github.com/acupt/repository/snapshot&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupsession&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 查看本地maven仓库，看看jar包有没有下载成功 12345678➜ acupsession cd ~/.m2/repository/com/acupt/acupsession/1.0-SNAPSHOT ➜ 1.0-SNAPSHOT lsacupsession-1.0-20180519.110225-1.jar acupsession-1.0-SNAPSHOT.jaracupsession-1.0-20180519.110225-1.jar.sha1 acupsession-1.0-SNAPSHOT.pomacupsession-1.0-20180519.110225-1.jar.tmp.sha1.tmp maven-metadata-acupt-repository.xmlacupsession-1.0-20180519.110225-1.pom maven-metadata-acupt-repository.xml.sha1acupsession-1.0-20180519.110225-1.pom.sha1 maven-metadata-acupt-repository.xml.tmp.sha1.tmpacupsession-1.0-20180519.110225-1.pom.tmp.sha1.tmp maven-metadata-snapshots.xml 可以看到已经有jar包了，至此一个属于你自己的maven仓库就完成了。 如果想让别人不需要添加你的仓库地址就能用你的jar包，那么就不能用自己搭建的私人仓库了，需要发布到大家公用的仓库里去，有专门的提供这种服务的公司，网上一搜就有，但不是免费的，告辞。","categories":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.github.io/categories/实践笔记/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"maven","slug":"maven","permalink":"https://acupt.github.io/tags/maven/"}],"keywords":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.github.io/categories/实践笔记/"}]}]}