{"meta":{"title":"一杯82年的JAVA","subtitle":null,"description":null,"author":"ACUPT","url":"https://acupt.github.io"},"pages":[{"title":"","date":"2018-09-21T10:01:16.566Z","updated":"2018-09-21T10:01:16.566Z","comments":true,"path":"README.html","permalink":"https://acupt.github.io/README.html","excerpt":"","text":"sourcemy hexo source"},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"gallery/index.html","permalink":"https://acupt.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2018-09-21T10:01:16.687Z","comments":true,"path":"tag/index.html","permalink":"https://acupt.github.io/tag/index.html","excerpt":"","text":""},{"title":"about me","date":"2018-05-20T08:00:00.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"about/index.html","permalink":"https://acupt.github.io/about/index.html","excerpt":"","text":"I’m fine, fuck you."},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2018-09-21T10:01:16.688Z","comments":true,"path":"work/index.html","permalink":"https://acupt.github.io/work/index.html","excerpt":"","text":""}],"posts":[{"title":"thrift-Java 示例","slug":"thrift-start","date":"2018-11-20T12:00:00.000Z","updated":"2018-11-20T12:05:26.055Z","comments":true,"path":"2018/11/20/thrift-start/","link":"","permalink":"https://acupt.github.io/2018/11/20/thrift-start/","excerpt":"","text":"安装thriftmac brew install thrift 安装完成检查 thrift –version 新建maven项目pom.xml 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;libthrift&lt;/artifactId&gt; &lt;version&gt;0.11.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;thrift-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.10.0&lt;/version&gt; &lt;configuration&gt; &lt;thriftExecutable&gt;/usr/local/bin/thrift&lt;/thriftExecutable&gt; &lt;!--thrift安装路径--&gt; &lt;thriftSourceRoot&gt;src/main/resources&lt;/thriftSourceRoot&gt; &lt;!--thrift配置文件路径--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;thrift-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 定义服务新建文件 src/main/resources/service.thrift 1234namespace java com.acupt.thritf.serviceservice HelloService&#123; string hello(1:string name)&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现thrift远程调用。 target/generated-sources/thrift/com/acupt/thritf/service/HelloService.java 如果在项目中无法直接引用上面的类，IDEA右键\bthrift文件夹 -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 123456789101112131415package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TException;/** * 服务实现类 */public class HelloServiceImpl implements HelloService.Iface &#123; @Override public String hello(String name) throws TException &#123; return \"hello,\" + name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TProcessor;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.server.TServer;import org.apache.thrift.server.TSimpleServer;import org.apache.thrift.transport.TServerSocket;/** * 服务提供方 */public class MyServer &#123; public static void main(String args[]) &#123; try &#123; TProcessor tprocessor = new HelloService.Processor&lt;HelloService.Iface&gt;(new HelloServiceImpl()); TServerSocket serverTransport = new TServerSocket(50005); TServer.Args tArgs = new TServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.protocolFactory(new TBinaryProtocol.Factory()); TServer server = new TSimpleServer(tArgs); System.out.println(\"server starting\"); //定时关闭 new Thread(() -&gt; &#123; try &#123; System.out.println(\"server wait stop\"); Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"server stopping\"); server.stop(); System.out.println(\"server stop\"); &#125;).start(); server.serve();//会阻塞 System.out.println(\"server finish\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.protocol.TProtocol;import org.apache.thrift.transport.TSocket;import org.apache.thrift.transport.TTransport;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; TTransport transport = null; try &#123; transport = new TSocket(\"localhost\", 50005); TProtocol protocol = new TBinaryProtocol(transport); HelloService.Client client = new HelloService.Client(protocol); transport.open(); String result = client.hello(\"tom\"); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != transport) &#123; transport.close(); &#125; &#125; &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient。 和grpc用法\b差不多，gRPC-Java 示例","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"spring rabbitmq 异常重试源码分析","slug":"spring-rabbitmq-retry","date":"2018-11-15T03:00:00.000Z","updated":"2018-11-19T12:09:26.575Z","comments":true,"path":"2018/11/15/spring-rabbitmq-retry/","link":"","permalink":"https://acupt.github.io/2018/11/15/spring-rabbitmq-retry/","excerpt":"","text":"springboot集成rabbitMQ\b发消息123456789@Resourceprivate RabbitTemplate rabbitTemplate;@Value(\"$&#123;my.exchange&#125;\")private String exchange;public void send(Object obj) &#123; rabbitTemplate.convertAndSend(exchange, \"\", JsonUtils.toJson(obj));&#125; 处理消息1234@RabbitListener(queues = \"$&#123;msg.queue.my.exchange&#125;\")public void receive(String msg) &#123; //...&#125; 默认情况下，如果处理消息时抛出了异常，这个消息会一直重复消费（重复调用receive方法），直到没有抛异常。 消息接收/处理流程分析在@RabbitListener注解的方法里打个断点，观察下调用栈。 末端是个实现了Runnable的内部类SimpleMessageListenerContainer$AsyncMessageProcessingConsumer 123456789101112@Overridepublic void run() &#123; //…… //从这里可以看出只要这个消费者（consumer）状态满足会一直轮询去接收消息和消费消息 while (isActive(this.consumer) || this.consumer.hasDelivery() || !this.consumer.cancelled()) &#123; try &#123; boolean receivedOk = receiveAndExecute(this.consumer); // At least one message received //…… &#125; //…… &#125;&#125; 12345678910111213141516171819202122232425private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Throwable &#123; //NOSONAR Channel channel = consumer.getChannel(); for (int i = 0; i &lt; this.txSize; i++) &#123; logger.trace(\"Waiting for message from consumer.\"); Message message = consumer.nextMessage(this.receiveTimeout); if (message == null) &#123;break;&#125; try &#123; //如果获取到了消息就会去消费，这里最终会执行到我们写的listener方法 executeListener(channel, message); &#125; //当我们写的方法抛异常的时候就会来到这里 //发现嫌疑代码：consumer.rollbackOnExceptionIfNecessary(ex) catch (ImmediateAcknowledgeAmqpException e) &#123;/*……*/&#125; catch (Throwable ex) &#123; //NOSONAR if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;/*……*/&#125; if (this.transactionManager != null) &#123;/*没开事务，忽略*/&#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125; return consumer.commitIfNecessary(isChannelLocallyTransacted(channel));&#125; 12345678910111213141516171819202122public void rollbackOnExceptionIfNecessary(Throwable ex) throws Exception &#123; boolean ackRequired = !this.acknowledgeMode.isAutoAck() &amp;&amp; !this.acknowledgeMode.isManual(); try &#123; if (this.transactional) &#123;/*……*/&#125; if (ackRequired) &#123; boolean shouldRequeue = RabbitUtils.shouldRequeue(this.defaultRequeuRejected, ex, logger); for (Long deliveryTag : this.deliveryTags) &#123; // 最终会执行到这里 // With newer RabbitMQ brokers could use basicNack here... this.channel.basicReject(deliveryTag, shouldRequeue); &#125; if (this.transactional) &#123;/*……*/&#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"Application exception overridden by rollback exception\", ex); throw e; &#125; finally &#123; this.deliveryTags.clear(); &#125;&#125; 由上可看出，导致无限重试的两个值： ackRequired: 和ack模式相关 shouldRequeue: 和defaultRequeuRejected以及抛出的异常类型有关 根据需要修改acknowledgeMode或者defaultRequeuRejected即可，在配置文件中根据IDE补全提示可以找到这两个属性。 12spring.rabbitmq.listener.acknowledge-mode=nonespring.rabbitmq.listener.default-requeue-rejected=false 如果只是不想异常时重试，直接在业务代码中try…catch全部代码不让抛异常也行。 PS：验证这两个配置的时候发现不生效，一番debug发现项目里面自定义了一个工厂bean，创建消费者相关对象时用的那个工厂bean，而不是根据配置属性生成。 1234567@Beanpublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(new Jackson2JsonMessageConverter()); return factory;&#125; 注释掉这个bean那两个配置才生效，当然也可以在这个bean里设置那两个属性。","categories":[{"name":"spring","slug":"spring","permalink":"https://acupt.github.io/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://acupt.github.io/tags/spring/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://acupt.github.io/tags/rabbitmq/"}],"keywords":[{"name":"spring","slug":"spring","permalink":"https://acupt.github.io/categories/spring/"}]},{"title":"spring cloud 自定义配置源及配置刷新","slug":"spring-cloud-source-diy","date":"2018-10-29T07:19:56.000Z","updated":"2018-11-15T09:12:42.075Z","comments":true,"path":"2018/10/29/spring-cloud-source-diy/","link":"","permalink":"https://acupt.github.io/2018/10/29/spring-cloud-source-diy/","excerpt":"","text":"通过自定义配置源可以接入自己的配置服务，配合ContextRefresher可以让应用运行中自动更新配置。 实现PropertySourceLocator123456789101112131415161718/** * 自定义配置源 */public class MyPropertySourceLocator implements PropertySourceLocator &#123; @Override public PropertySource&lt;?&gt; locate(Environment environment) &#123; String msg = new SimpleDateFormat(\"HH:mm:ss\").format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"demo.diy.msg\", msg); System.err.println(\"MyPropertySourceLocator, demo.diy.msg = \" + msg); //spring自带的一个简单的map结构配置集合，也可以继承PropertySource自定义 MapPropertySource source = new MapPropertySource(\"my-source\", map); return source; &#125;&#125; 配置类123456789@Configurationpublic class MyConfigBootstrapConfiguration &#123; @Bean public MyPropertySourceLocator myPropertySourceLocator() &#123; return new MyPropertySourceLocator(); &#125;&#125; 用Java代码声明bean，还需要在resources/META-INF/spring.factories中声明 12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\com.netease.ag.demoweb.MyConfigBootstrapConfiguration Spring中类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 使用自定义配置123456789101112131415@RefreshScope //可更新@Component@Datapublic class ValueConfig &#123; @Value(\"$&#123;demo.copy.msg&#125;\") private String copyMsg; @Value(\"$&#123;demo.diy.msg&#125;\") private String diyMsg; public ValueConfig() &#123; System.err.println(\"ValueConfig init\"); &#125;&#125; application.properties中可以引用自定义配置 1demo.copy.msg=$&#123;demo.diy.msg&#125; springboot应用启动12345678910111213141516171819202122232425262728@SpringBootApplication@RestControllerpublic class DemowebApplication &#123; @Resource private ValueConfig valueConfig; @Resource private ContextRefresher contextRefresher; public DemowebApplication() &#123; System.err.println(\"DemowebApplication init\"); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemowebApplication.class, args); &#125; @RequestMapping(\"/t\") public String t() &#123; return valueConfig.toString(); &#125; //更新bean属性 @RequestMapping(\"/r\") public Object r() &#123; return contextRefresher.refresh(); &#125; 启动日志1234567891011121314 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)MyPropertySourceLocator, demo.diy.msg = 17:18:22...DemowebApplication init...ValueConfig init...Tomcat started on port(s): 8080 (http) 查询，多次请求返回一致 请求：http://localhost:8080/t响应：ValueConfig(copyMsg=17:18:22, diyMsg=17:18:22) 更新 请求：http://localhost:8080/r响应：[“demo.diy.msg”] 日志输出：1MyPropertySourceLocator, demo.diy.msg = 17:27:44 再次调用查询接口，发现值改变，并且输出日志 1ValueConfig init 证明更新字段实际是重新生成了一个bean","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"config","slug":"config","permalink":"https://acupt.github.io/tags/config/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"gRPC-Java 示例","slug":"grpc-start","date":"2018-10-23T12:19:56.000Z","updated":"2018-11-28T07:41:22.877Z","comments":true,"path":"2018/10/23/grpc-start/","link":"","permalink":"https://acupt.github.io/2018/10/23/grpc-start/","excerpt":"","text":"新建maven项目pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-all&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.3.0:exe:$&#123;os.detected.classifier&#125; &lt;/protocArtifact&gt; &lt;pluginId&gt;grpc-java&lt;/pluginId&gt; &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.5.0:exe:$&#123;os.detected.classifier&#125; &lt;/pluginArtifact&gt; &lt;!--*.proto文件目录--&gt; &lt;protoSourceRoot&gt;src/main/resources&lt;/protoSourceRoot&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;compile-custom&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 定义服务新建文件 src/main/resources/test.proto 1234567891011121314151617181920syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.grpc.proto\";option java_outer_classname = \"HelloProto\";package com.acupt.grpc;service HelloService &#123; rpc hello (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string name = 1;&#125;message InvokeResponse &#123; string msg = 1;&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现gRPC远程调用。 但在项目中还无法直接引用上面的类，右键\b -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 1234567891011121314151617181920212223package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.stub.StreamObserver;/** * 服务实现类 */public class HelloService extends HelloServiceGrpc.HelloServiceImplBase &#123; @Override public void hello(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; System.out.println(\"request -&gt; \" + request); String name = request.getName();//自定义的字段名 name InvokeResponse response = InvokeResponse.newBuilder() .setMsg(\"hello,\" + name)//自定义的字段名 msg .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; 12345678910111213141516171819202122232425package com.acupt.grpc;import io.grpc.Server;import io.grpc.ServerBuilder;import java.io.IOException;/** * 服务提供方 * * @author liujie */public class MyServer &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; int port = 50051; Server server = ServerBuilder.forPort(port) .addService(new HelloService()) .build() .start(); System.out.println(\"started\"); Thread.sleep(1000 * 60 * 2); server.shutdown(); System.out.println(\"shutdown\"); &#125;&#125; 123456789101112131415161718192021package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.Channel;import io.grpc.ManagedChannelBuilder;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; InvokeRequest request = InvokeRequest.newBuilder().setName(\"tom\").build(); Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 50051).usePlaintext(true).build(); HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); InvokeResponse response = blockingStub.hello(request); System.out.println(response.getMsg()); &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient 请求方式1.阻塞\b同步请求，接口返回前是阻塞的。 123HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);InvokeResponse response = blockingStub.hello(request);System.out.println(response.getMsg()); 2.Future调用后返回guava包里继承了Future的接口ListenableFuture（增加了listener支持），可以控制超时时间。 12345678910111213141516HelloServiceGrpc.HelloServiceFutureStub futureStub = HelloServiceGrpc.newFutureStub(channel);ListenableFuture&lt;InvokeResponse&gt; future = futureStub.hello(request);future.addListener( () -&gt; System.out.println(\"listener 1\"), command -&gt; &#123; System.out.println(\"execute 1 \" + command); command.run(); &#125;);future.addListener( () -&gt; System.out.println(\"listener 2\"), command -&gt; &#123; System.out.println(\"execute 2 \" + command); command.run(); &#125;);System.out.println(future.get(10, TimeUnit.SECONDS)); 3.回调调用接口传入回调函数，调用后马上返回。 123456789101112131415161718192021222324MyClient.done = false;HelloServiceGrpc.HelloServiceStub stub = HelloServiceGrpc.newStub(channel);stub.hello(request, new StreamObserver&lt;InvokeResponse&gt;() &#123; @Override public void onNext(InvokeResponse value) &#123; System.out.println(\"onNext \" + value); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \" + t.getMessage()); t.printStackTrace(); MyClient.done = true; &#125; @Override public void onCompleted() &#123; System.out.println(\"onCompleted\"); MyClient.done = true; &#125;&#125;);while (!MyClient.done) &#123; Thread.sleep(1000);&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"github+hexo搭建个人主页","slug":"github-hexo-homepage","date":"2018-05-20T07:41:09.000Z","updated":"2018-10-24T12:19:39.537Z","comments":true,"path":"2018/05/20/github-hexo-homepage/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-hexo-homepage/","excerpt":"","text":"以前也尝试过搭建个人主页，前端+后端+服务器+域名，等这些都弄过一遍后，发现系统设计的太挫没有使用的欲望（还不如在开源中国写博客，页面美观还有人点赞）。某天突然明确了我的需求，一个酷炫的主面，一个可以看自己文章的页面，这些文章的资源最好具备通用性（比如.md），即可。 hexo，快速、简洁且高效的博客框架。hexo快速搭建博客（不写代码），基本无缝接入自己的md文档，配合github，服务器和域名也有了。 macOS Sierra github git nodejs hexo github个人主页创建官方教程 新建仓库我的github用户名是acupt，新建仓库，名为 acupt.github.io， git地址为 git@github.com:acupt/acupt.github.io.git github给你的个人主页地址为 https://acupt.github.io 修改主页访问主页地址将展示根目录下的index.html，如果没有的话展示README.md，也没有？告辞！ 这时候可以在index.html里面写主页代码了，不想写的继续往下。 hexo搭建个人主页安装hexo准备工作，请自行安装 nodejs git 开始安装hexo，新建一个文件夹并进入它 123npm install hexo-cli -ghexo initnpm install 启动hexo12hexo g # 生成文件，同 hexo generatehexo s # 启动服务，同 hexo server 启动成功后在浏览器访问 http://localhost:4000 写文章主目录下执行命令可新建一个md文件，也可以自己新建到source/_posts目录下 12345678hexo new &quot;文件名&quot; #新建文章hexo new page &quot;页面名&quot; #新建页面 # 常用简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 修改主题如果默认模板就能满足，此步骤可以跳过，但不找个酷炫的模板还怎么zhuangbility。 下载主题先找到你想象中的滑板鞋（ 官方模板库 ），克隆模板到hexo的themes目录下。 12# 我好不容易找到的酷炫模板git clone https://github.com/miccall/hexo-theme-Mic_Theme.git 但这个项目名不太友好，克隆成功后需要把文件夹重命名为模板名。 1mv hexo-theme-Mic_Theme miccall 主题模板配置编辑hexo主目录下的_config.yml，修改theme参数为新的主题名miccall 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: yiliatheme: miccall 修改模板的配置文件，在模板文件夹内也有个_config.yml，和hexo主目录下的_config.yml负责的东西不一样，hexo的配置管通用属性，模板的配置管个性参数，模板的项目首页一般都有配置教程。 模板可能有些地方不符合自己的需求，如果没法配置的话，除了给作者提issue，还可以自己改模板代码（反正代码在本地，可以为所欲为），比如我把这个模板的group（团队）布局用来展示自己的作品，那我就不需要QQ微信微博，只要个链接就行了，看文档没有相关参数隐藏，去代码里搜索了下，注释掉了那几行代码。 重启服务如果之前启动着，Ctrl+C关闭，后台运行的就kill掉。 123hexo clean # 清除缓存，会删除主目录下的public目录和数据库数据hexo ghexo s hexo发布个人主页到github编辑hexo主目录下的_config.yml，修改deploy配置 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:acupt/acupt.github.io.git branch: master 此配置表示用部署到git上，不过需要再安装一个插件。 1npm install hexo-deployer-git --save 发布 12hexo ghexo d 访问自己的github个人页面（如 https://acupt.github.io/ )，查看效果。 感谢miccall@github提供的酷炫模板，https://github.com/miccall/hexo-theme-Mic_Theme 技术性改进虽然这个主题很酷炫，但不可能每一点都如我所愿，如果主题作者未提供可配置选项，就需要对模板源代码做些改动。 先去主题项目的github主页fork一份到自己的github，再clone到本地。 links布局配置可选此主题的团队页面布局我很喜欢，但我并没有小伙伴想贴上去，那就做成作品展示页面好了。但是这个布局设计之初是为了展示人，所以有QQ、微信等信息配置，但我只想要一个‘链接’属性，其它的显示出来有点碍事。 IDE打开本地代码，全局搜索，就用属性名做关键词，果断在一个page-links.ejs文件中发现。 123456&lt;ul class=&quot;social&quot;&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 网上查一下语法，加个if判断。 1234567891011121314&lt;ul class=&quot;social&quot;&gt; &lt;% if (site.data.links[i].link != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].qq != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].wachat != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].weibo != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ul&gt; 妥了 https站内访问http资源受限部署到github后第二天发现我酷炫的作品展示页面不再酷炫了，样式有点诡异，打开调试界面 显然最上面那两个异常是问题所在（下面那个异常没影响，有空再研究） https协议的网站如果用http访问外部资源，往往会收到这种限制，这种情况最好统一一下，大家用同样的协议即可，显然我不能改github的协议，那只能改主题代码了 还是一波全局搜索，还是那个文件 12&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 改成https，搞定 再优雅点 12&lt;link href=&quot;//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 发布，验证，搞定，顺便提个pull request","categories":[{"name":"dev","slug":"dev","permalink":"https://acupt.github.io/categories/dev/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://acupt.github.io/tags/hexo/"}],"keywords":[{"name":"dev","slug":"dev","permalink":"https://acupt.github.io/categories/dev/"}]},{"title":"github搭建个人maven仓库","slug":"github-repository","date":"2018-05-20T07:00:00.000Z","updated":"2018-10-24T12:19:45.434Z","comments":true,"path":"2018/05/20/github-repository/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-repository/","excerpt":"","text":"新建仓库 在github新建一个普通的仓库即可，我的仓库地址 https://github.com/acupt/repository.git 克隆到本地 123456789101112➜ github git clone https://github.com/acupt/repository.gitCloning into &apos;repository&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.➜ github cd repository ➜ repository git:(master) lsREADME.md➜ repository git:(master) pwd/Users/yunpian/github/repository 发布到本地 用deploy命令发布项目，指定打包的文件输出到上一步克隆的本地仓库，在项目根目录下执行以下指令 1mvn deploy -DaltDeploymentRepository=acupt-repository::default::file:/Users/yunpian/github/repository/ 同步到远程仓库 不想用master可以新建个分支 123git branch snapshotgit push origin snapshotgit checkout snapshot git add/commit/push 12345678910111213141516171819202122232425262728➜ repository git:(snapshot) ✗ git add com/➜ repository git:(snapshot) ✗ git commit -m &quot;acupsession&quot;[snapshot 4409029] acupsession 12 files changed, 74 insertions(+) create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.sha1 create mode 100644 com/acupt/acupsession/maven-metadata.xml create mode 100644 com/acupt/acupsession/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/maven-metadata.xml.sha1 ➜ repository git:(snapshot) ✗ git pushCounting objects: 18, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (18/18), 12.50 KiB | 6.25 MiB/s, done.Total 18 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To https://github.com/acupt/repository.git 3951922..4409029 snapshot -&gt; snapshot➜ repository git:(snapshot) ✗ 测试到这里已经ok了，通过GitHub提供的域名可以下载maven依赖，但无法查看列表，地址： https://raw.github.com/acupt/repository/snapshot 新建maven项目 修改pom.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;acupt-repository&lt;/id&gt; &lt;url&gt;https://raw.github.com/acupt/repository/snapshot&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupsession&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 查看本地maven仓库，看看jar包有没有下载成功 12345678➜ acupsession cd ~/.m2/repository/com/acupt/acupsession/1.0-SNAPSHOT ➜ 1.0-SNAPSHOT lsacupsession-1.0-20180519.110225-1.jar acupsession-1.0-SNAPSHOT.jaracupsession-1.0-20180519.110225-1.jar.sha1 acupsession-1.0-SNAPSHOT.pomacupsession-1.0-20180519.110225-1.jar.tmp.sha1.tmp maven-metadata-acupt-repository.xmlacupsession-1.0-20180519.110225-1.pom maven-metadata-acupt-repository.xml.sha1acupsession-1.0-20180519.110225-1.pom.sha1 maven-metadata-acupt-repository.xml.tmp.sha1.tmpacupsession-1.0-20180519.110225-1.pom.tmp.sha1.tmp maven-metadata-snapshots.xml 运气不错，成功了。","categories":[{"name":"dev","slug":"dev","permalink":"https://acupt.github.io/categories/dev/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"maven","slug":"maven","permalink":"https://acupt.github.io/tags/maven/"}],"keywords":[{"name":"dev","slug":"dev","permalink":"https://acupt.github.io/categories/dev/"}]}]}