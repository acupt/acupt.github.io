{"meta":{"title":"一杯82年的JAVA","subtitle":null,"description":"大家好，我是练习时常两年半的JAVA练习生，爱好是Coding、Technology、Reading、Learning","author":"ACUPT","url":"https://acupt.cn"},"pages":[{"title":"","date":"2019-09-09T16:09:41.839Z","updated":"2019-09-09T16:09:41.839Z","comments":true,"path":"README.html","permalink":"https://acupt.cn/README.html","excerpt":"","text":"一杯82年的JAVA 大家好，我是练习时常两年半的JAVA练习生，爱好是 Coding、Technology、Reading、Learning 博客专用仓库，主要记录一些学习和实践的总结，感兴趣的朋友可以点个watch或star。 随笔 从TCP的三次握手和四次挥手说起 JAVA中有趣的移位操作 JAVA中有趣的位运算 跨域Access-Control-Allow-Origin解决方案 源码分析 - JVM关闭钩子的注册和调用 JAVA泛型与类型擦除 死锁的四大条件与处理策略 JAVA中的String真的不可变吗 CPU占用高如何排查 内存泄漏如何排查 JAVA GC 简析 thrift-Java 示例 gRPC-Java 示例 spring rabbitmq 异常重试源码分析 github+hexo搭建个人主页 github搭建个人maven仓库 探索JAVA并发 并发容器全家福 终于搞懂了sleep/wait/notify/notifyAll 悲观锁和乐观锁 可重入锁和不可重入锁 如何减少锁的竞争 线程池详解 如何处理线程中断 如何优雅地取消线程任务 同步工具类 ThreadLocal 从0.5到1写个RPC框架 0:前言 1:服务注册/发现(eureka) 2:远程服务调用(grpc) 3:远程服务调用(thrift) 4:request filter 5:服务监控和管理(actuator) 6:调用异常节点自动重试 7:网关支持(gateway)"},{"title":"关于","date":"2019-09-09T14:09:21.812Z","updated":"2019-09-09T14:09:21.812Z","comments":true,"path":"about/index.html","permalink":"https://acupt.cn/about/index.html","excerpt":"","text":"大家好，我是练习时常两年半的JAVA练习生，爱好是 Coding、Technology、Reading、Learning 此博客以JAVA为主，时常分享一些学习和实践方面的干货 如果对我的文章感兴趣，期待您关注我的同名公众号 关注后回复“加群”，加入技术交流微信群，与我们一起探索问题，交流技术，分享知识 PS：也可以直接加我微信邀请入群（acuptz），广告营销勿扰"},{"title":"","date":"2019-08-04T10:04:49.203Z","updated":"2019-08-04T09:39:57.229Z","comments":true,"path":"p/ca/captcha-dlg.css","permalink":"https://acupt.cn/p/ca/captcha-dlg.css","excerpt":"","text":".ggdoor_dlg { position: relative; height: auto; /*width: 500px;*/ } .ggdoor_switch { text-align: center; line-height: 30px; background-color: #F7F9FA; color: #45494c; cursor: pointer; border: 1px solid lightgray; } .ggdoor_switch:hover { color: #3F91F2; } .ggdoor_body { position: absolute; left: 0; top: 0; height: auto; width: 100%; display: none; border: 1px solid lightgray; background-color: #F7F9FA; } .ggdoor_main { position: absolute; height: auto; left: 10px; top: 10px; bottom: 10px; } .ggdoor_bg { position: absolute; width: 100%; height: auto; /*left: 10px;*/ /*top: 10px;*/ } .ggdoor_bg_img { position: absolute; width: 100%; height: auto; } .ggdoor_bg_patch { position: absolute; /*width: auto;*/ /*height: auto;*/ } .ggdoor_slider { position: absolute; /*left: 0;*/ width: 40px; height: 40px; border-radius: 2px; border: 1px solid lightgray; } .ggdoor_slider_icon { background-image: url('icons.png'); background-position: 0 -26px; background-size: 32px 544px; width: 14px; height: 10px; display: inline-block; position: absolute; left: 12px; top: 15px; } .ggdoor_tips { position: absolute; bottom: 0; /*left: 10px;*/ border: 1px solid lightgray; width: 100%; height: 40px; text-align: center; color: gray; line-height: 40px; }"},{"title":"","date":"2019-08-05T10:16:34.794Z","updated":"2019-08-05T10:16:34.794Z","comments":true,"path":"p/ca/captcha-sdk.js","permalink":"https://acupt.cn/p/ca/captcha-sdk.js","excerpt":"","text":"function configDoor(config) { _doorConfig = config; var url = \"/ca/img?callback=_afterGetImg\"; _doGet(url); var css = document.createElement('link'); css.rel = 'stylesheet'; css.href = \"captcha-dlg.css\"; //todo 真实可被外部引用的地址 document.head.appendChild(css); } function _showDoor() { document.getElementById(\"ggdoor_body\").style.display = \"block\"; // document.getElementById(\"ggdoor_switch\").style.display = \"none\"; // _e_dlg.style.height = (_e_bg_img.offsetHeight + 100) + \"px\"; _e_body.style.height = (_e_bg_img.offsetHeight + 80) + \"px\"; _e_bg_patch.style.height = _e_bg_img.offsetHeight + \"px\";//设置拼图的高度，宽度为auto，达到和背景图同比例缩放的目的 } function _hiddenDoor() { document.getElementById(\"ggdoor_body\").style.display = \"none\"; // document.getElementById(\"ggdoor_switch\").style.display = \"block\"; } function _doGet(url, queryMap) { if (queryMap) { var query = false; for (var key in queryMap) { if (query) { query += \"&\" + key + \"=\" + encodeURIComponent(queryMap[key]); } else { query = \"?\" + key + \"=\" + encodeURIComponent(queryMap[key]); } } if (query) { url += query; } } url = \"//captcha.yidaren.top\" + url; console.log(url); var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; document.head.appendChild(script); } function _afterGetImg(res) { console.log(\"获取验证码图片\", res); if (res.error) { alert(\"获取验证码失败: \" + res.msg); return; } // 创建元素 var e = document.getElementById(_doorConfig.elementId); e.style.width = _doorConfig.width; e.innerHTML = '\\n' + ' 点击完成验证\\n' + ' \\n' + ' \\n' + ' \\n' + ' \\n' + ' \\n' + ' \\n' + ' \\n' + ' ' + ' 30) { var selectItem = []; var n = 30; while (n-- > 0) { var i = Math.floor(Math.random() * track.length); selectItem.push(track[i]); track.splice(i, 1); } console.log(track.length + \" -> \" + selectItem.length); track = selectItem; } var p = _e_bg_patch.style.left; if (!p) { p = 0; } else if (p.indexOf(\"px\") > 0) { p = p.substring(0, p.length - 2); p = parseInt(p); } var data = { \"d\": track, \"p\": p }; var queryMap = { \"data\": JSON.stringify(data), \"callback\": \"_afterCheck\" }; _doGet(\"/ca/check\", queryMap); }; var move = function (e) { if (!isClickDown) { return; } var x = e.touches ? e.touches[0].pageX : e.clientX; var y = e.touches ? e.touches[0].pageY : e.clientY; // console.log(x, y); track.push({ \"x\": x, \"y\": y, \"t\": new Date().getTime() - startTs }); var lineDiv_left = getPosition(tips).left; //长线条的横坐标 var minDiv_left = x - lineDiv_left; //小方块相对于父元素（长线条）的left值 if (minDiv_left >= tips.offsetWidth - _e_slider.offsetWidth) { minDiv_left = tips.offsetWidth - _e_slider.offsetWidth; } if (minDiv_left < 0) { minDiv_left = 0; } //设置拖动后小方块的left值 _e_slider.style.left = minDiv_left + \"px\"; if (minDiv_left >= tips.offsetWidth - _e_bg_patch.offsetWidth) { minDiv_left = tips.offsetWidth - _e_bg_patch.offsetWidth; } _e_bg_patch.style.left = minDiv_left + \"px\"; }; //鼠标按下方块 _e_slider.addEventListener(\"touchstart\", start); _e_slider.addEventListener(\"mousedown\", start); //鼠标松开 window.addEventListener(\"touchend\", end); window.addEventListener(\"mouseup\", end); //拖动 window.addEventListener(\"touchmove\", move); window.addEventListener(\"mousemove\", move); //获取元素的绝对位置 function getPosition(node) { var left = node.offsetLeft; //获取元素相对于其父元素的left值var left var top = node.offsetTop; current = node.offsetParent; // 取得元素的offsetParent // 一直循环直到根元素 while (current != null) { left += current.offsetLeft; top += current.offsetTop; current = current.offsetParent; } return { \"left\": left, \"top\": top }; } } function _afterCheck(res) { isClickDown = false; _e_slider.style.left = \"0\"; _e_bg_patch.style.left = \"0\"; console.log(\"验证结果\", res); if (res.error) { _doorConfig.onError(res.msg); } else if (res.data.result) { _doorConfig.onSuccess(res.data.validate); } else { _doorConfig.onFail(); } }"},{"title":"","date":"2019-08-04T10:19:28.796Z","updated":"2019-08-04T10:19:28.796Z","comments":true,"path":"p/ca/index.html","permalink":"https://acupt.cn/p/ca/index.html","excerpt":"","text":"芝麻关门 用户名 密码 验证码 window.onload = function () { configDoor({ elementId: \"check-code\", mode: \"1\", width: \"100%\", onSuccess: function (v) { alert(\"验证成功\"); console.log(\"验证成功: \" + v); }, onFail: function () { alert(\"验证失败\"); console.log(\"验证失败\"); }, onError: function (err) { alert(\"系统异常: \" + err); console.log(\"系统异常: \" + err); } }); }"},{"title":"","date":"2019-09-09T14:04:03.422Z","updated":"2019-09-09T14:04:03.422Z","comments":true,"path":"p/wxsent/index.html","permalink":"https://acupt.cn/p/wxsent/index.html","excerpt":"","text":"我已经发朋友圈了 背景： 头像： 照片： 文字： 昵称： 账号： 替换文字 靓仔 acupt 2018年 今天 寂寞如雪 come on $('.btn_change_txt').click(function (e) { document.getElementById(\"txt_publish\").innerHTML = $('.input_txt_publish').val(); document.getElementById(\"txt_name\").innerHTML = $('.input_txt_name').val(); document.getElementById(\"txt_account\").innerHTML = $('.input_txt_account').val(); }) $('.input_back').change(function (e) { var _URL = window.URL || window.webkitURL; var file, img; if ((file = this.files[0])) { img = new Image(); img.onload = function () { $('.img_back').attr('src', this.src); console.log(this.width) }; img.src = _URL.createObjectURL(file); } }) $('.input_head').change(function (e) { var _URL = window.URL || window.webkitURL; var file, img; if ((file = this.files[0])) { img = new Image(); img.onload = function () { $('.img_head').attr('src', this.src); console.log(this.width) }; img.src = _URL.createObjectURL(file); } }) $('.input_publish').change(function (e) { var _URL = window.URL || window.webkitURL; var file, img; if ((file = this.files[0])) { img = new Image(); img.onload = function () { $('.img_publish').attr('src', this.src); console.log(this.width) }; img.src = _URL.createObjectURL(file); } })"},{"title":"","date":"2019-08-03T15:29:37.529Z","updated":"2019-08-03T15:29:37.529Z","comments":true,"path":"static/js/jquery.1.7.1.min.js","permalink":"https://acupt.cn/static/js/jquery.1.7.1.min.js","excerpt":"","text":"/*! jQuery v1.7.1 jquery.com | jquery.org/license */ (function (a, b) { function cy(a) { return f.isWindow(a) ? a : a.nodeType === 9 ? a.defaultView || a.parentWindow : !1 } function cv(a) { if (!ck[a]) { var b = c.body, d = f(\"\").appendTo(b), e = d.css(\"display\"); d.remove(); if (e === \"none\" || e === \"\") { cl || (cl = c.createElement(\"iframe\"), cl.frameBorder = cl.width = cl.height = 0), b.appendChild(cl); if (!cm || !cl.createElement)cm = (cl.contentWindow || cl.contentDocument).document, cm.write((c.compatMode === \"CSS1Compat\" ? \"\" : \"\") + \"\"), cm.close(); d = cm.createElement(a), cm.body.appendChild(d), e = f.css(d, \"display\"), b.removeChild(cl) } ck[a] = e } return ck[a] } function cu(a, b) { var c = {}; f.each(cq.concat.apply([], cq.slice(0, b)), function () { c[this] = a }); return c } function ct() { cr = b } function cs() { setTimeout(ct, 0); return cr = f.now() } function cj() { try { return new a.ActiveXObject(\"Microsoft.XMLHTTP\") } catch (b) { } } function ci() { try { return new a.XMLHttpRequest } catch (b) { } } function cc(a, c) { a.dataFilter && (c = a.dataFilter(c, a.dataType)); var d = a.dataTypes, e = {}, g, h, i = d.length, j, k = d[0], l, m, n, o, p; for (g = 1; g < i; g++) { if (g === 1)for (h in a.converters)typeof h == \"string\" && (e[h.toLowerCase()] = a.converters[h]); l = k, k = d[g]; if (k === \"*\")k = l; else if (l !== \"*\" && l !== k) { m = l + \" \" + k, n = e[m] || e[\"* \" + k]; if (!n) { p = b; for (o in e) { j = o.split(\" \"); if (j[0] === l || j[0] === \"*\") { p = e[j[1] + \" \" + k]; if (p) { o = e[o], o === !0 ? n = p : p === !0 && (n = o); break } } } } !n && !p && f.error(\"No conversion from \" + m.replace(\" \", \" to \")), n !== !0 && (c = n ? n(c) : p(o(c))) } } return c } function cb(a, c, d) { var e = a.contents, f = a.dataTypes, g = a.responseFields, h, i, j, k; for (i in g)i in d && (c[g[i]] = d[i]); while (f[0] === \"*\")f.shift(), h === b && (h = a.mimeType || c.getResponseHeader(\"content-type\")); if (h)for (i in e)if (e[i] && e[i].test(h)) { f.unshift(i); break } if (f[0] in d)j = f[0]; else { for (i in d) { if (!f[0] || a.converters[i + \" \" + f[0]]) { j = i; break } k || (k = i) } j = j || k } if (j) { j !== f[0] && f.unshift(j); return d[j] } } function ca(a, b, c, d) { if (f.isArray(b))f.each(b, function (b, e) { c || bE.test(a) ? d(a, e) : ca(a + \"[\" + (typeof e == \"object\" || f.isArray(e) ? b : \"\") + \"]\", e, c, d) }); else if (!c && b != null && typeof b == \"object\")for (var e in b)ca(a + \"[\" + e + \"]\", b[e], c, d); else d(a, b) } function b_(a, c) { var d, e, g = f.ajaxSettings.flatOptions || {}; for (d in c)c[d] !== b && ((g[d] ? a : e || (e = {}))[d] = c[d]); e && f.extend(!0, a, e) } function b$(a, c, d, e, f, g) { f = f || c.dataTypes[0], g = g || {}, g[f] = !0; var h = a[f], i = 0, j = h ? h.length : 0, k = a === bT, l; for (; i < j && (k || !l); i++)l = h[i](c, d, e), typeof l == \"string\" && (!k || g[l] ? l = b : (c.dataTypes.unshift(l), l = b$(a, c, d, e, l, g))); (k || !l) && !g[\"*\"] && (l = b$(a, c, d, e, \"*\", g)); return l } function bZ(a) { return function (b, c) { typeof b != \"string\" && (c = b, b = \"*\"); if (f.isFunction(c)) { var d = b.toLowerCase().split(bP), e = 0, g = d.length, h, i, j; for (; e < g; e++)h = d[e], j = /^\\+/.test(h), j && (h = h.substr(1) || \"*\"), i = a[h] = a[h] || [], i[j ? \"unshift\" : \"push\"](c) } } } function bC(a, b, c) { var d = b === \"width\" ? a.offsetWidth : a.offsetHeight, e = b === \"width\" ? bx : by, g = 0, h = e.length; if (d > 0) { if (c !== \"border\")for (; g < h; g++)c || (d -= parseFloat(f.css(a, \"padding\" + e[g])) || 0), c === \"margin\" ? d += parseFloat(f.css(a, c + e[g])) || 0 : d -= parseFloat(f.css(a, \"border\" + e[g] + \"Width\")) || 0; return d + \"px\" } d = bz(a, b, b); if (d < 0 || d == null)d = a.style[b] || 0; d = parseFloat(d) || 0; if (c)for (; g < h; g++)d += parseFloat(f.css(a, \"padding\" + e[g])) || 0, c !== \"padding\" && (d += parseFloat(f.css(a, \"border\" + e[g] + \"Width\")) || 0), c === \"margin\" && (d += parseFloat(f.css(a, c + e[g])) || 0); return d + \"px\" } function bp(a, b) { b.src ? f.ajax({ url: b.src, async: !1, dataType: \"script\" }) : f.globalEval((b.text || b.textContent || b.innerHTML || \"\").replace(bf, \"/*$0*/\")), b.parentNode && b.parentNode.removeChild(b) } function bo(a) { var b = c.createElement(\"div\"); bh.appendChild(b), b.innerHTML = a.outerHTML; return b.firstChild } function bn(a) { var b = (a.nodeName || \"\").toLowerCase(); b === \"input\" ? bm(a) : b !== \"script\" && typeof a.getElementsByTagName != \"undefined\" && f.grep(a.getElementsByTagName(\"input\"), bm) } function bm(a) { if (a.type === \"checkbox\" || a.type === \"radio\")a.defaultChecked = a.checked } function bl(a) { return typeof a.getElementsByTagName != \"undefined\" ? a.getElementsByTagName(\"*\") : typeof a.querySelectorAll != \"undefined\" ? a.querySelectorAll(\"*\") : [] } function bk(a, b) { var c; if (b.nodeType === 1) { b.clearAttributes && b.clearAttributes(), b.mergeAttributes && b.mergeAttributes(a), c = b.nodeName.toLowerCase(); if (c === \"object\")b.outerHTML = a.outerHTML; else if (c !== \"input\" || a.type !== \"checkbox\" && a.type !== \"radio\") { if (c === \"option\")b.selected = a.defaultSelected; else if (c === \"input\" || c === \"textarea\")b.defaultValue = a.defaultValue } else a.checked && (b.defaultChecked = b.checked = a.checked), b.value !== a.value && (b.value = a.value); b.removeAttribute(f.expando) } } function bj(a, b) { if (b.nodeType === 1 && !!f.hasData(a)) { var c, d, e, g = f._data(a), h = f._data(b, g), i = g.events; if (i) { delete h.handle, h.events = {}; for (c in i)for (d = 0, e = i[c].length; d < e; d++)f.event.add(b, c + (i[c][d].namespace ? \".\" : \"\") + i[c][d].namespace, i[c][d], i[c][d].data) } h.data && (h.data = f.extend({}, h.data)) } } function bi(a, b) { return f.nodeName(a, \"table\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a } function U(a) { var b = V.split(\"|\"), c = a.createDocumentFragment(); if (c.createElement)while (b.length)c.createElement(b.pop()); return c } function T(a, b, c) { b = b || 0; if (f.isFunction(b))return f.grep(a, function (a, d) { var e = !!b.call(a, d, a); return e === c }); if (b.nodeType)return f.grep(a, function (a, d) { return a === b === c }); if (typeof b == \"string\") { var d = f.grep(a, function (a) { return a.nodeType === 1 }); if (O.test(b))return f.filter(b, d, !c); b = f.filter(b, d) } return f.grep(a, function (a, d) { return f.inArray(a, b) >= 0 === c }) } function S(a) { return !a || !a.parentNode || a.parentNode.nodeType === 11 } function K() { return !0 } function J() { return !1 } function n(a, b, c) { var d = b + \"defer\", e = b + \"queue\", g = b + \"mark\", h = f._data(a, d); h && (c === \"queue\" || !f._data(a, e)) && (c === \"mark\" || !f._data(a, g)) && setTimeout(function () { !f._data(a, e) && !f._data(a, g) && (f.removeData(a, d, !0), h.fire()) }, 0) } function m(a) { for (var b in a) { if (b === \"data\" && f.isEmptyObject(a[b]))continue; if (b !== \"toJSON\")return !1 } return !0 } function l(a, c, d) { if (d === b && a.nodeType === 1) { var e = \"data-\" + c.replace(k, \"-$1\").toLowerCase(); d = a.getAttribute(e); if (typeof d == \"string\") { try { d = d === \"true\" ? !0 : d === \"false\" ? !1 : d === \"null\" ? null : f.isNumeric(d) ? parseFloat(d) : j.test(d) ? f.parseJSON(d) : d } catch (g) { } f.data(a, c, d) } else d = b } return d } function h(a) { var b = g[a] = {}, c, d; a = a.split(/\\s+/); for (c = 0, d = a.length; c < d; c++)b[a[c]] = !0; return b } var c = a.document, d = a.navigator, e = a.location, f = function () { function J() { if (!e.isReady) { try { c.documentElement.doScroll(\"left\") } catch (a) { setTimeout(J, 1); return } e.ready() } } var e = function (a, b) { return new e.fn.init(a, b, h) }, f = a.jQuery, g = a.$, h, i = /^(?:[^#]*$|#([\\w\\-]*)$)/, j = /\\S/, k = /^\\s+/, l = /\\s+$/, m = /^(?:)?$/, n = /^[\\],:{}\\s]*$/, o = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, p = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, q = /(?:^|:|,)(?:\\s*\\[)+/g, r = /(webkit)[ \\/]([\\w.]+)/, s = /(opera)(?:.*version)?[ \\/]([\\w.]+)/, t = /(msie) ([\\w.]+)/, u = /(mozilla)(?:.*? rv:([\\w.]+))?/, v = /-([a-z]|[0-9])/ig, w = /^-ms-/, x = function (a, b) { return (b + \"\").toUpperCase() }, y = d.userAgent, z, A, B, C = Object.prototype.toString, D = Object.prototype.hasOwnProperty, E = Array.prototype.push, F = Array.prototype.slice, G = String.prototype.trim, H = Array.prototype.indexOf, I = {}; e.fn = e.prototype = { constructor: e, init: function (a, d, f) { var g, h, j, k; if (!a)return this; if (a.nodeType) { this.context = this[0] = a, this.length = 1; return this } if (a === \"body\" && !d && c.body) { this.context = c, this[0] = c.body, this.selector = a, this.length = 1; return this } if (typeof a == \"string\") { a.charAt(0) !== \"\" || a.length < 3 ? g = i.exec(a) : g = [null, a, null]; if (g && (g[1] || !d)) { if (g[1]) { d = d instanceof e ? d[0] : d, k = d ? d.ownerDocument || d : c, j = m.exec(a), j ? e.isPlainObject(d) ? (a = [c.createElement(j[1])], e.fn.attr.call(a, d, !0)) : a = [k.createElement(j[1])] : (j = e.buildFragment([g[1]], [k]), a = (j.cacheable ? e.clone(j.fragment) : j.fragment).childNodes); return e.merge(this, a) } h = c.getElementById(g[2]); if (h && h.parentNode) { if (h.id !== g[2])return f.find(a); this.length = 1, this[0] = h } this.context = c, this.selector = a; return this } return !d || d.jquery ? (d || f).find(a) : this.constructor(d).find(a) } if (e.isFunction(a))return f.ready(a); a.selector !== b && (this.selector = a.selector, this.context = a.context); return e.makeArray(a, this) }, selector: \"\", jquery: \"1.7.1\", length: 0, size: function () { return this.length }, toArray: function () { return F.call(this, 0) }, get: function (a) { return a == null ? this.toArray() : a < 0 ? this[this.length + a] : this[a] }, pushStack: function (a, b, c) { var d = this.constructor(); e.isArray(a) ? E.apply(d, a) : e.merge(d, a), d.prevObject = this, d.context = this.context, b === \"find\" ? d.selector = this.selector + (this.selector ? \" \" : \"\") + c : b && (d.selector = this.selector + \".\" + b + \"(\" + c + \")\"); return d }, each: function (a, b) { return e.each(this, a, b) }, ready: function (a) { e.bindReady(), A.add(a); return this }, eq: function (a) { a = +a; return a === -1 ? this.slice(a) : this.slice(a, a + 1) }, first: function () { return this.eq(0) }, last: function () { return this.eq(-1) }, slice: function () { return this.pushStack(F.apply(this, arguments), \"slice\", F.call(arguments).join(\",\")) }, map: function (a) { return this.pushStack(e.map(this, function (b, c) { return a.call(b, c, b) })) }, end: function () { return this.prevObject || this.constructor(null) }, push: E, sort: [].sort, splice: [].splice }, e.fn.init.prototype = e.fn, e.extend = e.fn.extend = function () { var a, c, d, f, g, h, i = arguments[0] || {}, j = 1, k = arguments.length, l = !1; typeof i == \"boolean\" && (l = i, i = arguments[1] || {}, j = 2), typeof i != \"object\" && !e.isFunction(i) && (i = {}), k === j && (i = this, --j); for (; j < k; j++)if ((a = arguments[j]) != null)for (c in a) { d = i[c], f = a[c]; if (i === f)continue; l && f && (e.isPlainObject(f) || (g = e.isArray(f))) ? (g ? (g = !1, h = d && e.isArray(d) ? d : []) : h = d && e.isPlainObject(d) ? d : {}, i[c] = e.extend(l, h, f)) : f !== b && (i[c] = f) } return i }, e.extend({ noConflict: function (b) { a.$ === e && (a.$ = g), b && a.jQuery === e && (a.jQuery = f); return e }, isReady: !1, readyWait: 1, holdReady: function (a) { a ? e.readyWait++ : e.ready(!0) }, ready: function (a) { if (a === !0 && !--e.readyWait || a !== !0 && !e.isReady) { if (!c.body)return setTimeout(e.ready, 1); e.isReady = !0; if (a !== !0 && --e.readyWait > 0)return; A.fireWith(c, [e]), e.fn.trigger && e(c).trigger(\"ready\").off(\"ready\") } }, bindReady: function () { if (!A) { A = e.Callbacks(\"once memory\"); if (c.readyState === \"complete\")return setTimeout(e.ready, 1); if (c.addEventListener)c.addEventListener(\"DOMContentLoaded\", B, !1), a.addEventListener(\"load\", e.ready, !1); else if (c.attachEvent) { c.attachEvent(\"onreadystatechange\", B), a.attachEvent(\"onload\", e.ready); var b = !1; try { b = a.frameElement == null } catch (d) { } c.documentElement.doScroll && b && J() } } }, isFunction: function (a) { return e.type(a) === \"function\" }, isArray: Array.isArray || function (a) { return e.type(a) === \"array\" }, isWindow: function (a) { return a && typeof a == \"object\" && \"setInterval\" in a }, isNumeric: function (a) { return !isNaN(parseFloat(a)) && isFinite(a) }, type: function (a) { return a == null ? String(a) : I[C.call(a)] || \"object\" }, isPlainObject: function (a) { if (!a || e.type(a) !== \"object\" || a.nodeType || e.isWindow(a))return !1; try { if (a.constructor && !D.call(a, \"constructor\") && !D.call(a.constructor.prototype, \"isPrototypeOf\"))return !1 } catch (c) { return !1 } var d; for (d in a); return d === b || D.call(a, d) }, isEmptyObject: function (a) { for (var b in a)return !1; return !0 }, error: function (a) { throw new Error(a) }, parseJSON: function (b) { if (typeof b != \"string\" || !b)return null; b = e.trim(b); if (a.JSON && a.JSON.parse)return a.JSON.parse(b); if (n.test(b.replace(o, \"@\").replace(p, \"]\").replace(q, \"\")))return (new Function(\"return \" + b))(); e.error(\"Invalid JSON: \" + b) }, parseXML: function (c) { var d, f; try { a.DOMParser ? (f = new DOMParser, d = f.parseFromString(c, \"text/xml\")) : (d = new ActiveXObject(\"Microsoft.XMLDOM\"), d.async = \"false\", d.loadXML(c)) } catch (g) { d = b } (!d || !d.documentElement || d.getElementsByTagName(\"parsererror\").length) && e.error(\"Invalid XML: \" + c); return d }, noop: function () { }, globalEval: function (b) { b && j.test(b) && (a.execScript || function (b) { a.eval.call(a, b) })(b) }, camelCase: function (a) { return a.replace(w, \"ms-\").replace(v, x) }, nodeName: function (a, b) { return a.nodeName && a.nodeName.toUpperCase() === b.toUpperCase() }, each: function (a, c, d) { var f, g = 0, h = a.length, i = h === b || e.isFunction(a); if (d) { if (i) { for (f in a)if (c.apply(a[f], d) === !1)break } else for (; g < h;)if (c.apply(a[g++], d) === !1)break } else if (i) { for (f in a)if (c.call(a[f], f, a[f]) === !1)break } else for (; g < h;)if (c.call(a[g], g, a[g++]) === !1)break; return a }, trim: G ? function (a) { return a == null ? \"\" : G.call(a) } : function (a) { return a == null ? \"\" : (a + \"\").replace(k, \"\").replace(l, \"\") }, makeArray: function (a, b) { var c = b || []; if (a != null) { var d = e.type(a); a.length == null || d === \"string\" || d === \"function\" || d === \"regexp\" || e.isWindow(a) ? E.call(c, a) : e.merge(c, a) } return c }, inArray: function (a, b, c) { var d; if (b) { if (H)return H.call(b, a, c); d = b.length, c = c ? c < 0 ? Math.max(0, d + c) : c : 0; for (; c < d; c++)if (c in b && b[c] === a)return c } return -1 }, merge: function (a, c) { var d = a.length, e = 0; if (typeof c.length == \"number\")for (var f = c.length; e < f; e++)a[d++] = c[e]; else while (c[e] !== b)a[d++] = c[e++]; a.length = d; return a }, grep: function (a, b, c) { var d = [], e; c = !!c; for (var f = 0, g = a.length; f < g; f++)e = !!b(a[f], f), c !== e && d.push(a[f]); return d }, map: function (a, c, d) { var f, g, h = [], i = 0, j = a.length, k = a instanceof e || j !== b && typeof j == \"number\" && (j > 0 && a[0] && a[j - 1] || j === 0 || e.isArray(a)); if (k)for (; i < j; i++)f = c(a[i], i, d), f != null && (h[h.length] = f); else for (g in a)f = c(a[g], g, d), f != null && (h[h.length] = f); return h.concat.apply([], h) }, guid: 1, proxy: function (a, c) { if (typeof c == \"string\") { var d = a[c]; c = a, a = d } if (!e.isFunction(a))return b; var f = F.call(arguments, 2), g = function () { return a.apply(c, f.concat(F.call(arguments))) }; g.guid = a.guid = a.guid || g.guid || e.guid++; return g }, access: function (a, c, d, f, g, h) { var i = a.length; if (typeof c == \"object\") { for (var j in c)e.access(a, j, c[j], f, g, d); return a } if (d !== b) { f = !h && f && e.isFunction(d); for (var k = 0; k < i; k++)g(a[k], c, f ? d.call(a[k], k, g(a[k], c)) : d, h); return a } return i ? g(a[0], c) : b }, now: function () { return (new Date).getTime() }, uaMatch: function (a) { a = a.toLowerCase(); var b = r.exec(a) || s.exec(a) || t.exec(a) || a.indexOf(\"compatible\") < 0 && u.exec(a) || []; return {browser: b[1] || \"\", version: b[2] || \"0\"} }, sub: function () { function a(b, c) { return new a.fn.init(b, c) } e.extend(!0, a, this), a.superclass = this, a.fn = a.prototype = this(), a.fn.constructor = a, a.sub = this.sub, a.fn.init = function (d, f) { f && f instanceof e && !(f instanceof a) && (f = a(f)); return e.fn.init.call(this, d, f, b) }, a.fn.init.prototype = a.fn; var b = a(c); return a }, browser: {} }), e.each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function (a, b) { I[\"[object \" + b + \"]\"] = b.toLowerCase() }), z = e.uaMatch(y), z.browser && (e.browser[z.browser] = !0, e.browser.version = z.version), e.browser.webkit && (e.browser.safari = !0), j.test(\" \") && (k = /^[\\s\\xA0]+/, l = /[\\s\\xA0]+$/), h = e(c), c.addEventListener ? B = function () { c.removeEventListener(\"DOMContentLoaded\", B, !1), e.ready() } : c.attachEvent && (B = function () { c.readyState === \"complete\" && (c.detachEvent(\"onreadystatechange\", B), e.ready()) }); return e }(), g = {}; f.Callbacks = function (a) { a = a ? g[a] || h(a) : {}; var c = [], d = [], e, i, j, k, l, m = function (b) { var d, e, g, h, i; for (d = 0, e = b.length; d < e; d++)g = b[d], h = f.type(g), h === \"array\" ? m(g) : h === \"function\" && (!a.unique || !o.has(g)) && c.push(g) }, n = function (b, f) { f = f || [], e = !a.memory || [b, f], i = !0, l = j || 0, j = 0, k = c.length; for (; c && l < k; l++)if (c[l].apply(b, f) === !1 && a.stopOnFalse) { e = !0; break } i = !1, c && (a.once ? e === !0 ? o.disable() : c = [] : d && d.length && (e = d.shift(), o.fireWith(e[0], e[1]))) }, o = { add: function () { if (c) { var a = c.length; m(arguments), i ? k = c.length : e && e !== !0 && (j = a, n(e[0], e[1])) } return this }, remove: function () { if (c) { var b = arguments, d = 0, e = b.length; for (; d < e; d++)for (var f = 0; f < c.length; f++)if (b[d] === c[f]) { i && f \" + \"\", a = c.createElement(\"div\"), a.style.cssText = m + \"width:0;height:0;position:static;top:0;margin-top:\" + j + \"px\", r.insertBefore(a, r.firstChild), q = c.createElement(\"div\"), a.appendChild(q), q.innerHTML = \"t\", l = q.getElementsByTagName(\"td\"), p = l[0].offsetHeight === 0, l[0].style.display = \"\", l[1].style.display = \"none\", b.reliableHiddenOffsets = p && l[0].offsetHeight === 0, q.innerHTML = \"\", q.style.width = q.style.paddingLeft = \"1px\", f.boxModel = b.boxModel = q.offsetWidth === 2, typeof q.style.zoom != \"undefined\" && (q.style.display = \"inline\", q.style.zoom = 1, b.inlineBlockNeedsLayout = q.offsetWidth === 2, q.style.display = \"\", q.innerHTML = \"\", b.shrinkWrapBlocks = q.offsetWidth !== 2), q.style.cssText = k + m, q.innerHTML = o, d = q.firstChild, e = d.firstChild, h = d.nextSibling.firstChild.firstChild, i = { doesNotAddBorder: e.offsetTop !== 5, doesAddBorderForTableAndCells: h.offsetTop === 5 }, e.style.position = \"fixed\", e.style.top = \"20px\", i.fixedPosition = e.offsetTop === 20 || e.offsetTop === 15, e.style.position = e.style.top = \"\", d.style.overflow = \"hidden\", d.style.position = \"relative\", i.subtractsBorderForOverflowNotVisible = e.offsetTop === -5, i.doesNotIncludeMarginInBodyOffset = r.offsetTop !== j, r.removeChild(a), q = a = null, f.extend(b, i)) }); return b }(); var j = /^(?:\\{.*\\}|\\[.*\\])$/, k = /([A-Z])/g; f.extend({ cache: {}, uuid: 0, expando: \"jQuery\" + (f.fn.jquery + Math.random()).replace(/\\D/g, \"\"), noData: {embed: !0, object: \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\", applet: !0}, hasData: function (a) { a = a.nodeType ? f.cache[a[f.expando]] : a[f.expando]; return !!a && !m(a) }, data: function (a, c, d, e) { if (!!f.acceptData(a)) { var g, h, i, j = f.expando, k = typeof c == \"string\", l = a.nodeType, m = l ? f.cache : a, n = l ? a[j] : a[j] && j, o = c === \"events\"; if ((!n || !m[n] || !o && !e && !m[n].data) && k && d === b)return; n || (l ? a[j] = n = ++f.uuid : n = j), m[n] || (m[n] = {}, l || (m[n].toJSON = f.noop)); if (typeof c == \"object\" || typeof c == \"function\")e ? m[n] = f.extend(m[n], c) : m[n].data = f.extend(m[n].data, c); g = h = m[n], e || (h.data || (h.data = {}), h = h.data), d !== b && (h[f.camelCase(c)] = d); if (o && !h[c])return g.events; k ? (i = h[c], i == null && (i = h[f.camelCase(c)])) : i = h; return i } }, removeData: function (a, b, c) { if (!!f.acceptData(a)) { var d, e, g, h = f.expando, i = a.nodeType, j = i ? f.cache : a, k = i ? a[h] : h; if (!j[k])return; if (b) { d = c ? j[k] : j[k].data; if (d) { f.isArray(b) || (b in d ? b = [b] : (b = f.camelCase(b), b in d ? b = [b] : b = b.split(\" \"))); for (e = 0, g = b.length; e < g; e++)delete d[b[e]]; if (!(c ? m : f.isEmptyObject)(d))return } } if (!c) { delete j[k].data; if (!m(j[k]))return } f.support.deleteExpando || !j.setInterval ? delete j[k] : j[k] = null, i && (f.support.deleteExpando ? delete a[h] : a.removeAttribute ? a.removeAttribute(h) : a[h] = null) } }, _data: function (a, b, c) { return f.data(a, b, c, !0) }, acceptData: function (a) { if (a.nodeName) { var b = f.noData[a.nodeName.toLowerCase()]; if (b)return b !== !0 && a.getAttribute(\"classid\") === b } return !0 } }), f.fn.extend({ data: function (a, c) { var d, e, g, h = null; if (typeof a == \"undefined\") { if (this.length) { h = f.data(this[0]); if (this[0].nodeType === 1 && !f._data(this[0], \"parsedAttrs\")) { e = this[0].attributes; for (var i = 0, j = e.length; i < j; i++)g = e[i].name, g.indexOf(\"data-\") === 0 && (g = f.camelCase(g.substring(5)), l(this[0], g, h[g])); f._data(this[0], \"parsedAttrs\", !0) } } return h } if (typeof a == \"object\")return this.each(function () { f.data(this, a) }); d = a.split(\".\"), d[1] = d[1] ? \".\" + d[1] : \"\"; if (c === b) { h = this.triggerHandler(\"getData\" + d[1] + \"!\", [d[0]]), h === b && this.length && (h = f.data(this[0], a), h = l(this[0], a, h)); return h === b && d[1] ? this.data(d[0]) : h } return this.each(function () { var b = f(this), e = [d[0], c]; b.triggerHandler(\"setData\" + d[1] + \"!\", e), f.data(this, a, c), b.triggerHandler(\"changeData\" + d[1] + \"!\", e) }) }, removeData: function (a) { return this.each(function () { f.removeData(this, a) }) } }), f.extend({ _mark: function (a, b) { a && (b = (b || \"fx\") + \"mark\", f._data(a, b, (f._data(a, b) || 0) + 1)) }, _unmark: function (a, b, c) { a !== !0 && (c = b, b = a, a = !1); if (b) { c = c || \"fx\"; var d = c + \"mark\", e = a ? 0 : (f._data(b, d) || 1) - 1; e ? f._data(b, d, e) : (f.removeData(b, d, !0), n(b, c, \"mark\")) } }, queue: function (a, b, c) { var d; if (a) { b = (b || \"fx\") + \"queue\", d = f._data(a, b), c && (!d || f.isArray(c) ? d = f._data(a, b, f.makeArray(c)) : d.push(c)); return d || [] } }, dequeue: function (a, b) { b = b || \"fx\"; var c = f.queue(a, b), d = c.shift(), e = {}; d === \"inprogress\" && (d = c.shift()), d && (b === \"fx\" && c.unshift(\"inprogress\"), f._data(a, b + \".run\", e), d.call(a, function () { f.dequeue(a, b) }, e)), c.length || (f.removeData(a, b + \"queue \" + b + \".run\", !0), n(a, b, \"queue\")) } }), f.fn.extend({ queue: function (a, c) { typeof a != \"string\" && (c = a, a = \"fx\"); if (c === b)return f.queue(this[0], a); return this.each(function () { var b = f.queue(this, a, c); a === \"fx\" && b[0] !== \"inprogress\" && f.dequeue(this, a) }) }, dequeue: function (a) { return this.each(function () { f.dequeue(this, a) }) }, delay: function (a, b) { a = f.fx ? f.fx.speeds[a] || a : a, b = b || \"fx\"; return this.queue(b, function (b, c) { var d = setTimeout(b, a); c.stop = function () { clearTimeout(d) } }) }, clearQueue: function (a) { return this.queue(a || \"fx\", []) }, promise: function (a, c) { function m() { --h || d.resolveWith(e, [e]) } typeof a != \"string\" && (c = a, a = b), a = a || \"fx\"; var d = f.Deferred(), e = this, g = e.length, h = 1, i = a + \"defer\", j = a + \"queue\", k = a + \"mark\", l; while (g--)if (l = f.data(e[g], i, b, !0) || (f.data(e[g], j, b, !0) || f.data(e[g], k, b, !0)) && f.data(e[g], i, f.Callbacks(\"once memory\"), !0))h++, l.add(m); m(); return d.promise() } }); var o = /[\\n\\t\\r]/g, p = /\\s+/, q = /\\r/g, r = /^(?:button|input)$/i, s = /^(?:button|input|object|select|textarea)$/i, t = /^a(?:rea)?$/i, u = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, v = f.support.getSetAttribute, w, x, y; f.fn.extend({ attr: function (a, b) { return f.access(this, a, b, !0, f.attr) }, removeAttr: function (a) { return this.each(function () { f.removeAttr(this, a) }) }, prop: function (a, b) { return f.access(this, a, b, !0, f.prop) }, removeProp: function (a) { a = f.propFix[a] || a; return this.each(function () { try { this[a] = b, delete this[a] } catch (c) { } }) }, addClass: function (a) { var b, c, d, e, g, h, i; if (f.isFunction(a))return this.each(function (b) { f(this).addClass(a.call(this, b, this.className)) }); if (a && typeof a == \"string\") { b = a.split(p); for (c = 0, d = this.length; c < d; c++) { e = this[c]; if (e.nodeType === 1)if (!e.className && b.length === 1)e.className = a; else { g = \" \" + e.className + \" \"; for (h = 0, i = b.length; h < i; h++)~g.indexOf(\" \" + b[h] + \" \") || (g += b[h] + \" \"); e.className = f.trim(g) } } } return this }, removeClass: function (a) { var c, d, e, g, h, i, j; if (f.isFunction(a))return this.each(function (b) { f(this).removeClass(a.call(this, b, this.className)) }); if (a && typeof a == \"string\" || a === b) { c = (a || \"\").split(p); for (d = 0, e = this.length; d < e; d++) { g = this[d]; if (g.nodeType === 1 && g.className)if (a) { h = (\" \" + g.className + \" \").replace(o, \" \"); for (i = 0, j = c.length; i < j; i++)h = h.replace(\" \" + c[i] + \" \", \" \"); g.className = f.trim(h) } else g.className = \"\" } } return this }, toggleClass: function (a, b) { var c = typeof a, d = typeof b == \"boolean\"; if (f.isFunction(a))return this.each(function (c) { f(this).toggleClass(a.call(this, c, this.className, b), b) }); return this.each(function () { if (c === \"string\") { var e, g = 0, h = f(this), i = b, j = a.split(p); while (e = j[g++])i = d ? i : !h.hasClass(e), h[i ? \"addClass\" : \"removeClass\"](e) } else if (c === \"undefined\" || c === \"boolean\")this.className && f._data(this, \"__className__\", this.className), this.className = this.className || a === !1 ? \"\" : f._data(this, \"__className__\") || \"\" }) }, hasClass: function (a) { var b = \" \" + a + \" \", c = 0, d = this.length; for (; c < d; c++)if (this[c].nodeType === 1 && (\" \" + this[c].className + \" \").replace(o, \" \").indexOf(b) > -1)return !0; return !1 }, val: function (a) { var c, d, e, g = this[0]; { if (!!arguments.length) { e = f.isFunction(a); return this.each(function (d) { var g = f(this), h; if (this.nodeType === 1) { e ? h = a.call(this, d, g.val()) : h = a, h == null ? h = \"\" : typeof h == \"number\" ? h += \"\" : f.isArray(h) && (h = f.map(h, function (a) { return a == null ? \"\" : a + \"\" })), c = f.valHooks[this.nodeName.toLowerCase()] || f.valHooks[this.type]; if (!c || !(\"set\" in c) || c.set(this, h, \"value\") === b)this.value = h } }) } if (g) { c = f.valHooks[g.nodeName.toLowerCase()] || f.valHooks[g.type]; if (c && \"get\" in c && (d = c.get(g, \"value\")) !== b)return d; d = g.value; return typeof d == \"string\" ? d.replace(q, \"\") : d == null ? \"\" : d } } } }), f.extend({ valHooks: { option: { get: function (a) { var b = a.attributes.value; return !b || b.specified ? a.value : a.text } }, select: { get: function (a) { var b, c, d, e, g = a.selectedIndex, h = [], i = a.options, j = a.type === \"select-one\"; if (g < 0)return null; c = j ? g : 0, d = j ? g + 1 : i.length; for (; c < d; c++) { e = i[c]; if (e.selected && (f.support.optDisabled ? !e.disabled : e.getAttribute(\"disabled\") === null) && (!e.parentNode.disabled || !f.nodeName(e.parentNode, \"optgroup\"))) { b = f(e).val(); if (j)return b; h.push(b) } } if (j && !h.length && i.length)return f(i[g]).val(); return h }, set: function (a, b) { var c = f.makeArray(b); f(a).find(\"option\").each(function () { this.selected = f.inArray(f(this).val(), c) >= 0 }), c.length || (a.selectedIndex = -1); return c } } }, attrFn: {val: !0, css: !0, html: !0, text: !0, data: !0, width: !0, height: !0, offset: !0}, attr: function (a, c, d, e) { var g, h, i, j = a.nodeType; if (!!a && j !== 3 && j !== 8 && j !== 2) { if (e && c in f.attrFn)return f(a)[c](d); if (typeof a.getAttribute == \"undefined\")return f.prop(a, c, d); i = j !== 1 || !f.isXMLDoc(a), i && (c = c.toLowerCase(), h = f.attrHooks[c] || (u.test(c) ? x : w)); if (d !== b) { if (d === null) { f.removeAttr(a, c); return } if (h && \"set\" in h && i && (g = h.set(a, d, c)) !== b)return g; a.setAttribute(c, \"\" + d); return d } if (h && \"get\" in h && i && (g = h.get(a, c)) !== null)return g; g = a.getAttribute(c); return g === null ? b : g } }, removeAttr: function (a, b) { var c, d, e, g, h = 0; if (b && a.nodeType === 1) { d = b.toLowerCase().split(p), g = d.length; for (; h < g; h++)e = d[h], e && (c = f.propFix[e] || e, f.attr(a, e, \"\"), a.removeAttribute(v ? e : c), u.test(e) && c in a && (a[c] = !1)) } }, attrHooks: { type: { set: function (a, b) { if (r.test(a.nodeName) && a.parentNode)f.error(\"type property can't be changed\"); else if (!f.support.radioValue && b === \"radio\" && f.nodeName(a, \"input\")) { var c = a.value; a.setAttribute(\"type\", b), c && (a.value = c); return b } } }, value: { get: function (a, b) { if (w && f.nodeName(a, \"button\"))return w.get(a, b); return b in a ? a.value : null }, set: function (a, b, c) { if (w && f.nodeName(a, \"button\"))return w.set(a, b, c); a.value = b } } }, propFix: { tabindex: \"tabIndex\", readonly: \"readOnly\", \"for\": \"htmlFor\", \"class\": \"className\", maxlength: \"maxLength\", cellspacing: \"cellSpacing\", cellpadding: \"cellPadding\", rowspan: \"rowSpan\", colspan: \"colSpan\", usemap: \"useMap\", frameborder: \"frameBorder\", contenteditable: \"contentEditable\" }, prop: function (a, c, d) { var e, g, h, i = a.nodeType; if (!!a && i !== 3 && i !== 8 && i !== 2) { h = i !== 1 || !f.isXMLDoc(a), h && (c = f.propFix[c] || c, g = f.propHooks[c]); return d !== b ? g && \"set\" in g && (e = g.set(a, d, c)) !== b ? e : a[c] = d : g && \"get\" in g && (e = g.get(a, c)) !== null ? e : a[c] } }, propHooks: { tabIndex: { get: function (a) { var c = a.getAttributeNode(\"tabindex\"); return c && c.specified ? parseInt(c.value, 10) : s.test(a.nodeName) || t.test(a.nodeName) && a.href ? 0 : b } } } }), f.attrHooks.tabindex = f.propHooks.tabIndex, x = { get: function (a, c) { var d, e = f.prop(a, c); return e === !0 || typeof e != \"boolean\" && (d = a.getAttributeNode(c)) && d.nodeValue !== !1 ? c.toLowerCase() : b }, set: function (a, b, c) { var d; b === !1 ? f.removeAttr(a, c) : (d = f.propFix[c] || c, d in a && (a[d] = !0), a.setAttribute(c, c.toLowerCase())); return c } }, v || (y = {name: !0, id: !0}, w = f.valHooks.button = { get: function (a, c) { var d; d = a.getAttributeNode(c); return d && (y[c] ? d.nodeValue !== \"\" : d.specified) ? d.nodeValue : b }, set: function (a, b, d) { var e = a.getAttributeNode(d); e || (e = c.createAttribute(d), a.setAttributeNode(e)); return e.nodeValue = b + \"\" } }, f.attrHooks.tabindex.set = w.set, f.each([\"width\", \"height\"], function (a, b) { f.attrHooks[b] = f.extend(f.attrHooks[b], { set: function (a, c) { if (c === \"\") { a.setAttribute(b, \"auto\"); return c } } }) }), f.attrHooks.contenteditable = { get: w.get, set: function (a, b, c) { b === \"\" && (b = \"false\"), w.set(a, b, c) } }), f.support.hrefNormalized || f.each([\"href\", \"src\", \"width\", \"height\"], function (a, c) { f.attrHooks[c] = f.extend(f.attrHooks[c], { get: function (a) { var d = a.getAttribute(c, 2); return d === null ? b : d } }) }), f.support.style || (f.attrHooks.style = { get: function (a) { return a.style.cssText.toLowerCase() || b }, set: function (a, b) { return a.style.cssText = \"\" + b } }), f.support.optSelected || (f.propHooks.selected = f.extend(f.propHooks.selected, { get: function (a) { var b = a.parentNode; b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex); return null } })), f.support.enctype || (f.propFix.enctype = \"encoding\"), f.support.checkOn || f.each([\"radio\", \"checkbox\"], function () { f.valHooks[this] = { get: function (a) { return a.getAttribute(\"value\") === null ? \"on\" : a.value } } }), f.each([\"radio\", \"checkbox\"], function () { f.valHooks[this] = f.extend(f.valHooks[this], { set: function (a, b) { if (f.isArray(b))return a.checked = f.inArray(f(a).val(), b) >= 0 } }) }); var z = /^(?:textarea|input|select)$/i, A = /^([^\\.]*)?(?:\\.(.+))?$/, B = /\\bhover(\\.\\S+)?\\b/, C = /^key/, D = /^(?:mouse|contextmenu)|click/, E = /^(?:focusinfocus|focusoutblur)$/, F = /^(\\w*)(?:#([\\w\\-]+))?(?:\\.([\\w\\-]+))?$/, G = function (a) { var b = F.exec(a); b && (b[1] = (b[1] || \"\").toLowerCase(), b[3] = b[3] && new RegExp(\"(?:^|\\\\s)\" + b[3] + \"(?:\\\\s|$)\")); return b }, H = function (a, b) { var c = a.attributes || {}; return (!b[1] || a.nodeName.toLowerCase() === b[1]) && (!b[2] || (c.id || {}).value === b[2]) && (!b[3] || b[3].test((c[\"class\"] || {}).value)) }, I = function (a) { return f.event.special.hover ? a : a.replace(B, \"mouseenter$1 mouseleave$1\") }; f.event = { add: function (a, c, d, e, g) { var h, i, j, k, l, m, n, o, p, q, r, s; if (!(a.nodeType === 3 || a.nodeType === 8 || !c || !d || !(h = f._data(a)))) { d.handler && (p = d, d = p.handler), d.guid || (d.guid = f.guid++), j = h.events, j || (h.events = j = {}), i = h.handle, i || (h.handle = i = function (a) { return typeof f != \"undefined\" && (!a || f.event.triggered !== a.type) ? f.event.dispatch.apply(i.elem, arguments) : b }, i.elem = a), c = f.trim(I(c)).split(\" \"); for (k = 0; k < c.length; k++) { l = A.exec(c[k]) || [], m = l[1], n = (l[2] || \"\").split(\".\").sort(), s = f.event.special[m] || {}, m = (g ? s.delegateType : s.bindType) || m, s = f.event.special[m] || {}, o = f.extend({ type: m, origType: l[1], data: e, handler: d, guid: d.guid, selector: g, quick: G(g), namespace: n.join(\".\") }, p), r = j[m]; if (!r) { r = j[m] = [], r.delegateCount = 0; if (!s.setup || s.setup.call(a, e, n, i) === !1)a.addEventListener ? a.addEventListener(m, i, !1) : a.attachEvent && a.attachEvent(\"on\" + m, i) } s.add && (s.add.call(a, o), o.handler.guid || (o.handler.guid = d.guid)), g ? r.splice(r.delegateCount++, 0, o) : r.push(o), f.event.global[m] = !0 } a = null } }, global: {}, remove: function (a, b, c, d, e) { var g = f.hasData(a) && f._data(a), h, i, j, k, l, m, n, o, p, q, r, s; if (!!g && !!(o = g.events)) { b = f.trim(I(b || \"\")).split(\" \"); for (h = 0; h < b.length; h++) { i = A.exec(b[h]) || [], j = k = i[1], l = i[2]; if (!j) { for (j in o)f.event.remove(a, j + b[h], c, d, !0); continue } p = f.event.special[j] || {}, j = (d ? p.delegateType : p.bindType) || j, r = o[j] || [], m = r.length, l = l ? new RegExp(\"(^|\\\\.)\" + l.split(\".\").sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null; for (n = 0; n < r.length; n++)s = r[n], (e || k === s.origType) && (!c || c.guid === s.guid) && (!l || l.test(s.namespace)) && (!d || d === s.selector || d === \"**\" && s.selector) && (r.splice(n--, 1), s.selector && r.delegateCount--, p.remove && p.remove.call(a, s)); r.length === 0 && m !== r.length && ((!p.teardown || p.teardown.call(a, l) === !1) && f.removeEvent(a, j, g.handle), delete o[j]) } f.isEmptyObject(o) && (q = g.handle, q && (q.elem = null), f.removeData(a, [\"events\", \"handle\"], !0)) } }, customEvent: {getData: !0, setData: !0, changeData: !0}, trigger: function (c, d, e, g) { if (!e || e.nodeType !== 3 && e.nodeType !== 8) { var h = c.type || c, i = [], j, k, l, m, n, o, p, q, r, s; if (E.test(h + f.event.triggered))return; h.indexOf(\"!\") >= 0 && (h = h.slice(0, -1), k = !0), h.indexOf(\".\") >= 0 && (i = h.split(\".\"), h = i.shift(), i.sort()); if ((!e || f.event.customEvent[h]) && !f.event.global[h])return; c = typeof c == \"object\" ? c[f.expando] ? c : new f.Event(h, c) : new f.Event(h), c.type = h, c.isTrigger = !0, c.exclusive = k, c.namespace = i.join(\".\"), c.namespace_re = c.namespace ? new RegExp(\"(^|\\\\.)\" + i.join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") : null, o = h.indexOf(\":\") < 0 ? \"on\" + h : \"\"; if (!e) { j = f.cache; for (l in j)j[l].events && j[l].events[h] && f.event.trigger(c, d, j[l].handle.elem, !0); return } c.result = b, c.target || (c.target = e), d = d != null ? f.makeArray(d) : [], d.unshift(c), p = f.event.special[h] || {}; if (p.trigger && p.trigger.apply(e, d) === !1)return; r = [[e, p.bindType || h]]; if (!g && !p.noBubble && !f.isWindow(e)) { s = p.delegateType || h, m = E.test(s + h) ? e : e.parentNode, n = null; for (; m; m = m.parentNode)r.push([m, s]), n = m; n && n === e.ownerDocument && r.push([n.defaultView || n.parentWindow || a, s]) } for (l = 0; l < r.length && !c.isPropagationStopped(); l++)m = r[l][0], c.type = r[l][1], q = (f._data(m, \"events\") || {})[c.type] && f._data(m, \"handle\"), q && q.apply(m, d), q = o && m[o], q && f.acceptData(m) && q.apply(m, d) === !1 && c.preventDefault(); c.type = h, !g && !c.isDefaultPrevented() && (!p._default || p._default.apply(e.ownerDocument, d) === !1) && (h !== \"click\" || !f.nodeName(e, \"a\")) && f.acceptData(e) && o && e[h] && (h !== \"focus\" && h !== \"blur\" || c.target.offsetWidth !== 0) && !f.isWindow(e) && (n = e[o], n && (e[o] = null), f.event.triggered = h, e[h](), f.event.triggered = b, n && (e[o] = n)); return c.result } }, dispatch: function (c) { c = f.event.fix(c || a.event); var d = (f._data(this, \"events\") || {})[c.type] || [], e = d.delegateCount, g = [].slice.call(arguments, 0), h = !c.exclusive && !c.namespace, i = [], j, k, l, m, n, o, p, q, r, s, t; g[0] = c, c.delegateTarget = this; if (e && !c.target.disabled && (!c.button || c.type !== \"click\")) { m = f(this), m.context = this.ownerDocument || this; for (l = c.target; l != this; l = l.parentNode || this) { o = {}, q = [], m[0] = l; for (j = 0; j < e; j++)r = d[j], s = r.selector, o[s] === b && (o[s] = r.quick ? H(l, r.quick) : m.is(s)), o[s] && q.push(r); q.length && i.push({elem: l, matches: q}) } } d.length > e && i.push({elem: this, matches: d.slice(e)}); for (j = 0; j < i.length && !c.isPropagationStopped(); j++) { p = i[j], c.currentTarget = p.elem; for (k = 0; k < p.matches.length && !c.isImmediatePropagationStopped(); k++) { r = p.matches[k]; if (h || !c.namespace && !r.namespace || c.namespace_re && c.namespace_re.test(r.namespace))c.data = r.data, c.handleObj = r, n = ((f.event.special[r.origType] || {}).handle || r.handler).apply(p.elem, g), n !== b && (c.result = n, n === !1 && (c.preventDefault(), c.stopPropagation())) } } return c.result }, props: \"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function (a, b) { a.which == null && (a.which = b.charCode != null ? b.charCode : b.keyCode); return a } }, mouseHooks: { props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function (a, d) { var e, f, g, h = d.button, i = d.fromElement; a.pageX == null && d.clientX != null && (e = a.target.ownerDocument || c, f = e.documentElement, g = e.body, a.pageX = d.clientX + (f && f.scrollLeft || g && g.scrollLeft || 0) - (f && f.clientLeft || g && g.clientLeft || 0), a.pageY = d.clientY + (f && f.scrollTop || g && g.scrollTop || 0) - (f && f.clientTop || g && g.clientTop || 0)), !a.relatedTarget && i && (a.relatedTarget = i === a.target ? d.toElement : i), !a.which && h !== b && (a.which = h & 1 ? 1 : h & 2 ? 3 : h & 4 ? 2 : 0); return a } }, fix: function (a) { if (a[f.expando])return a; var d, e, g = a, h = f.event.fixHooks[a.type] || {}, i = h.props ? this.props.concat(h.props) : this.props; a = f.Event(g); for (d = i.length; d;)e = i[--d], a[e] = g[e]; a.target || (a.target = g.srcElement || c), a.target.nodeType === 3 && (a.target = a.target.parentNode), a.metaKey === b && (a.metaKey = a.ctrlKey); return h.filter ? h.filter(a, g) : a }, special: { ready: {setup: f.bindReady}, load: {noBubble: !0}, focus: {delegateType: \"focusin\"}, blur: {delegateType: \"focusout\"}, beforeunload: { setup: function (a, b, c) { f.isWindow(this) && (this.onbeforeunload = c) }, teardown: function (a, b) { this.onbeforeunload === b && (this.onbeforeunload = null) } } }, simulate: function (a, b, c, d) { var e = f.extend(new f.Event, c, {type: a, isSimulated: !0, originalEvent: {}}); d ? f.event.trigger(e, null, b) : f.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault() } }, f.event.handle = f.event.dispatch, f.removeEvent = c.removeEventListener ? function (a, b, c) { a.removeEventListener && a.removeEventListener(b, c, !1) } : function (a, b, c) { a.detachEvent && a.detachEvent(\"on\" + b, c) }, f.Event = function (a, b) { if (!(this instanceof f.Event))return new f.Event(a, b); a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || a.returnValue === !1 || a.getPreventDefault && a.getPreventDefault() ? K : J) : this.type = a, b && f.extend(this, b), this.timeStamp = a && a.timeStamp || f.now(), this[f.expando] = !0 }, f.Event.prototype = { preventDefault: function () { this.isDefaultPrevented = K; var a = this.originalEvent; !a || (a.preventDefault ? a.preventDefault() : a.returnValue = !1) }, stopPropagation: function () { this.isPropagationStopped = K; var a = this.originalEvent; !a || (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0) }, stopImmediatePropagation: function () { this.isImmediatePropagationStopped = K, this.stopPropagation() }, isDefaultPrevented: J, isPropagationStopped: J, isImmediatePropagationStopped: J }, f.each({mouseenter: \"mouseover\", mouseleave: \"mouseout\"}, function (a, b) { f.event.special[a] = { delegateType: b, bindType: b, handle: function (a) { var c = this, d = a.relatedTarget, e = a.handleObj, g = e.selector, h; if (!d || d !== c && !f.contains(c, d))a.type = e.origType, h = e.handler.apply(this, arguments), a.type = b; return h } } }), f.support.submitBubbles || (f.event.special.submit = { setup: function () { if (f.nodeName(this, \"form\"))return !1; f.event.add(this, \"click._submit keypress._submit\", function (a) { var c = a.target, d = f.nodeName(c, \"input\") || f.nodeName(c, \"button\") ? c.form : b; d && !d._submit_attached && (f.event.add(d, \"submit._submit\", function (a) { this.parentNode && !a.isTrigger && f.event.simulate(\"submit\", this.parentNode, a, !0) }), d._submit_attached = !0) }) }, teardown: function () { if (f.nodeName(this, \"form\"))return !1; f.event.remove(this, \"._submit\") } }), f.support.changeBubbles || (f.event.special.change = { setup: function () { if (z.test(this.nodeName)) { if (this.type === \"checkbox\" || this.type === \"radio\")f.event.add(this, \"propertychange._change\", function (a) { a.originalEvent.propertyName === \"checked\" && (this._just_changed = !0) }), f.event.add(this, \"click._change\", function (a) { this._just_changed && !a.isTrigger && (this._just_changed = !1, f.event.simulate(\"change\", this, a, !0)) }); return !1 } f.event.add(this, \"beforeactivate._change\", function (a) { var b = a.target; z.test(b.nodeName) && !b._change_attached && (f.event.add(b, \"change._change\", function (a) { this.parentNode && !a.isSimulated && !a.isTrigger && f.event.simulate(\"change\", this.parentNode, a, !0) }), b._change_attached = !0) }) }, handle: function (a) { var b = a.target; if (this !== b || a.isSimulated || a.isTrigger || b.type !== \"radio\" && b.type !== \"checkbox\")return a.handleObj.handler.apply(this, arguments) }, teardown: function () { f.event.remove(this, \"._change\"); return z.test(this.nodeName) } }), f.support.focusinBubbles || f.each({focus: \"focusin\", blur: \"focusout\"}, function (a, b) { var d = 0, e = function (a) { f.event.simulate(b, a.target, f.event.fix(a), !0) }; f.event.special[b] = { setup: function () { d++ === 0 && c.addEventListener(a, e, !0) }, teardown: function () { --d === 0 && c.removeEventListener(a, e, !0) } } }), f.fn.extend({ on: function (a, c, d, e, g) { var h, i; if (typeof a == \"object\") { typeof c != \"string\" && (d = c, c = b); for (i in a)this.on(i, c, d, a[i], g); return this } d == null && e == null ? (e = c, d = c = b) : e == null && (typeof c == \"string\" ? (e = d, d = b) : (e = d, d = c, c = b)); if (e === !1)e = J; else if (!e)return this; g === 1 && (h = e, e = function (a) { f().off(a); return h.apply(this, arguments) }, e.guid = h.guid || (h.guid = f.guid++)); return this.each(function () { f.event.add(this, a, e, d, c) }) }, one: function (a, b, c, d) { return this.on.call(this, a, b, c, d, 1) }, off: function (a, c, d) { if (a && a.preventDefault && a.handleObj) { var e = a.handleObj; f(a.delegateTarget).off(e.namespace ? e.type + \".\" + e.namespace : e.type, e.selector, e.handler); return this } if (typeof a == \"object\") { for (var g in a)this.off(g, c, a[g]); return this } if (c === !1 || typeof c == \"function\")d = c, c = b; d === !1 && (d = J); return this.each(function () { f.event.remove(this, a, d, c) }) }, bind: function (a, b, c) { return this.on(a, null, b, c) }, unbind: function (a, b) { return this.off(a, null, b) }, live: function (a, b, c) { f(this.context).on(a, this.selector, b, c); return this }, die: function (a, b) { f(this.context).off(a, this.selector || \"**\", b); return this }, delegate: function (a, b, c, d) { return this.on(b, a, c, d) }, undelegate: function (a, b, c) { return arguments.length == 1 ? this.off(a, \"**\") : this.off(b, a, c) }, trigger: function (a, b) { return this.each(function () { f.event.trigger(a, b, this) }) }, triggerHandler: function (a, b) { if (this[0])return f.event.trigger(a, b, this[0], !0) }, toggle: function (a) { var b = arguments, c = a.guid || f.guid++, d = 0, e = function (c) { var e = (f._data(this, \"lastToggle\" + a.guid) || 0) % d; f._data(this, \"lastToggle\" + a.guid, e + 1), c.preventDefault(); return b[e].apply(this, arguments) || !1 }; e.guid = c; while (d < b.length)b[d++].guid = c; return this.click(e) }, hover: function (a, b) { return this.mouseenter(a).mouseleave(b || a) } }), f.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) { f.fn[b] = function (a, c) { c == null && (c = a, a = null); return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b) }, f.attrFn && (f.attrFn[b] = !0), C.test(b) && (f.event.fixHooks[b] = f.event.keyHooks), D.test(b) && (f.event.fixHooks[b] = f.event.mouseHooks) }), function () { function x(a, b, c, e, f, g) { for (var h = 0, i = e.length; h < i; h++) { var j = e[h]; if (j) { var k = !1; j = j[a]; while (j) { if (j[d] === c) { k = e[j.sizset]; break } if (j.nodeType === 1) { g || (j[d] = c, j.sizset = h); if (typeof b != \"string\") { if (j === b) { k = !0; break } } else if (m.filter(b, [j]).length > 0) { k = j; break } } j = j[a] } e[h] = k } } } function w(a, b, c, e, f, g) { for (var h = 0, i = e.length; h < i; h++) { var j = e[h]; if (j) { var k = !1; j = j[a]; while (j) { if (j[d] === c) { k = e[j.sizset]; break } j.nodeType === 1 && !g && (j[d] = c, j.sizset = h); if (j.nodeName.toLowerCase() === b) { k = j; break } j = j[a] } e[h] = k } } } var a = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g, d = \"sizcache\" + (Math.random() + \"\").replace(\".\", \"\"), e = 0, g = Object.prototype.toString, h = !1, i = !0, j = /\\\\/g, k = /\\r\\n/g, l = /\\W/; [0, 0].sort(function () { i = !1; return 0 }); var m = function (b, d, e, f) { e = e || [], d = d || c; var h = d; if (d.nodeType !== 1 && d.nodeType !== 9)return []; if (!b || typeof b != \"string\")return e; var i, j, k, l, n, q, r, t, u = !0, v = m.isXML(d), w = [], x = b; do { a.exec(\"\"), i = a.exec(x); if (i) { x = i[3], w.push(i[1]); if (i[2]) { l = i[3]; break } } } while (i); if (w.length > 1 && p.exec(b))if (w.length === 2 && o.relative[w[0]])j = y(w[0] + w[1], d, f); else { j = o.relative[w[0]] ? [d] : m(w.shift(), d); while (w.length)b = w.shift(), o.relative[b] && (b += w.shift()), j = y(b, j, f) } else { !f && w.length > 1 && d.nodeType === 9 && !v && o.match.ID.test(w[0]) && !o.match.ID.test(w[w.length - 1]) && (n = m.find(w.shift(), d, v), d = n.expr ? m.filter(n.expr, n.set)[0] : n.set[0]); if (d) { n = f ? { expr: w.pop(), set: s(f) } : m.find(w.pop(), w.length === 1 && (w[0] === \"~\" || w[0] === \"+\") && d.parentNode ? d.parentNode : d, v), j = n.expr ? m.filter(n.expr, n.set) : n.set, w.length > 0 ? k = s(j) : u = !1; while (w.length)q = w.pop(), r = q, o.relative[q] ? r = w.pop() : q = \"\", r == null && (r = d), o.relative[q](k, r, v) } else k = w = [] } k || (k = j), k || m.error(q || b); if (g.call(k) === \"[object Array]\")if (!u)e.push.apply(e, k); else if (d && d.nodeType === 1)for (t = 0; k[t] != null; t++)k[t] && (k[t] === !0 || k[t].nodeType === 1 && m.contains(d, k[t])) && e.push(j[t]); else for (t = 0; k[t] != null; t++)k[t] && k[t].nodeType === 1 && e.push(j[t]); else s(k, e); l && (m(l, h, e, f), m.uniqueSort(e)); return e }; m.uniqueSort = function (a) { if (u) { h = i, a.sort(u); if (h)for (var b = 1; b < a.length; b++)a[b] === a[b - 1] && a.splice(b--, 1) } return a }, m.matches = function (a, b) { return m(a, null, null, b) }, m.matchesSelector = function (a, b) { return m(b, null, null, [a]).length > 0 }, m.find = function (a, b, c) { var d, e, f, g, h, i; if (!a)return []; for (e = 0, f = o.order.length; e < f; e++) { h = o.order[e]; if (g = o.leftMatch[h].exec(a)) { i = g[1], g.splice(1, 1); if (i.substr(i.length - 1) !== \"\\\\\") { g[1] = (g[1] || \"\").replace(j, \"\"), d = o.find[h](g, b, c); if (d != null) { a = a.replace(o.match[h], \"\"); break } } } } d || (d = typeof b.getElementsByTagName != \"undefined\" ? b.getElementsByTagName(\"*\") : []); return {set: d, expr: a} }, m.filter = function (a, c, d, e) { var f, g, h, i, j, k, l, n, p, q = a, r = [], s = c, t = c && c[0] && m.isXML(c[0]); while (a && c.length) { for (h in o.filter)if ((f = o.leftMatch[h].exec(a)) != null && f[2]) { k = o.filter[h], l = f[1], g = !1, f.splice(1, 1); if (l.substr(l.length - 1) === \"\\\\\")continue; s === r && (r = []); if (o.preFilter[h]) { f = o.preFilter[h](f, s, d, r, e, t); if (!f)g = i = !0; else if (f === !0)continue } if (f)for (n = 0; (j = s[n]) != null; n++)j && (i = k(j, f, n, s), p = e ^ i, d && i != null ? p ? g = !0 : s[n] = !1 : p && (r.push(j), g = !0)); if (i !== b) { d || (s = r), a = a.replace(o.match[h], \"\"); if (!g)return []; break } } if (a === q)if (g == null)m.error(a); else break; q = a } return s }, m.error = function (a) { throw new Error(\"Syntax error, unrecognized expression: \" + a) }; var n = m.getText = function (a) { var b, c, d = a.nodeType, e = \"\"; if (d) { if (d === 1 || d === 9) { if (typeof a.textContent == \"string\")return a.textContent; if (typeof a.innerText == \"string\")return a.innerText.replace(k, \"\"); for (a = a.firstChild; a; a = a.nextSibling)e += n(a) } else if (d === 3 || d === 4)return a.nodeValue } else for (b = 0; c = a[b]; b++)c.nodeType !== 8 && (e += n(c)); return e }, o = m.selectors = { order: [\"ID\", \"NAME\", \"TAG\"], match: { ID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/, CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/, NAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/, ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/, TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/, CHILD: /:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/, POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/, PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/ }, leftMatch: {}, attrMap: {\"class\": \"className\", \"for\": \"htmlFor\"}, attrHandle: { href: function (a) { return a.getAttribute(\"href\") }, type: function (a) { return a.getAttribute(\"type\") } }, relative: { \"+\": function (a, b) { var c = typeof b == \"string\", d = c && !l.test(b), e = c && !d; d && (b = b.toLowerCase()); for (var f = 0, g = a.length, h; f < g; f++)if (h = a[f]) { while ((h = h.previousSibling) && h.nodeType !== 1); a[f] = e || h && h.nodeName.toLowerCase() === b ? h || !1 : h === b } e && m.filter(b, a, !0) }, \">\": function (a, b) { var c, d = typeof b == \"string\", e = 0, f = a.length; if (d && !l.test(b)) { b = b.toLowerCase(); for (; e < f; e++) { c = a[e]; if (c) { var g = c.parentNode; a[e] = g.nodeName.toLowerCase() === b ? g : !1 } } } else { for (; e < f; e++)c = a[e], c && (a[e] = d ? c.parentNode : c.parentNode === b); d && m.filter(b, a, !0) } }, \"\": function (a, b, c) { var d, f = e++, g = x; typeof b == \"string\" && !l.test(b) && (b = b.toLowerCase(), d = b, g = w), g(\"parentNode\", b, f, a, d, c) }, \"~\": function (a, b, c) { var d, f = e++, g = x; typeof b == \"string\" && !l.test(b) && (b = b.toLowerCase(), d = b, g = w), g(\"previousSibling\", b, f, a, d, c) } }, find: { ID: function (a, b, c) { if (typeof b.getElementById != \"undefined\" && !c) { var d = b.getElementById(a[1]); return d && d.parentNode ? [d] : [] } }, NAME: function (a, b) { if (typeof b.getElementsByName != \"undefined\") { var c = [], d = b.getElementsByName(a[1]); for (var e = 0, f = d.length; e < f; e++)d[e].getAttribute(\"name\") === a[1] && c.push(d[e]); return c.length === 0 ? null : c } }, TAG: function (a, b) { if (typeof b.getElementsByTagName != \"undefined\")return b.getElementsByTagName(a[1]) } }, preFilter: { CLASS: function (a, b, c, d, e, f) { a = \" \" + a[1].replace(j, \"\") + \" \"; if (f)return a; for (var g = 0, h; (h = b[g]) != null; g++)h && (e ^ (h.className && (\" \" + h.className + \" \").replace(/[\\t\\n\\r]/g, \" \").indexOf(a) >= 0) ? c || d.push(h) : c && (b[g] = !1)); return !1 }, ID: function (a) { return a[1].replace(j, \"\") }, TAG: function (a, b) { return a[1].replace(j, \"\").toLowerCase() }, CHILD: function (a) { if (a[1] === \"nth\") { a[2] || m.error(a[0]), a[2] = a[2].replace(/^\\+|\\s*/g, \"\"); var b = /(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(a[2] === \"even\" && \"2n\" || a[2] === \"odd\" && \"2n+1\" || !/\\D/.test(a[2]) && \"0n+\" + a[2] || a[2]); a[2] = b[1] + (b[2] || 1) - 0, a[3] = b[3] - 0 } else a[2] && m.error(a[0]); a[0] = e++; return a }, ATTR: function (a, b, c, d, e, f) { var g = a[1] = a[1].replace(j, \"\"); !f && o.attrMap[g] && (a[1] = o.attrMap[g]), a[4] = (a[4] || a[5] || \"\").replace(j, \"\"), a[2] === \"~=\" && (a[4] = \" \" + a[4] + \" \"); return a }, PSEUDO: function (b, c, d, e, f) { if (b[1] === \"not\")if ((a.exec(b[3]) || \"\").length > 1 || /^\\w/.test(b[3]))b[3] = m(b[3], null, null, c); else { var g = m.filter(b[3], c, d, !0 ^ f); d || e.push.apply(e, g); return !1 } else if (o.match.POS.test(b[0]) || o.match.CHILD.test(b[0]))return !0; return b }, POS: function (a) { a.unshift(!0); return a } }, filters: { enabled: function (a) { return a.disabled === !1 && a.type !== \"hidden\" }, disabled: function (a) { return a.disabled === !0 }, checked: function (a) { return a.checked === !0 }, selected: function (a) { a.parentNode && a.parentNode.selectedIndex; return a.selected === !0 }, parent: function (a) { return !!a.firstChild }, empty: function (a) { return !a.firstChild }, has: function (a, b, c) { return !!m(c[3], a).length }, header: function (a) { return /h\\d/i.test(a.nodeName) }, text: function (a) { var b = a.getAttribute(\"type\"), c = a.type; return a.nodeName.toLowerCase() === \"input\" && \"text\" === c && (b === c || b === null) }, radio: function (a) { return a.nodeName.toLowerCase() === \"input\" && \"radio\" === a.type }, checkbox: function (a) { return a.nodeName.toLowerCase() === \"input\" && \"checkbox\" === a.type }, file: function (a) { return a.nodeName.toLowerCase() === \"input\" && \"file\" === a.type }, password: function (a) { return a.nodeName.toLowerCase() === \"input\" && \"password\" === a.type }, submit: function (a) { var b = a.nodeName.toLowerCase(); return (b === \"input\" || b === \"button\") && \"submit\" === a.type }, image: function (a) { return a.nodeName.toLowerCase() === \"input\" && \"image\" === a.type }, reset: function (a) { var b = a.nodeName.toLowerCase(); return (b === \"input\" || b === \"button\") && \"reset\" === a.type }, button: function (a) { var b = a.nodeName.toLowerCase(); return b === \"input\" && \"button\" === a.type || b === \"button\" }, input: function (a) { return /input|select|textarea|button/i.test(a.nodeName) }, focus: function (a) { return a === a.ownerDocument.activeElement } }, setFilters: { first: function (a, b) { return b === 0 }, last: function (a, b, c, d) { return b === d.length - 1 }, even: function (a, b) { return b % 2 === 0 }, odd: function (a, b) { return b % 2 === 1 }, lt: function (a, b, c) { return b < c[3] - 0 }, gt: function (a, b, c) { return b > c[3] - 0 }, nth: function (a, b, c) { return c[3] - 0 === b }, eq: function (a, b, c) { return c[3] - 0 === b } }, filter: { PSEUDO: function (a, b, c, d) { var e = b[1], f = o.filters[e]; if (f)return f(a, c, b, d); if (e === \"contains\")return (a.textContent || a.innerText || n([a]) || \"\").indexOf(b[3]) >= 0; if (e === \"not\") { var g = b[3]; for (var h = 0, i = g.length; h < i; h++)if (g[h] === a)return !1; return !0 } m.error(e) }, CHILD: function (a, b) { var c, e, f, g, h, i, j, k = b[1], l = a; switch (k) { case\"only\": case\"first\": while (l = l.previousSibling)if (l.nodeType === 1)return !1; if (k === \"first\")return !0; l = a; case\"last\": while (l = l.nextSibling)if (l.nodeType === 1)return !1; return !0; case\"nth\": c = b[2], e = b[3]; if (c === 1 && e === 0)return !0; f = b[0], g = a.parentNode; if (g && (g[d] !== f || !a.nodeIndex)) { i = 0; for (l = g.firstChild; l; l = l.nextSibling)l.nodeType === 1 && (l.nodeIndex = ++i); g[d] = f } j = a.nodeIndex - e; return c === 0 ? j === 0 : j % c === 0 && j / c >= 0 } }, ID: function (a, b) { return a.nodeType === 1 && a.getAttribute(\"id\") === b }, TAG: function (a, b) { return b === \"*\" && a.nodeType === 1 || !!a.nodeName && a.nodeName.toLowerCase() === b }, CLASS: function (a, b) { return (\" \" + (a.className || a.getAttribute(\"class\")) + \" \").indexOf(b) > -1 }, ATTR: function (a, b) { var c = b[1], d = m.attr ? m.attr(a, c) : o.attrHandle[c] ? o.attrHandle[c](a) : a[c] != null ? a[c] : a.getAttribute(c), e = d + \"\", f = b[2], g = b[4]; return d == null ? f === \"!=\" : !f && m.attr ? d != null : f === \"=\" ? e === g : f === \"*=\" ? e.indexOf(g) >= 0 : f === \"~=\" ? (\" \" + e + \" \").indexOf(g) >= 0 : g ? f === \"!=\" ? e !== g : f === \"^=\" ? e.indexOf(g) === 0 : f === \"$=\" ? e.substr(e.length - g.length) === g : f === \"|=\" ? e === g || e.substr(0, g.length + 1) === g + \"-\" : !1 : e && d !== !1 }, POS: function (a, b, c, d) { var e = b[2], f = o.setFilters[e]; if (f)return f(a, c, b, d) } } }, p = o.match.POS, q = function (a, b) { return \"\\\\\" + (b - 0 + 1) }; for (var r in o.match)o.match[r] = new RegExp(o.match[r].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source), o.leftMatch[r] = new RegExp(/(^(?:.|\\r|\\n)*?)/.source + o.match[r].source.replace(/\\\\(\\d+)/g, q)); var s = function (a, b) { a = Array.prototype.slice.call(a, 0); if (b) { b.push.apply(b, a); return b } return a }; try { Array.prototype.slice.call(c.documentElement.childNodes, 0)[0].nodeType } catch (t) { s = function (a, b) { var c = 0, d = b || []; if (g.call(a) === \"[object Array]\")Array.prototype.push.apply(d, a); else if (typeof a.length == \"number\")for (var e = a.length; c < e; c++)d.push(a[c]); else for (; a[c]; c++)d.push(a[c]); return d } } var u, v; c.documentElement.compareDocumentPosition ? u = function (a, b) { if (a === b) { h = !0; return 0 } if (!a.compareDocumentPosition || !b.compareDocumentPosition)return a.compareDocumentPosition ? -1 : 1; return a.compareDocumentPosition(b) & 4 ? -1 : 1 } : (u = function (a, b) { if (a === b) { h = !0; return 0 } if (a.sourceIndex && b.sourceIndex)return a.sourceIndex - b.sourceIndex; var c, d, e = [], f = [], g = a.parentNode, i = b.parentNode, j = g; if (g === i)return v(a, b); if (!g)return -1; if (!i)return 1; while (j)e.unshift(j), j = j.parentNode; j = i; while (j)f.unshift(j), j = j.parentNode; c = e.length, d = f.length; for (var k = 0; k < c && k < d; k++)if (e[k] !== f[k])return v(e[k], f[k]); return k === c ? v(a, f[k], -1) : v(e[k], b, 1) }, v = function (a, b, c) { if (a === b)return c; var d = a.nextSibling; while (d) { if (d === b)return -1; d = d.nextSibling } return 1 }), function () { var a = c.createElement(\"div\"), d = \"script\" + (new Date).getTime(), e = c.documentElement; a.innerHTML = \"\", e.insertBefore(a, e.firstChild), c.getElementById(d) && (o.find.ID = function (a, c, d) { if (typeof c.getElementById != \"undefined\" && !d) { var e = c.getElementById(a[1]); return e ? e.id === a[1] || typeof e.getAttributeNode != \"undefined\" && e.getAttributeNode(\"id\").nodeValue === a[1] ? [e] : b : [] } }, o.filter.ID = function (a, b) { var c = typeof a.getAttributeNode != \"undefined\" && a.getAttributeNode(\"id\"); return a.nodeType === 1 && c && c.nodeValue === b }), e.removeChild(a), e = a = null }(), function () { var a = c.createElement(\"div\"); a.appendChild(c.createComment(\"\")), a.getElementsByTagName(\"*\").length > 0 && (o.find.TAG = function (a, b) { var c = b.getElementsByTagName(a[1]); if (a[1] === \"*\") { var d = []; for (var e = 0; c[e]; e++)c[e].nodeType === 1 && d.push(c[e]); c = d } return c }), a.innerHTML = \"\", a.firstChild && typeof a.firstChild.getAttribute != \"undefined\" && a.firstChild.getAttribute(\"href\") !== \"#\" && (o.attrHandle.href = function (a) { return a.getAttribute(\"href\", 2) }), a = null }(), c.querySelectorAll && function () { var a = m, b = c.createElement(\"div\"), d = \"__sizzle__\"; b.innerHTML = \"\"; if (!b.querySelectorAll || b.querySelectorAll(\".TEST\").length !== 0) { m = function (b, e, f, g) { e = e || c; if (!g && !m.isXML(e)) { var h = /^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(b); if (h && (e.nodeType === 1 || e.nodeType === 9)) { if (h[1])return s(e.getElementsByTagName(b), f); if (h[2] && o.find.CLASS && e.getElementsByClassName)return s(e.getElementsByClassName(h[2]), f) } if (e.nodeType === 9) { if (b === \"body\" && e.body)return s([e.body], f); if (h && h[3]) { var i = e.getElementById(h[3]); if (!i || !i.parentNode)return s([], f); if (i.id === h[3])return s([i], f) } try { return s(e.querySelectorAll(b), f) } catch (j) { } } else if (e.nodeType === 1 && e.nodeName.toLowerCase() !== \"object\") { var k = e, l = e.getAttribute(\"id\"), n = l || d, p = e.parentNode, q = /^\\s*[+~]/.test(b); l ? n = n.replace(/'/g, \"\\\\$&\") : e.setAttribute(\"id\", n), q && p && (e = e.parentNode); try { if (!q || p)return s(e.querySelectorAll(\"[id='\" + n + \"'] \" + b), f) } catch (r) { } finally { l || k.removeAttribute(\"id\") } } } return a(b, e, f, g) }; for (var e in a)m[e] = a[e]; b = null } }(), function () { var a = c.documentElement, b = a.matchesSelector || a.mozMatchesSelector || a.webkitMatchesSelector || a.msMatchesSelector; if (b) { var d = !b.call(c.createElement(\"div\"), \"div\"), e = !1; try { b.call(c.documentElement, \"[test!='']:sizzle\") } catch (f) { e = !0 } m.matchesSelector = function (a, c) { c = c.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g, \"='$1']\"); if (!m.isXML(a))try { if (e || !o.match.PSEUDO.test(c) && !/!=/.test(c)) { var f = b.call(a, c); if (f || !d || a.document && a.document.nodeType !== 11)return f } } catch (g) { } return m(c, null, null, [a]).length > 0 } } }(), function () { var a = c.createElement(\"div\"); a.innerHTML = \"\"; if (!!a.getElementsByClassName && a.getElementsByClassName(\"e\").length !== 0) { a.lastChild.className = \"e\"; if (a.getElementsByClassName(\"e\").length === 1)return; o.order.splice(1, 0, \"CLASS\"), o.find.CLASS = function (a, b, c) { if (typeof b.getElementsByClassName != \"undefined\" && !c)return b.getElementsByClassName(a[1]) }, a = null } }(), c.documentElement.contains ? m.contains = function (a, b) { return a !== b && (a.contains ? a.contains(b) : !0) } : c.documentElement.compareDocumentPosition ? m.contains = function (a, b) { return !!(a.compareDocumentPosition(b) & 16) } : m.contains = function () { return !1 }, m.isXML = function (a) { var b = (a ? a.ownerDocument || a : 0).documentElement; return b ? b.nodeName !== \"HTML\" : !1 }; var y = function (a, b, c) { var d, e = [], f = \"\", g = b.nodeType ? [b] : b; while (d = o.match.PSEUDO.exec(a))f += d[0], a = a.replace(o.match.PSEUDO, \"\"); a = o.relative[a] ? a + \"*\" : a; for (var h = 0, i = g.length; h < i; h++)m(a, g[h], e, c); return m.filter(f, e) }; m.attr = f.attr, m.selectors.attrMap = {}, f.find = m, f.expr = m.selectors, f.expr[\":\"] = f.expr.filters, f.unique = m.uniqueSort, f.text = m.getText, f.isXMLDoc = m.isXML, f.contains = m.contains }(); var L = /Until$/, M = /^(?:parents|prevUntil|prevAll)/, N = /,/, O = /^.[^:#\\[\\.,]*$/, P = Array.prototype.slice, Q = f.expr.match.POS, R = { children: !0, contents: !0, next: !0, prev: !0 }; f.fn.extend({ find: function (a) { var b = this, c, d; if (typeof a != \"string\")return f(a).filter(function () { for (c = 0, d = b.length; c < d; c++)if (f.contains(b[c], this))return !0 }); var e = this.pushStack(\"\", \"find\", a), g, h, i; for (c = 0, d = this.length; c < d; c++) { g = e.length, f.find(a, this[c], e); if (c > 0)for (h = g; h < e.length; h++)for (i = 0; i < g; i++)if (e[i] === e[h]) { e.splice(h--, 1); break } } return e }, has: function (a) { var b = f(a); return this.filter(function () { for (var a = 0, c = b.length; a < c; a++)if (f.contains(this, b[a]))return !0 }) }, not: function (a) { return this.pushStack(T(this, a, !1), \"not\", a) }, filter: function (a) { return this.pushStack(T(this, a, !0), \"filter\", a) }, is: function (a) { return !!a && (typeof a == \"string\" ? Q.test(a) ? f(a, this.context).index(this[0]) >= 0 : f.filter(a, this).length > 0 : this.filter(a).length > 0) }, closest: function (a, b) { var c = [], d, e, g = this[0]; if (f.isArray(a)) { var h = 1; while (g && g.ownerDocument && g !== b) { for (d = 0; d < a.length; d++)f(g).is(a[d]) && c.push({selector: a[d], elem: g, level: h}); g = g.parentNode, h++ } return c } var i = Q.test(a) || typeof a != \"string\" ? f(a, b || this.context) : 0; for (d = 0, e = this.length; d < e; d++) { g = this[d]; while (g) { if (i ? i.index(g) > -1 : f.find.matchesSelector(g, a)) { c.push(g); break } g = g.parentNode; if (!g || !g.ownerDocument || g === b || g.nodeType === 11)break } } c = c.length > 1 ? f.unique(c) : c; return this.pushStack(c, \"closest\", a) }, index: function (a) { if (!a)return this[0] && this[0].parentNode ? this.prevAll().length : -1; if (typeof a == \"string\")return f.inArray(this[0], f(a)); return f.inArray(a.jquery ? a[0] : a, this) }, add: function (a, b) { var c = typeof a == \"string\" ? f(a, b) : f.makeArray(a && a.nodeType ? [a] : a), d = f.merge(this.get(), c); return this.pushStack(S(c[0]) || S(d[0]) ? d : f.unique(d)) }, andSelf: function () { return this.add(this.prevObject) } }), f.each({ parent: function (a) { var b = a.parentNode; return b && b.nodeType !== 11 ? b : null }, parents: function (a) { return f.dir(a, \"parentNode\") }, parentsUntil: function (a, b, c) { return f.dir(a, \"parentNode\", c) }, next: function (a) { return f.nth(a, 2, \"nextSibling\") }, prev: function (a) { return f.nth(a, 2, \"previousSibling\") }, nextAll: function (a) { return f.dir(a, \"nextSibling\") }, prevAll: function (a) { return f.dir(a, \"previousSibling\") }, nextUntil: function (a, b, c) { return f.dir(a, \"nextSibling\", c) }, prevUntil: function (a, b, c) { return f.dir(a, \"previousSibling\", c) }, siblings: function (a) { return f.sibling(a.parentNode.firstChild, a) }, children: function (a) { return f.sibling(a.firstChild) }, contents: function (a) { return f.nodeName(a, \"iframe\") ? a.contentDocument || a.contentWindow.document : f.makeArray(a.childNodes) } }, function (a, b) { f.fn[a] = function (c, d) { var e = f.map(this, b, c); L.test(a) || (d = c), d && typeof d == \"string\" && (e = f.filter(d, e)), e = this.length > 1 && !R[a] ? f.unique(e) : e, (this.length > 1 || N.test(d)) && M.test(a) && (e = e.reverse()); return this.pushStack(e, a, P.call(arguments).join(\",\")) } }), f.extend({ filter: function (a, b, c) { c && (a = \":not(\" + a + \")\"); return b.length === 1 ? f.find.matchesSelector(b[0], a) ? [b[0]] : [] : f.find.matches(a, b) }, dir: function (a, c, d) { var e = [], g = a[c]; while (g && g.nodeType !== 9 && (d === b || g.nodeType !== 1 || !f(g).is(d)))g.nodeType === 1 && e.push(g), g = g[c]; return e }, nth: function (a, b, c, d) { b = b || 1; var e = 0; for (; a; a = a[c])if (a.nodeType === 1 && ++e === b)break; return a }, sibling: function (a, b) { var c = []; for (; a; a = a.nextSibling)a.nodeType === 1 && a !== b && c.push(a); return c } }); var V = \"abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\", W = / jQuery\\d+=\"(?:\\d+|null)\"/g, X = /^\\s+/, Y = /]*)\\/>/ig, Z = /"}],"posts":[{"title":"从TCP的三次握手和四次挥手说起","slug":"tcp-3-4","date":"2019-09-08T17:00:00.000Z","updated":"2019-09-09T15:52:37.592Z","comments":true,"path":"2019/09/09/tcp-3-4/","link":"","permalink":"https://acupt.cn/2019/09/09/tcp-3-4/","excerpt":"","text":"只知道它有三次握手和四次挥手是不足以应付严格的面试官的… 传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。 我们熟悉的HTTP就是基于TCP来的。 TCP连接在面试中也是一个很高频的话题，一般面试官的起手式为：请讲讲TCP的三次握手/四次挥手… 本文大纲如下，看不完可以收藏慢慢看（看完怕忘也是） 三次握手和四次挥手的简单讲解 三次握手和四次挥手的进阶讲解 为什么是三次握手 为什么是四次挥手 TCP报文格式 慢开始与拥塞避免 快重传与快恢复 time_wait何时出现，大量出现时怎么处理 close_wait何时出现，大量出现时怎么处理 入门入门级回答，简单描述下客户端和服务端之间每次在做什么。 发起连接请求的是客户端，接收连接请求的是服务端。 对于图中的几个关键词，是TCP报文中的控制位中的标志（为1表示有对应标志） SYN 表示建立连接 FIN 表示关闭连接 ACK 表示响应 三次握手（建立连接，红色部分）： 客户端向服务端发送一个SYN包（建交吧） 服务端收到并发送一个ACK + SYN包（好的，建交吧） 客户端收到并发送一个ACK包（好的） 完成这三个步骤后客户端和服务端建立起深厚的友谊，开始你来我往，传递数据。当双发无话可说时，友谊的小船说翻就翻。 四次挥手（断开连接，绿色部分）： 客户端向服务端发送一个FIN包（我对你言尽于此） 服务端收到并发送一个ACK包（好，很好） 服务端再发送一个FIN包（我对你也没啥好说的了） 客户端向服务端发送一个ACK包（嗯，你也不错） 断开连接可以由任意一方先提出，一般是客户端提出的。 进阶上面的描述比较简单，我们可以更加深入探索客户端和服务端之间的种种行为。 SYN 表示建立连接 FIN 表示关闭连接 ACK 表示响应 seq sequence number，表示的是我方（发送方）这边，这个packet的数据部分的第一位应该在整个data stream中所在的位置 ack acknowledge number：表示的是期望的对方（接收方）的下一次sequence number是多少 三次握手（建立连接，红色部分）：服务端处于监听状态（LISTEN），随时准备接受连接。 客户端向服务端发送一个SYN包，同时用个随机数作为初始序列号seq = x，进入SYN_SENT状态 服务端收到并发送一个ACK + SYN包，也随机个数来作为初始序列号seq = y，进入SYN_RCVD状态 客户端收到并发送一个ACK包（好的），进入ESTABLISHED状态，表示连接建立 服务端收到ACK后也进入ESTABLISHED状态，表示连接建立 完成这四个步骤后（只是多了一个状态变化的描述，还是三次握手哈）客户端和服务端再次建立起深厚的友谊，开始你来我往，传递数据。 当然天下无不散之筵席，挥手再见的时刻即将到来。 四次挥手（断开连接，绿色部分）：还是客户端先提出分手。 客户端向服务端发送一个FIN包，进入FIN_WAIT1状态 服务端收到并发送一个ACK包，进入CLOSE_WAIT状态 服务端再发送一个FIN包，进入LAST_ACK状态 客户端向服务端发送一个ACK包，进入TIME_WAIT状态，并在等待2MSL(报文最大生存时间)变为CLOSED状态 服务端收到ACK后也变为CLOSED状态 扩展对于上面描述的过程，如果你之前不太了解，那么针对某些点肯定会有些许疑问。 下面总结一些可以延伸的问题。 为什么建立连接要三次握手为何是三，不是二，也不是四？借助经典的打电话的场景来帮助理解。 第一次握手：A对B说，小B，能听到吗？（SYN） 第二次握手：B对A说，听得到（ACK），你能听到吗？（SYN） 第三次握手：A对B说，俺也一样！（ACK） 在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。如此这般，就可以开始愉快地交流了。 如果两次，那么B无法确定B的信息A是否能收到，可能B发出的消息A都收不到。 如果四次，可以，但没必要。 为什么断开连接需要四次挥手为什么不能像建立连接那样三次？毕竟三次就能保证互相知晓了。 回顾上面的图，可以看到服务端得知客户端想要断开连接后，先给客户端发了一个ACK包，然后又发了一个FIN包，问题的关键在于这两步能否合并，如果可以那么就可以精简为三次挥手。 答案当然是不可以。因为服务端得知客户端想断开连接时，它这边可能还有些事没处理完，比如还有些消息没发完（我还有话说系列）。等它处理好后，再给客户端发送一个FIN包，表示它也可以结束了，这是客户端再发个ACK包到服务端，表示他知道了。 TCP报文格式这个问题笔者面试时被问到过，当时自信且流畅地说完TCP的连接过程，甚至在内心默默给自己点了个赞。。。后面不说也罢。 TCP的报文构造还是有点复杂的，这里不讨论了，网上找了个图（来源见水印）。 可以看到上面曾有过出镜的FIN、ACK、SYN等东东，这些都存在报文对应位置。 慢开始与拥塞避免 发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。 快重传与快恢复快重传 发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期 快恢复 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法 time_wait何时出现，大量出现时怎么发现和处理time_wait是主动关闭的一方会出现的状态，当收到对方发来的FIN包并返回一个ACK后，进入time_wait。 time_wait存在的原因有两点 可靠地终止连接：若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。 保证迟来的报文段有足够的时间被识别并丢弃：linux 中一个TCPport不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据。 time_wait大量出现的场景，一般是服务端，因为一般是大量客户端连接少量服务端。虽然一般是客户端主动断开连接，但某些情况也可能是客户端向服务端发送一个信息，然后服务端主动关闭。这样就可能导致服务端短时间内出现大量time_wait状态，而占用了资源致使不能创建更多的socket。 几个解决思路： 改为长链接 设计时尽量让客户端主动关闭 重用端口，即服务器设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口 增加IP close_wait何时出现，大量出现时怎么处理close_wait是被动关闭的一方出现的状态，出现原因时，收到要关闭的信号后，自己这边还有些事情没处理完，导致迟迟不能发送FIN包给主动断开的一方。 所以说，一般大量出现都是我们的程序有问题，建议改代码。 通过netstat命令可以查看各种状态的连接数量，举个栗子： 1234567891011➜ ~ netstat -an|awk '/tcp/ &#123;print $6&#125;'|sort|uniq -c 1 CLOSED 8 CLOSE_WAIT 1 CLOSING 42 ESTABLISHED 1 FIN_WAIT_1 2 FIN_WAIT_2 2 LAST_ACK 20 LISTEN 3 SYN_SENT 1 com.apple.network.tcp_ccdebug","categories":[{"name":"网络","slug":"网络","permalink":"https://acupt.cn/categories/网络/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://acupt.cn/tags/TCP/"}],"keywords":[{"name":"网络","slug":"网络","permalink":"https://acupt.cn/categories/网络/"}]},{"title":"JAVA中有趣的移位操作","slug":"acuprpc-java-bit-move","date":"2019-09-01T13:00:00.000Z","updated":"2019-09-09T13:58:29.181Z","comments":true,"path":"2019/09/01/acuprpc-java-bit-move/","link":"","permalink":"https://acupt.cn/2019/09/01/acuprpc-java-bit-move/","excerpt":"","text":"&lt;&lt;, &gt;&gt;, &gt;&gt;&gt; 这些符号什么意思？有哪些容易被遗漏的细节？ 上次介绍了JAVA中有趣的位运算，知道了位运算是直接对一个整形的二进制位进行操作，效率上比起加减乘除高不少，因此常运用在对性能很敏感的场景。 今天介绍在二进制下的移位操作。 原码、反码、补码磨刀不误砍柴工，这几个名词可还有印象？ 原码: 二进制表示，最左边的一位是符号位，0表示正数，1表示负数 反码: 正数时同原码，负数时，等于原码每位取反（除了符号位） 补码: 正数时同原码，负数时，等于反码+1 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。 JAVA中也一样，存储和移位操作的都是补码，正数时都一样，负数时就要注意了。 &lt;&lt; 左移位在二进制格式下，把所有的数字向左移动指定位数，左边的高位移出(舍弃)，右边的低位多出来的空位补0。 n = n &lt;&lt; 1，左移一位，相当于 n = n * 2 需要注意的是，正数的二进制最高位是0，如果左移后被怼上来的那位是1，这个数就成了负数。 如果觉得奇怪，想想有时候我们遇到过的场景：一个很大的int正数，乘一个正数后如果结果超过了int能存储的极限，往往就变成了负数，或者一个很小的正数。 另一个需要注意的地方，由于Java只存储补码，正数补码和原码相同先不管，负数的补码会把原码的0变成1，所以负数左移位时，移出去的最高是1，后面怼上来的一般也是1(没到极限)，所以还是负数。 对于程序员，或许还是把内容和代码放在一起更容易让人注意... 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Bit &#123; public static void main(String[] args) &#123; int n = 6; // ..000110 (6) System.out.println(n + \"左移1位 \" + (n &lt;&lt; 1));// ..001100 (12) System.out.println(n + \"左移2位 \" + (n &lt;&lt; 2));// ..011000 (24) System.out.println(n + \"左移3位 \" + (n &lt;&lt; 3));// ..110000 (48) // 通过2进制的方式赋值(jdk7+)，0b开头，后面是二进制表示(超过int最大值就要结尾加L成为Long) // 等同于int x = 1073741825 // 01000000000000000000000000000001 第一位0表示正数 int x = 0b01000000000000000000000000000001; System.out.println(\"x = \" + x); // 10000000000000000000000000000010 // 左移后最高位成了1，变成了负数 System.out.println(\"x左移1位\\t= \" + (x &lt;&lt; 1)); // 就像乘2如果超过了int最大值也会变成负数，结果是一样一样的 System.out.println(\"x乘2\\t= \" + (x * 2)); // 如果左移两位，最高位依然是正数(4) // 00000000000000000000000000000100 System.out.println(\"x左移2位\\t= \" + (x &lt;&lt; 2)); // 正数超过极限可能变成负数，负数变成正数也不奇怪吧 System.out.println(\"x乘4\\t= \" + (x * 2 * 2)); // y = -3 时: // 原码: 10000000000000000000000000000011 // 反码: 11111111111111111111111111111100 (符号位除外，其余取反) // 补码: 11111111111111111111111111111101 (反码+1) // Java存储补码，移位操作也是对补码操作 // 也就解释了为啥负数时左移1位也能和乘2结果一样(最高位的1没了，后面跟上来的也是1，符号还是负) int y = -3; System.out.println(y + \" 二进制表示(补码) \" + Integer.toBinaryString(y)); //补码左移一位后: 11111111111111111111111111111010 //转为反码: 11111111111111111111111111111001 (补码-1) //转为原码: 10000000000000000000000000000110 //十进制: -6 System.out.println(y + \" 左移1位 \" + (y &lt;&lt; 1)); &#125;&#125;/* 输出:6左移1位 126左移2位 246左移3位 48x = 1073741825x左移1位 = -2147483646x乘2 = -2147483646x左移2位 = 4x乘4 = 4-3 二进制表示(补码) 11111111111111111111111111111101-3 左移1位 -6*/ &gt;&gt; 右移位在二进制格式下，把所有的数字向右移动指定位数，低位移出(舍弃)，高位的空位补符号位，即正数补0，负数补1(想想负数存的补码和原码是不同的)。 n = n &gt;&gt; 1，右移一位，相当于 n = n / 2 (PS:正数时) 12345678910111213141516171819public class Bit &#123; public static void main(String[] args) &#123; int n = 6; // ..110 (6) System.out.println(n + \"右移1位 \" + (n &gt;&gt; 1));// ..011 (3) System.out.println(n + \"右移2位 \" + (n &gt;&gt; 2));// ..001 (1) System.out.println(n + \"右移3位 \" + (n &gt;&gt; 3));// ..000 (0) System.out.println(n + \"右移4位 \" + (n &gt;&gt; 4));// ..000 (0) &#125;&#125;/* 输出:6右移1位 36右移2位 16右移3位 06右移4位 0*/ 上面是正数右移，负数的时候情况又有点不同了。 由于计算机存储和位移的都是补码，正数补码和原码一样，一直右移最后都变成了0，就像一直整除2，最后不管怎么除都是0。 而负数的补码一直右移最后全都是1，即: 1234补码: 11111111111111111111111111111111反码: 11111111111111111111111111111110 (补码-1)原码: 10000000000000000000000000000001十进制: -1 12345678910111213141516171819public class Bit &#123; public static void main(String[] args) &#123; int m = -3; System.out.println(m + \"\\t补码 \" + Integer.toBinaryString(m)); System.out.println(m + \"\\t补码右移1位 \" + (m &gt;&gt; 1)); System.out.println(m + \"\\t补码右移2位 \" + (m &gt;&gt; 2)); System.out.println(m + \"\\t补码右移3位 \" + (m &gt;&gt; 3)); &#125;&#125;/* 输出:-3 补码 11111111111111111111111111111101-3 补码右移1位 -2-3 补码右移2位 -1-3 补码右移3位 -1*/ &gt;&gt;&gt; 无符号右移依然是右移指定位数，与右移不同的是，无论正负，高位均补0。对于正数没影响，对于负数来说，这样一移，直接变成正数了。 12345678910111213141516171819public class Bit &#123; public static void main(String[] args) &#123; int m = -3; System.out.println(m + \"\\t补码 \" + Integer.toBinaryString(m)); System.out.println(m + \"\\t补码无符号右移1位 \" + (m &gt;&gt;&gt; 1)); System.out.println(m + \"\\t补码无符号右移2位 \" + (m &gt;&gt;&gt; 2)); System.out.println(m + \"\\t补码无符号右移3位 \" + (m &gt;&gt;&gt; 3)); &#125;&#125;/* 输出:-3 补码 11111111111111111111111111111101-3 补码无符号右移1位 2147483646-3 补码无符号右移2位 1073741823-3 补码无符号右移3位 536870911*/ &lt;&lt;&lt; 无符号左移 位数限制一个容易忽略的地方，每次移动一位循环N次，和一次移动N位，结果并不一定是一样的。 以int为例，如果直接左移36位，结果并不是0，而是等同于左移36%32=4位。 右移和无符号右移也同样适用。 1234567891011121314151617181920public class Bit &#123; public static void main(String[] args) &#123; int m = 3; int t = m; for (int i = 1; i &lt;= 36; i++) &#123; t = t &lt;&lt; 1; &#125; System.out.println(t); System.out.println(m &lt;&lt; 36); System.out.println(m &lt;&lt; (36 % 32)); &#125;&#125;/* 输出:04848*/ 总结 箭头朝哪边，就往哪边移位 左移操作相当于乘2，右移相当于除2，不全是 左移操作可能改变正负，因为符号位会被移走，新符号位不一定和以前一样 右移操作不改变符号，因为左边填充的是符号位 无符号右移会把负数变成正数 没有无符号左移 位移超过JAVA基本类型的位数后，等同于位移取模后的位数","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/tags/JAVA/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}]},{"title":"JAVA中有趣的位运算","slug":"acuprpc-java-bit","date":"2019-08-29T13:00:00.000Z","updated":"2019-08-29T16:43:21.775Z","comments":true,"path":"2019/08/29/acuprpc-java-bit/","link":"","permalink":"https://acupt.cn/2019/08/29/acuprpc-java-bit/","excerpt":"","text":"&amp;, |, ^, ~ 这些符号什么意思？有什么妙用？一起来感受它们的神奇吧~ 当我们看一些源码的时候，经常会看到诸如 &amp;、|、^、~ 的符号，这些就是位运算符。 位运算是直接对一个整形的二进制位进行操作，效率上比起加减乘除高不少，因此常运用在对性能很敏感的场景。 &amp; 与运算在二进制格式下，将两个数的每一位（1或0）分别做与运算（1&amp;1=1，其它=0），得到一个新的二进制数。 1234567891011121314public class Bit &#123; public static void main(String[] args) &#123; /* * 十进制 二进制 * 5 0 1 0 1 从最低位(右)开始比较，不足的为0 * 与 与 * 14 1 1 1 0 * = = * 4 0 1 0 0 */ System.out.println(5 &amp; 14); &#125;&#125;// 输出: 4 判断整数n是奇数还是偶数： n &amp; 1 = 0 偶数 n &amp; 1 = 1 奇数 原理：二进制格式下，右边第一位是0则是偶数，反之为奇数，因此只需要和1进行与运算即可。 | 或运算在二进制格式下，将两个数的每一位（1或0）分别做或运算（0|0=0，其它=1），得到一个新的二进制数。 1234567891011121314public class Bit &#123; public static void main(String[] args) &#123; /* * 十进制 二进制 * 2 0 1 0 从最低位(右)开始比较，不足的为0 * 或 或 * 4 1 0 0 * = = * 6 1 1 0 */ System.out.println(2 | 4); &#125;&#125;// 输出: 6 在Linux系统中，文件权限管理用1、2、4分别表示执行x、写w、读r的权限。 可以看做一个三位的二进制数，每一位分别表示一种权限的开启与否（1开启，0关闭），通过或运算组合就得到了不同的权限组合。 所以最高权限就是7，即二进制的“111”，拥有读、写、执行全部权限。而777权限则是所属用户、组用户、其他用户都拥有最高权限。 基于这个思路，我们只需要一个int或者long型的数字就可以存储几十个布尔类型的属性值，在某些场景下很有用。 ^ 异或运算异或：相同为false，不同true 在二进制格式下，将两个数的每一位（1或0）分别做异或运算（0^0=0，1^1=0, 其它=1），得到一个新的二进制数。 123456789101112131415public class Bit &#123; public static void main(String[] args) &#123; /* * 十进制 二进制 * 2 0 1 0 从最低位(右)开始比较，不足的为0 * 异或 异或 * 6 1 1 0 * = = * 4 1 0 0 */ System.out.println(2 ^ 6); &#125;&#125;// 输出: 4 异或有个有趣的特性，它的逆运算是它本身，即A^B=C，C^B=A。基于这个特点，可以做一个简单的加密，把B作为秘钥，原文A用秘钥B加密后进行传输或存储等，使用时再用秘钥B进行解密。 通过异或操作还能实现两个数的交换，不需要中间值。(简单测了下性能并没有很棒棒) 12345678910111213141516171819public class Bit &#123; public static void main(String[] args) &#123; int x = 2;// 010 int y = 4;// 100 x = x ^ y;// 110 y = y ^ x;// 010 x = x ^ y;// 100 System.out.println(\"x = \" + x); System.out.println(\"y = \" + y); &#125;&#125;/* 输出:x = 4y = 2*/ ~ 非运算在二进制格式下，将两个数的每一位（1或0）分别做非运算（~0=1，~1=0），得到一个新的二进制数。 12345678public class Bit &#123; public static void main(String[] args) &#123; System.out.println(~1); &#125;&#125;// 输出: -2 1进行非运算后值成了负数，不只是1，只要是正数，取非后都是负数，因为对于有符号的整数，最高位（最左边）是用来表示正负的，最高位为0是正数，1是负数。 正数1非运算后从“00000000000000000000000000000001”变成了“11111111111111111111111111111110”。 二进制表示负数的情况，要转成十进制需要两个步骤： 逐位取反 -&gt; 00000000000000000000000000000001(2进制) 加1 -&gt; 00000000000000000000000000000010(2进制) -&gt; 2(10进制) 加上负号 -&gt; -2(10进制) 总结通过位运算可以巧妙且高效地达到某些目的，但如果不是很有必要，并不建议使用，毕竟可读性不高，别人看起来太痛苦（想想在阅读源码时看到一堆位运算的心情）。 这次简单介绍了与、或、非、异或，下次再讲讲移位操作的实践。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/tags/JAVA/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}]},{"title":"探索JAVA并发 - 并发容器全家福","slug":"concurrent-container","date":"2019-08-25T14:00:00.000Z","updated":"2019-08-25T17:03:17.414Z","comments":true,"path":"2019/08/25/concurrent-container/","link":"","permalink":"https://acupt.cn/2019/08/25/concurrent-container/","excerpt":"","text":"14个并发容器，你用过几个？ 不考虑多线程并发的情况下，容器类一般使用ArrayList、HashMap等线程不安全的类，效率更高。在并发场景下，常会用到ConcurrentHashMap、ArrayBlockingQueue等线程安全的容器类，虽然牺牲了一些效率，但却得到了安全。 上面提到的线程安全容器都在java.util.concurrent包下，这个包下并发容器不少，今天全部翻出来鼓捣一下。 仅做简单介绍，后续再分别深入探索。 简介 ConcurrentHashMap： 并发版HashMap CopyOnWriteArrayList： 并发版ArrayList CopyOnWriteArraySet： 并发Set ConcurrentLinkedQueue： 并发队列(基于链表) ConcurrentLinkedDeque： 并发队列(基于双向链表) ConcurrentSkipListMap： 基于跳表的并发Map ConcurrentSkipListSet： 基于跳表的并发Set ArrayBlockingQueue： 阻塞队列(基于数组) LinkedBlockingQueue： 阻塞队列(基于链表) LinkedBlockingDeque： 阻塞队列(基于双向链表) PriorityBlockingQueue： 线程安全的优先队列 SynchronousQueue： 读写成对的队列 LinkedTransferQueue： 基于链表的数据交换队列 DelayQueue： 延时队列 ConcurrentHashMap 并发版HashMap最常见的并发容器之一，可以用作并发场景下的缓存。底层依然是哈希表，但在JAVA 8中有了不小的改变，而JAVA 7和JAVA 8都是用的比较多的版本，因此经常会将这两个版本的实现方式做一些比较（比如面试中）。 一个比较大的差异就是，JAVA 7中采用分段锁来减少锁的竞争，JAVA 8中放弃了分段锁，采用CAS（一种乐观锁），同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。 CopyOnWriteArrayList 并发版ArrayList并发版ArrayList，底层结构也是数组，和ArrayList不同之处在于：当新增和删除元素时会创建一个新的数组，在新的数组中增加或者排除指定对象，最后用新增数组替换原来的数组。 适用场景：由于读操作不加锁，写（增、删、改）操作加锁，因此适用于读多写少的场景。 局限：由于读的时候不会加锁（读的效率高，就和普通ArrayList一样），读取的当前副本，因此可能读取到脏数据。如果介意，建议不用。 看看源码感受下： 1234567891011121314151617181920212223242526public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; final transient ReentrantLock lock = new ReentrantLock(); private transient volatile Object[] array; // 添加元素，有锁 public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); // 修改时加锁，保证并发安全 try &#123; Object[] elements = getArray(); // 当前数组 int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); // 创建一个新数组，比老的大一个空间 newElements[len] = e; // 要添加的元素放进新数组 setArray(newElements); // 用新数组替换原来的数组 return true; &#125; finally &#123; lock.unlock(); // 解锁 &#125; &#125; // 读元素，不加锁，因此可能读取到旧数据 public E get(int index) &#123; return get(getArray(), index); &#125;&#125; CopyOnWriteArraySet 并发Set基于CopyOnWriteArrayList实现（内含一个CopyOnWriteArrayList成员变量），也就是说底层是一个数组，意味着每次add都要遍历整个集合才能知道是否存在，不存在时需要插入（加锁）。 适用场景：在CopyOnWriteArrayList适用场景下加一个，集合别太大（全部遍历伤不起）。 ConcurrentLinkedQueue 并发队列(基于链表)基于链表实现的并发队列，使用乐观锁(CAS)保证线程安全。因为数据结构是链表，所以理论上是没有队列大小限制的，也就是说添加数据一定能成功。 ConcurrentLinkedDeque 并发队列(基于双向链表)基于双向链表实现的并发队列，可以分别对头尾进行操作，因此除了先进先出(FIFO)，也可以先进后出（FILO），当然先进后出的话应该叫它栈了。 ConcurrentSkipListMap 基于跳表的并发MapSkipList即跳表，跳表是一种空间换时间的数据结构，通过冗余数据，将链表一层一层索引，达到类似二分查找的效果。 ConcurrentSkipListSet 基于跳表的并发Set类似HashSet和HashMap的关系，ConcurrentSkipListSet里面就是一个ConcurrentSkipListMap，就不细说了。 ArrayBlockingQueue 阻塞队列(基于数组)基于数组实现的可阻塞队列，构造时必须制定数组大小，往里面放东西时如果数组满了便会阻塞直到有位置（也支持直接返回和超时等待），通过一个锁ReentrantLock保证线程安全。 用offer操作举个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; /** * 读写共用此锁，线程间通过下面两个Condition通信 * 这两个Condition和lock有紧密联系（就是lock的方法生成的） * 类似Object的wait/notify */ final ReentrantLock lock; /** 队列不为空的信号，取数据的线程需要关注 */ private final Condition notEmpty; /** 队列没满的信号，写数据的线程需要关注 */ private final Condition notFull; // 一直阻塞直到有东西可以拿出来 public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125; // 在尾部插入一个元素，队列已满时等待指定时间，如果还是不能插入则返回 public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); // 锁住 try &#123; // 循环等待直到队列有空闲 while (count == items.length) &#123; if (nanos &lt;= 0) return false;// 等待超时，返回 // 暂时放出锁，等待一段时间（可能被提前唤醒并抢到锁，所以需要循环判断条件） // 这段时间可能其他线程取走了元素，这样就有机会插入了 nanos = notFull.awaitNanos(nanos); &#125; enqueue(e);//插入一个元素 return true; &#125; finally &#123; lock.unlock(); //解锁 &#125; &#125; 乍一看会有点疑惑，读和写都是同一个锁，那要是空的时候正好一个读线程来了不会一直阻塞吗？ 答案就在notEmpty、notFull里，这两个出自lock的小东西让锁有了类似synchronized + wait + notify的功能。传送门 → 终于搞懂了sleep/wait/notify/notifyAll LinkedBlockingQueue 阻塞队列(基于链表)基于链表实现的阻塞队列，想比与不阻塞的ConcurrentLinkedQueue，它多了一个容量限制，如果不设置默认为int最大值。 LinkedBlockingDeque 阻塞队列(基于双向链表)类似LinkedBlockingQueue，但提供了双向链表特有的操作。 PriorityBlockingQueue 线程安全的优先队列构造时可以传入一个比较器，可以看做放进去的元素会被排序，然后读取的时候按顺序消费。某些低优先级的元素可能长期无法被消费，因为不断有更高优先级的元素进来。 SynchronousQueue 数据同步交换的队列一个虚假的队列，因为它实际上没有真正用于存储元素的空间，每个插入操作都必须有对应的取出操作，没取出时无法继续放入。 一个简单的例子感受一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) &#123; SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; try &#123; // 没有休息，疯狂写入 for (int i = 0; ; i++) &#123; System.out.println(\"放入: \" + i); queue.put(i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); new Thread(() -&gt; &#123; try &#123; // 咸鱼模式取数据 while (true) &#123; System.out.println(\"取出: \" + queue.take()); Thread.sleep((long) (Math.random() * 2000)); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125;&#125;/* 输出:放入: 0取出: 0放入: 1取出: 1放入: 2取出: 2放入: 3取出: 3*/ 可以看到，写入的线程没有任何sleep，可以说是全力往队列放东西，而读取的线程又很不积极，读一个又sleep一会。输出的结果却是读写操作成对出现。 JAVA中一个使用场景就是Executors.newCachedThreadPool()，创建一个缓存线程池。 1234567public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor( 0, // 核心线程为0，没用的线程都被无情抛弃 Integer.MAX_VALUE, // 最大线程数理论上是无限了，还没到这个值机器资源就被掏空了 60L, TimeUnit.SECONDS, // 闲置线程60秒后销毁 new SynchronousQueue&lt;Runnable&gt;()); // offer时如果没有空闲线程取出任务，则会失败，线程池就会新建一个线程&#125; LinkedTransferQueue 基于链表的数据交换队列实现了接口TransferQueue，通过transfer方法放入元素时，如果发现有线程在阻塞在取元素，会直接把这个元素给等待线程。如果没有人等着消费，那么会把这个元素放到队列尾部，并且此方法阻塞直到有人读取这个元素。和SynchronousQueue有点像，但比它更强大。 DelayQueue 延时队列可以使放入队列的元素在指定的延时后才被消费者取出，元素需要实现Delayed接口。 总结上面简单介绍了JAVA并发包下的一些容器类，知道有这些东西，遇到合适的场景时就能想起有个现成的东西可以用了。想要知其所以然，后续还得再深入探索一番。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"容器","slug":"容器","permalink":"https://acupt.cn/tags/容器/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 终于搞懂了sleep/wait/notify/notifyAll","slug":"concurrent-wait-notify","date":"2019-08-14T14:30:00.000Z","updated":"2019-08-15T16:52:55.370Z","comments":true,"path":"2019/08/14/concurrent-wait-notify/","link":"","permalink":"https://acupt.cn/2019/08/14/concurrent-wait-notify/","excerpt":"","text":"sleep/wait/notify/notifyAll分别有什么作用？它们的区别是什么？wait时为什么要放在循环里而不能直接用if？ 简介首先对几个相关的方法做个简单解释，Object中有几个用于线程同步的方法：wait、notify、notifyAll。 12345public class Object &#123; public final native void wait(long timeout) throws InterruptedException; public final native void notify(); public final native void notifyAll();&#125; wait: 释放当前锁，阻塞直到被notify或notifyAll唤醒，或者超时，或者线程被中断(InterruptedException) notify: 任意选择一个（无法控制选哪个）正在这个对象上等待的线程把它唤醒，其它线程依然在等待被唤醒 notifyAll: 唤醒所有线程，让它们去竞争，不过也只有一个能抢到锁 sleep: 不是Object中的方法，而是Thread类的静态方法，让当前线程持有锁阻塞指定时间 sleep和waitsleep和wait都可以让线程阻塞，也都可以指定超时时间，甚至还都会抛出中断异常InterruptedException。 而它们最大的区别就在于，sleep时线程依然持有锁，别人无法进当前同步方法；wait时放弃了持有的锁，其它线程有机会进入该同步方法。多次提到同步方法，因为wait必须在synchronized同步代码块中，否则会抛出异常IllegalMonitorStateException，notify也是如此，可以说wait和notify是就是为了在同步代码中做线程调度而生的。 下面一个简单的例子展现sleep和wait的区别： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.Date;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; // 日志行号记录 private AtomicInteger count = new AtomicInteger(); public static void main(String[] args) throws InterruptedException &#123; Main main = new Main(); // 开启两个线程去执行test方法 new Thread(main::test).start(); new Thread(main::test).start(); &#125; private synchronized void test() &#123; try &#123; log(\"进入了同步方法，并开始睡觉，1s\"); // sleep不会释放锁，因此其他线程不能进入这个方法 Thread.sleep(1000); log(\"睡好了，但没事做，有事叫我，等待2s\"); //阻塞在此，并且释放锁，其它线程可以进入这个方法 //当其它线程调用此对象的notify或者notifyAll时才有机会停止阻塞 //就算没有人notify，如果超时了也会停止阻塞 wait(2000); log(\"我要走了，但我要再睡一觉，10s\"); //这里睡的时间很长，因为没有释放锁，其它线程就算wait超时了也无法继续执行 Thread.sleep(10000); log(\"走了\"); notify(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 打印日志 private void log(String s) &#123; System.out.println(count.incrementAndGet() + \" \" + new Date().toString().split(\" \")[3] + \"\\t\" + Thread.currentThread().getName() + \" \" + s); &#125;&#125;/* 输出:1 00:13:23 Thread-0 进入了同步方法，并开始睡觉，1s2 00:13:24 Thread-0 睡好了，但没事做，有事叫我，等待2s3 00:13:24 Thread-1 进入了同步方法，并开始睡觉，1s4 00:13:25 Thread-1 睡好了，但没事做，有事叫我，等待2s5 00:13:26 Thread-0 我要走了，但我要再睡一觉，10s6 00:13:36 Thread-0 走了7 00:13:36 Thread-1 我要走了，但我要再睡一觉，10s8 00:13:46 Thread-1 走了*/ 对输出做个简单解释（已经看懂代码的童鞋可以跳过）： 123456781 00:13:23 Thread-0 进入了同步方法，并开始睡觉，1s // Thread-0首先进入同步方法，Thread-1只能门外候着2 00:13:24 Thread-0 睡好了，但没事做，有事叫我，等待2s // Thread-0 sleep 1秒这段时间，Thread-1没进来，证明sleep没有释放锁3 00:13:24 Thread-1 进入了同步方法，并开始睡觉，1s // Thread-0开始wait后Thread-1马上就进来了，证明wait释放了锁4 00:13:25 Thread-1 睡好了，但没事做，有事叫我，等待2s // Thread-1也打算wait 2秒（2秒后真的能醒来吗？）5 00:13:26 Thread-0 我要走了，但我要再睡一觉，10s // Thread-0已经wait超时醒来了，这次准备sleep 10s6 00:13:36 Thread-0 走了 // 10s过去了Thread-0都sleep结束了，那个说要wait 2s的Thread-1还没动静，证明超时也没用，还得抢到锁7 00:13:36 Thread-1 我要走了，但我要再睡一觉，10s // Thread-0退出同步代码后，Thread-1才终于得到了锁，能行动了8 00:13:46 Thread-1 走了 notify和notifyAll同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。 区别在于： notify：唤醒一个线程，其他线程依然处于wait的等待唤醒状态，如果被唤醒的线程结束时没调用notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断 notifyAll：所有线程退出wait的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁 如果觉得解释的不够明白，代码来一波： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Date;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; private AtomicInteger count = new AtomicInteger(); public static void main(String[] args) throws InterruptedException &#123; Main main = new Main(); // 开启两个线程去执行test方法 for (int i = 0; i &lt; 10; i++) &#123; new Thread(main::testWait).start(); &#125; Thread.sleep(1000); for (int i = 0; i &lt; 5; i++) &#123; main.testNotify(); &#125; &#125; private synchronized void testWait() &#123; try &#123; log(\"进入了同步方法，开始wait\"); wait(); log(\"wait结束\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private synchronized void testNotify() &#123; notify(); &#125; private void log(String s) &#123; System.out.println(count.incrementAndGet() + \" \" + new Date().toString().split(\" \")[3] + \"\\t\" + Thread.currentThread().getName() + \" \" + s); &#125;&#125;/* 输出:1 00:59:32 Thread-0 进入了同步方法，开始wait2 00:59:32 Thread-9 进入了同步方法，开始wait3 00:59:32 Thread-8 进入了同步方法，开始wait4 00:59:32 Thread-7 进入了同步方法，开始wait5 00:59:32 Thread-6 进入了同步方法，开始wait6 00:59:32 Thread-5 进入了同步方法，开始wait7 00:59:32 Thread-4 进入了同步方法，开始wait8 00:59:32 Thread-3 进入了同步方法，开始wait9 00:59:32 Thread-2 进入了同步方法，开始wait10 00:59:32 Thread-1 进入了同步方法，开始wait11 00:59:33 Thread-0 wait结束12 00:59:33 Thread-6 wait结束13 00:59:33 Thread-7 wait结束14 00:59:33 Thread-8 wait结束15 00:59:33 Thread-9 wait结束*/ 例子中有10个线程在wait，但notify了5次，然后其它线程一直阻塞，这也就说明使用notify时如果不能准确控制和wait的线程数对应，可能会导致某些线程永远阻塞。 使用notifyAll唤醒所有等待的线程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Date;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; private AtomicInteger count = new AtomicInteger(); public static void main(String[] args) throws InterruptedException &#123; Main main = new Main(); // 开启两个线程去执行test方法 for (int i = 0; i &lt; 5; i++) &#123; new Thread(main::testWait).start(); &#125; Thread.sleep(1000); main.testNotifyAll(); &#125; private synchronized void testWait() &#123; try &#123; log(\"进入了同步方法，开始wait\"); wait(); log(\"wait结束\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private synchronized void testNotifyAll() &#123; notifyAll(); &#125; private void log(String s) &#123; System.out.println(count.incrementAndGet() + \" \" + new Date().toString().split(\" \")[3] + \"\\t\" + Thread.currentThread().getName() + \" \" + s); &#125;&#125;/* 输出:1 01:03:24 Thread-0 进入了同步方法，开始wait2 01:03:24 Thread-4 进入了同步方法，开始wait3 01:03:24 Thread-3 进入了同步方法，开始wait4 01:03:24 Thread-2 进入了同步方法，开始wait5 01:03:24 Thread-1 进入了同步方法，开始wait6 01:03:25 Thread-1 wait结束7 01:03:25 Thread-2 wait结束8 01:03:25 Thread-3 wait结束9 01:03:25 Thread-4 wait结束10 01:03:25 Thread-0 wait结束*/ 只需要调用一次notifyAll，所有的等待线程都被唤醒，并且去竞争锁，然后依次（无序）获取锁完成了后续任务。 为什么wait要放到循环中使用一些源码中出现wait时，往往都是伴随着一个循环语句出现的，比如： 123456private synchronized void f() throws InterruptedException &#123; while (!isOk()) &#123; wait(); &#125; System.out.println(\"I'm ok\");&#125; 既然wait会被阻塞直到被唤醒，那么用if+wait不就可以了吗？其他线程发现条件达到时notify一下不就行了？ 理想情况确实如此，但实际开发中我们往往不能保证这个线程被notify时条件已经满足了，因为很可能有某个无关(和这个条件的逻辑无关)的线程因为需要线程调度而调用了notify或者notifyAll。此时如果样例中位置等待的线程不巧被唤醒，它就会继续往下执行，但因为用的if，这次被唤醒就不会再判断条件是否满足，最终程序按照我们不期望的方式执行下去。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"},{"name":"同步","slug":"同步","permalink":"https://acupt.cn/tags/同步/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 悲观锁和乐观锁","slug":"concurrent-lock-pessimistic-optimistic","date":"2019-08-10T04:30:00.000Z","updated":"2019-08-10T08:52:01.637Z","comments":true,"path":"2019/08/10/concurrent-lock-pessimistic-optimistic/","link":"","permalink":"https://acupt.cn/2019/08/10/concurrent-lock-pessimistic-optimistic/","excerpt":"","text":"什么是悲观锁，什么是乐观锁，它们是如何实现的？ 定义 悲观锁：对世界充满不信任，认为一定会发生冲突，因此在使用资源前先将其锁住，具有强烈的独占和排他特性。 乐观锁：相信世界是和谐的，认为接下来的操作不会和别人发生冲突，因此不会上锁，直接进行计算，但在更新时还是会判断下这期间是否有人更新过(该有的谨慎还是不能少)，再决定是重新计算还是更新。 悲观锁悲观锁认为一定会有人和它同时访问目标资源，因此必须先将其锁定，常见的synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。 举个简单的例子感受一下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; // java提供的一个可以进行原子操作的类，对它进行加减不会受多线程影响 // 虽然这里实际上用不到 private static AtomicInteger count = new AtomicInteger(); public static void main(String[] args) throws Exception &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; while (true) &#123; System.out.println(Thread.currentThread().getName() + \" waiting\"); visit(); &#125; &#125;).start(); &#125; &#125; private static synchronized void visit() &#123; System.out.println(Thread.currentThread().getName() + \" is coming, count = \" + count.incrementAndGet()); try &#123; Thread.sleep((long) (Math.random() * 5000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; count.decrementAndGet(); &#125;&#125;/* 输出:Thread-0 waitingThread-0 is coming, count = 1Thread-1 waitingThread-2 waitingThread-3 waitingThread-4 waitingThread-0 waitingThread-4 is coming, count = 1Thread-4 waitingThread-3 is coming, count = 1Thread-3 waitingThread-2 is coming, count = 1Thread-2 waitingThread-1 is coming, count = 1Thread-2 is coming, count = 1Thread-1 waitingThread-2 waitingThread-3 is coming, count = 1Thread-3 waitingThread-4 is coming, count = 1Thread-4 waitingThread-0 is coming, count = 1Thread-0 waitingThread-4 is coming, count = 1*/ 从输出可以看到，每次有线程访问这个资源(方法)时，count都是1，也就是说只有一个线程在访问它，这个线程在访问前先锁定了资源，导致其他线程只能等待。 乐观锁乐观锁总是假设会遇到最好的情况，即这个资源除了我没人感兴趣，没人和我抢。虽然理想是美好的，但现实往往是残酷的，所以也不能盲目乐观，还是需要保证并发操作时不会对资源造成错误影响。可以使用版本号机制和CAS算法实现。 版本号机制常用于数据库的版本控制中，即每个数据版本有个版本号字段，每次数据被修改，版本号就会增加。 当一个操作要更新一个数据时，先读取当前版本号并记录，然后修改数据，在提交更新时检测版本号是否变化，如果没变化就应用更新，变化了就重试更新。 CAS算法Compare-And-Swap，比较并交换。 这种算法一般接收两个参数：预估值(expectedValue)和更新值(newValue)，返回一个布尔值（是否更新成功）。如下： 1boolean compareAndSwap(int expectedValue,int newValue); 实现逻辑为，将预估值(expectedValue)和真实值(realValue)比较，如果相同，则把真实值(realValue)修改为更新值(newValue)，返回true，否则返回false。 使用Java代码模拟CAS实现： 1234567891011121314151617181920212223242526272829303132333435public class CASer &#123; // 真实值 private volatile int realValue; // 获取当前值 public int get() &#123; return realValue; &#125; // 自增指定值并获取自增后的值 public synchronized int addAndGet(int increment) &#123; // 不断CAS直到更新成功 // 经常在源码中看到的是for(;;)这种写法，一种说法是两者编译出来的指令不同 // for(;;)编译后指令更简单更快 // 如果不是对性能很敏感随意就好，另外有的编译器可能会在编译时帮你优化成最佳指令 while (true) &#123; int expectedValue = get(); int newValue = expectedValue + increment; if (compareAndSwap(expectedValue, newValue)) &#123; return newValue; &#125; &#125; &#125; // CAS // 如果当前值是expectedValue，则替换成newValue private synchronized boolean compareAndSwap(int expectedValue, int newValue) &#123; if (expectedValue == realValue) &#123; realValue = newValue; return true; &#125; return false; &#125;&#125; 为了模拟CAS，这里用到了synchronized关键字让方法变成同步方法，真这样用CAS也就没必要了，那么Java中是怎么实现CAS的呢？可以在原子类里找到答案。 基于CAS的AtomicIntegerjava.util.concurrent.atomic.* 包下提供了一些基本类型的原子变量类，可以在并发场景进行原子的加减操作，它们就是用到了CAS。 从源码开始理解： 12345678910111213141516171819202122public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; // 获取某个字段相对Java对象的“起始地址”的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // 使用volatile保证可见性 private volatile int value; // 增加指定值，并返回增加后的值 public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; 可以看到，AtomicInteger使用volatile保证真实值的可见性，然后使用Unsafe类提供的CAS操作来更新value的值。 Unsafe类名字看上去不太好听，但它确实不太安全。 Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。 Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。 1234567891011121314151617181920public final class Unsafe &#123; private static final Unsafe theUnsafe; // 单例模式，私有化构造方法 private Unsafe() &#123; &#125; public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; &#125; public native int getIntVolatile(Object var1, long var2); public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); 从源码中可以看出，Unsafe的CAS是通过一系列本地方法实现的。使用了硬件级别的原子操作，效率很高。 CAS算法缺陷只能操作一个共享变量从上面的分析可以看出，CAS只能对单个变量有效，如果有多个资源需要一起使用似乎无法实现。但实际上是有办法的，Java中提供了一个原子引用类，让我们可以以对象为目标进行原子操作，那就是AtomicReference。把多个共享资源放到一个对象中，然后通过AtomicReference包装这个对象即可。类似还有操作数组的AtomicReferenceArray。 过度消耗CPU由于CAS可能会无法更新值，那么一般是在一个循环中不断尝试知道成功，如果竞争很大，有些线程长时间循环，会导致过度消耗CPU。因此CAS更适合在读比写多的情况下使用，反之慎用。 ABA问题再看看开始提到CAS时定义的方法： 1boolean compareAndSwap(int expectedValue,int newValue); 如果真实值等于expectedValue，就能肯定这期间没人操作过资源吗？显然不能，比如另一个线程先把一个数+1，然后又-1。此时虽然值没变，但它已经经历了你不知道的事。 那么ABA会造成什么恶劣影响呢？ 答案是一般不会（不会我说个锤子？但我就是要说，至少面试中经常问到），只能说一般我们期望保证在操作过程中没有其它人访问过这个资源，我才会应用我这段时间的更新（乐观锁也是锁啊，当然要保证这段时间只有我在操作啊，虽然我没锁定，但原则问题不能迁就），但是ABA使我们期望落空了，我们还不能察觉。 想举个ABA造成不良影响的例子，硬是想不出来，网上也没找到喜欢的，有没有大佬留言来一个？ ABA解决方案：核心思想就是，用于判断是否更新的值不能变回用过的值，这需要业务逻辑上做一定调整。Java中的解决方案是AtomicStampedReference，一个带版本号的原子引用类，比较时不比较业务中要用的值（这个值可能又回到最初的起点），使用一个版本号，每次修改都将版本号增加，也就是前面提到的版本号机制。 总结 悲观锁：锁定资源 -&gt; 使用 -&gt; 释放资源 乐观锁：获取资源快照 -&gt; 使用 -&gt; 确定资源没改变 -&gt; 更新 悲观锁适用竞争激烈的场景，乐观锁反之 乐观锁可以用 版本号机制 + CAS算法 实现","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://acupt.cn/tags/并发/"},{"name":"锁","slug":"锁","permalink":"https://acupt.cn/tags/锁/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 可重入锁和不可重入锁","slug":"concurrent-lock-reentrant","date":"2019-08-08T14:30:00.000Z","updated":"2019-08-14T14:51:05.418Z","comments":true,"path":"2019/08/08/concurrent-lock-reentrant/","link":"","permalink":"https://acupt.cn/2019/08/08/concurrent-lock-reentrant/","excerpt":"","text":"什么是可重入锁，什么是不可重入锁，它们是如何实现的？ 定义 可重入锁：当线程获取某个锁后，还可以继续获取它，可以递归调用，而不会发生死锁； 不可重入锁：与可重入相反，获取锁后不能重复获取，否则会死锁（自己锁自己）。 不可重入锁用代码说话。 基于 wait/notify 实现不可重入锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.concurrent.locks.ReentrantLock;/** * 不可重入锁 */public class ReentrantForbiddenLock &#123; private Thread owner;// 持有锁的线程，为空表示无人占有 /** * 获取锁，锁被占用时阻塞直到锁被释放 * * @throws InterruptedException 等待锁时线程被中断 */ public synchronized void lock() throws InterruptedException &#123; Thread thread = Thread.currentThread(); // wait()方法一般和while一起使用，防止因其它原因唤醒而实际没达到期望的条件 while (owner != null) &#123; System.out.println(String.format(\"%s 等待 %s 释放锁\", thread.getName(), owner.getName())); wait(); // 阻塞，直到被唤起 &#125; System.out.println(thread.getName() + \" 获得了锁\"); owner = thread;//成功上位 &#125; public synchronized void unlock() &#123; //只有持有锁的线程才有资格释放锁，别的线程不能强迫它 if (Thread.currentThread() != owner) &#123; throw new IllegalMonitorStateException(); &#125; System.out.println(owner.getName() + \" 释放了持有的锁\"); owner = null; notify();//唤醒一个等待锁的线程，也可以用notifyAll() &#125; public static void main(String[] args) throws InterruptedException &#123; ReentrantForbiddenLock lock = new ReentrantForbiddenLock(); lock.lock(); // 获取锁 lock.lock(); // 还想再来一次 &#125;&#125;/* 输出:main 获得了锁main 等待 main 释放锁*/ 第二次调用lock后线程就阻塞了，线程开始等待持有锁的线程放手，然而是它是它就是它。 基于自旋锁实现不可重入锁自旋锁，即获取锁的线程在锁被占用时，不是阻塞，而是不断循环去尝试，直到获取锁。 好处：线程保持活跃，减少了线程切换的开销 缺点：很消耗CPU，特别是等待时间很长时 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.locks.ReentrantLock;/** * 不可重入锁 */public class ReentrantForbiddenLock &#123; // 原子引用：持有锁的线程，为空表示无人占有 private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;(); /** * 获取锁，锁被占用时阻塞直到锁被释放 * 使用CAS原子操作，不用synchronized同步了 */ public void lock() &#123; Thread thread = Thread.currentThread(); // compareAndSet: 原子操作，依赖操作系统底层实现 // 如果当前持有值为null，则替换为thread，并返回true，否则返回false while (!owner.compareAndSet(null, thread)) &#123; // 真正用时可不敢这样打印，那输出太多了 System.out.println(String.format(\"%s 等待 %s 释放锁\", thread.getName(), owner.get().getName())); &#125; System.out.println(thread.getName() + \" 获得了锁\"); &#125; public void unlock() &#123; Thread thread = Thread.currentThread(); if (owner.compareAndSet(thread, null)) &#123; System.out.println(thread.getName() + \" 释放了锁\"); return; &#125; //只有持有锁的线程才有资格释放锁，别的线程不能强迫它 throw new IllegalMonitorStateException(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReentrantForbiddenLock lock = new ReentrantForbiddenLock(); lock.lock(); lock.lock(); &#125;&#125;/* 输出:main 获得了锁main 等待 main 释放锁main 等待 main 释放锁main 等待 main 释放锁...*/ 如果不想磁盘爆掉，不要在自旋过程中随便打印日志😈 可重入锁不可重入锁扩展一下，增加一个计数器，同一个线程每次获取锁计数器加1，释放锁减1，为0时释放锁。 基于自旋锁实现可重入锁直接用上个例子的代码改一下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.util.concurrent.atomic.AtomicReference;import java.util.concurrent.locks.ReentrantLock;/** * 不可重入锁 */public class ReentrantForbiddenLock &#123; // 原子引用：持有锁的线程，为空表示无人占有 private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;&gt;(); // 计数器 private int count; /** * 获取锁，锁被占用时阻塞直到锁被释放 */ public void lock() &#123; Thread thread = Thread.currentThread(); if (thread == owner.get()) &#123; count++; System.out.println(thread.getName() + \" 再次获得了锁， count = \" + count); return; &#125; // compareAndSet: 原子操作，依赖操作系统底层实现 // 如果当前持有值为null，则替换为thread，并返回true，否则返回false while (!owner.compareAndSet(null, thread)) &#123; // 真正用时可不敢这样打印，那输出太多了 System.out.println(String.format(\"%s 等待 %s 释放锁\", thread.getName(), owner.get().getName())); &#125; count = 1;//为了便于理解初始化为1 System.out.println(thread.getName() + \" 获得了锁\"); &#125; public void unlock() &#123; Thread thread = Thread.currentThread(); if (thread == owner.get()) &#123; count--; System.out.println(thread.getName() + \" 释放了锁，count = \" + count); if (count == 0) &#123; owner.set(null); System.out.println(thread.getName() + \" 彻底释放了锁\"); &#125; return; &#125; //只有持有锁的线程才有资格释放锁，别的线程不能强迫它 throw new IllegalMonitorStateException(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReentrantForbiddenLock lock = new ReentrantForbiddenLock(); lock.lock(); lock.lock(); lock.unlock(); lock.unlock(); &#125;&#125;/* 输出:main 获得了锁main 再次获得了锁， count = 2main 释放了锁，count = 1main 释放了锁，count = 0main 彻底释放了锁*/ 可重入锁 synchronized没错，用于声明同步方法/代码块的synchronized关键字提供的也是一个可重入锁。 同步方法递归测试： 123456789101112131415161718192021222324252627282930313233343536373839public class Main &#123; public static void main(String[] args) throws Exception &#123; new Thread(() -&gt; &#123; lock(5); &#125;).start(); Thread.sleep(1000); System.out.println(\"我是主线程，我也要来\"); lock(2); &#125; private static synchronized void lock(int count) &#123; if (count == 0) &#123; return; &#125; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \" \" + count); lock(count - 1); &#125;&#125;/* 输出:Thread-0 5我是主线程，我也要来Thread-0 4Thread-0 3Thread-0 2Thread-0 1main 2main 1*/ 可重入锁 ReentrantLockReentrantLock是Java中很常见的工具类， 从名字就可以看出，它是个可重入锁，用法也很简单： 1234567891011121314151617181920212223242526272829303132333435363738import java.util.concurrent.locks.ReentrantLock;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 构造函数可传入一个布尔，表示是否使用公平锁(公平锁是什么？请听下回分解) ReentrantLock lock = new ReentrantLock(false); new Thread(() -&gt; &#123; lock.lock(); System.out.println(\"A 获取了锁\"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"A 释放了锁\"); lock.unlock(); &#125;).start(); new Thread(() -&gt; &#123; System.out.println(\"B 等待锁\"); lock.lock(); System.out.println(\"B 获取了锁\"); lock.unlock(); System.out.println(\"B 释放了锁\"); &#125;).start(); &#125;&#125;/* 输出:A 获取了锁B 等待锁A 释放了锁B 获取了锁B 释放了锁*/","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://acupt.cn/tags/并发/"},{"name":"锁","slug":"锁","permalink":"https://acupt.cn/tags/锁/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 如何减少锁的竞争","slug":"concurrent-lock-contention-reduce","date":"2019-08-04T15:20:00.000Z","updated":"2019-08-06T05:02:27.063Z","comments":true,"path":"2019/08/04/concurrent-lock-contention-reduce/","link":"","permalink":"https://acupt.cn/2019/08/04/concurrent-lock-contention-reduce/","excerpt":"","text":"锁的竞争会限制代码的可伸缩性，在并发编程时通过一些手段有意地减少锁竞争，可以让程序有更好的表现。 所谓可伸缩性，即当增加计算资源(如CPU、内存、带宽等)时，程序的吞吐量或处理能力会相应增加。这个时候，我们当然希望增加的效果越明显越好，不过如果锁竞争太严重，可伸缩性会大打折扣。 缩小锁的范围当某个方法需要操作一个线程不安全的共享资源时，最简单的办法就是给方法加上synchronized，这样一来这个方法只能同时有一个线程在执行，满满的安全感。 12345678910111213141516171819public class Counter &#123; private volatile int value; public synchronized void incr(int n) &#123; System.out.println(\"i will incr \" + n); try &#123; // 这个小小的睡眠代表一些线程安全的操作 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"i am ready\"); value = value + n; System.out.println(\"i incr \" + n); &#125; //...&#125; 上述示例的同步方法中有个耗时1秒的准备过程，这个过程是线程安全，但由于身在同步方法中，众线程不得不排队睡觉。这时候不管增加多少个线程，程序该睡多久还是睡多久。若是把这个步骤从同步代码块中移除，大家就能并发睡觉。 123456789101112131415161718192021public class Counter &#123; private volatile int value; public void incr(int n) &#123; System.out.println(\"i will incr \" + n); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"i am ready\"); synchronized (this) &#123; // 只有这行代码是不能并发执行的 value = value + n; &#125; System.out.println(\"i incr \" + n); &#125; //...&#125; 通过上述示例就让线程在持有锁时需要执行的指令尽可能小，并发的效率更高了。 但如果多个线程不安全的操作之间隔着一些安全的耗时操作，是分别使用同步块，还是用一个同步块，并不能说谁一定好。因为同步代码块也是有额外性能开销的，比起同步执行无关的操作，不一定划算，还是需要通过测试，用数据说话。 减小锁粒度 - 锁分解如果一个锁要用来保护多个相互独立的资源，可以考虑用多个锁分别保护某个资源，即锁分解。 如此这般，就不用在只需要操作一个资源时，把其它不相干资源也卷入其中，导致其它想用资源的线程看着这个线程占着茅坑不拉💩（或者占着整个厕所更恰当？）。 使用一个锁保护多个资源下面这个示例，不管想操作哪个资源，都会把所有资源都锁住。 123456789101112public class Counter &#123; private volatile int src1; private volatile int src2; private volatile int src3; public synchronized void incr(int src1, int src2, int src3) &#123; this.src1 += src1; this.src2 += src2; this.src3 += src3; &#125;&#125; 一个锁保护一个资源通过锁分解，每个资源有它自己的锁，可以单独操作。如果想兼容旧代码也是可以的。 12345678910111213141516171819202122232425262728293031public class Counter &#123; private volatile int src1; private volatile int src2; private volatile int src3; // 兼容旧代码，不用修改调用的地方 public void incr(int src1, int src2, int src3) &#123; if (src1 != 0) &#123; incrSrc1(src1); &#125; if (src2 != 0) &#123; incrSrc2(src2); &#125; if (src3 != 0) &#123; incrSrc3(src3); &#125; &#125; public synchronized void incrSrc1(int n) &#123; this.src1 += n; &#125; public synchronized void incrSrc2(int n) &#123; this.src2 += n; &#125; public synchronized void incrSrc3(int n) &#123; this.src3 += n; &#125;&#125; 减小锁粒度 - 锁分段锁分段是锁分解的进一步扩展，对于一组资源集合，可以把资源分为多个小组，每个小组用一个锁来保护，比如我们熟知的ConcurrentHashMap(java8中已经不再使用分段锁了，改为synchronized + cas)。 用的java8，不能分析一波ConcurrentHashMap的分段锁了，写个例子。 12345678910111213141516171819202122232425262728293031public class Counter &#123; private int[] src; private Object[] locks; /** * @param nSrc 资源数量 * @param nLocks 分成几段锁 */ public Counter(int nSrc, int nLocks) &#123; src = new int[nSrc]; locks = new Object[nLocks]; for (int i = 0; i &lt; nLocks; i++) &#123; locks[i] = new Object(); &#125; &#125; /** * @param idx 要访问的资源序号 * @param n 增量 */ public void incr(int idx, int n) &#123; // 根据一定规则（比如hash）找到目标资源归谁管 synchronized (locks[idx % locks.length]) &#123; src[idx] += n; &#125; &#125; //...&#125; 避免热点域上面的例子通过锁分段减小了锁的竞争，因为访问不同段的资源时，需要的锁是不同的，竞争压力也随之减小。毕竟比起10个人竞争一个名额，10个人竞争5个名额的话大家冲突不会那么大。 但是，依然会存在需要同时访问多个资源的情况，比如计算当前所有资源的总和，这个时候锁的粒度就很难降低了。当锁的粒度无法降低时，为了减少等待的时间，机智的程序员往往会用一些优化措施，比如把计算的结果缓存起来，热点域就随之被引入了。 依然以上面的代码为例，增加一个计数器来记录资源的变化，每个资源变化都修改计数器，这样当需要统计所有资源时，只需要返回计数器的值就行了。这个计数器就是一个热点域。 全局计数器引入热点域12345678910111213141516171819202122232425262728293031323334353637383940414243public class Counter &#123; private int[] src; private Object[] locks; // 全局计数器 private volatile int count; /** * @param nSrc 资源数量 * @param nLocks 分成几段锁 */ public Counter(int nSrc, int nLocks) &#123; src = new int[nSrc]; locks = new Object[nLocks]; for (int i = 0; i &lt; nLocks; i++) &#123; locks[i] = new Object(); &#125; &#125; /** * @param idx 要访问的资源序号 * @param n 增量 */ public void incr(int idx, int n) &#123; // 根据一定规则（比如hash）找到目标资源归谁管 synchronized (locks[idx % locks.length]) &#123; src[idx] += n; &#125; // 不管操作哪个分段的资源，计数时都竞争同一个锁 synchronized (this) &#123; count++; &#125; &#125; // 直接返回缓存的值 public int count() &#123; return count; &#125; //...&#125; 分段计数器避免热点域上述通过全局计数器缓存计算的结果虽然让获取计数方法的开销从O(n)变成了O(1)，但却引入了热点域，每次访问资源都要访问同一个计数器，这时候对可伸缩性就产生了一定影响，因为不管怎么增加并发资源，在访问计数器时都会有竞争。 ConcurrentHashMap中的做法是为每段数据单独维护一个计数器，然后获取总数时再对所有分段的计数做一个累加（真实情况会更复杂，比如ConcurrentHashMap会计算两次modCount并比较，如果不相等表示计算过程有变动，就会给所有分段加锁再累加）。 对全局计数器的例子做了简单的改写，去掉了热点域。但换个角度，这样却也让获取总数的方法性能受到了影响，因此实际操作时还需要根据业务场景权衡利弊。鱼和熊掌不可兼得，虽然很想说我全都要。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Counter &#123; private int[] src; private Lock[] locks; /** * @param nSrc 资源数量 * @param nLocks 分成几段锁 */ public Counter(int nSrc, int nLocks) &#123; src = new int[nSrc]; locks = new Lock[nLocks]; for (int i = 0; i &lt; nLocks; i++) &#123; locks[i] = new Lock(); &#125; &#125; /** * @param idx 要访问的资源序号 * @param n 增量 */ public void incr(int idx, int n) &#123; // 根据一定规则（比如hash）找到目标资源归谁管 int lockIdx = idx % locks.length; synchronized (locks[lockIdx]) &#123; src[idx] += n; locks[lockIdx].count++; &#125; &#125; public int count() &#123; // 就不像ConcurrentHashMap那么严谨了，意思一下 int sum = 0; for (Lock lock : locks) &#123; sum += lock.count; &#125; return sum; &#125; // 锁 private static class Lock &#123; volatile int count; &#125; //...&#125; 替代独占锁有时候可以选择放弃使用独占锁，改用更加友好的并发方式。 读写锁 读写锁(ReentrantReadWriteLock)维护了一对锁（一个读锁和一个写锁），通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。 在读比写多的场景下，使用读写锁往往比一般的独占锁有更好的性能表现。 原子变量 原子变量可以降低热点域的更新开销，但无法消除。 java.util.concurrent.atomic.* 包下有一些对应基本类型的原子变量类，使用了操作系统底层的能力，使用CAS(比较并交换，compare-and-swap)更新值。 检测CPU利用率通过检测CPU的利用率，分析出可能限制程序性能的点，做出相应措施。 CPU利用率不均匀多核的机器上，如果某个CPU忙成🐶，其它CPU就在旁边喊666，那证明当前程序的的大部分计算工作都由一小组线程在做。这时候可以考虑把这部分工作多拆分几个线程来做（比如参考CPU数）。 CPU利用不充分和CPU利用率不均匀的区别在于，他可能是均匀的，就是大家都在磨洋工。 CPU利用不充分一般有以下几个原因： 负载不均衡：僧多粥少，一人能分点事做就不错了。这种情况可以考虑增加工作量，不要怜惜它们； I/O密集：程序就不是CPU密集型的，这种情况可以想办法增加I/O效率（比如增加任务/并发、提高带宽），以此来使CPU利用率得到一定提高； 外部依赖限制：比如调用其它服务等待太久，瓶颈在别人那。可以像I/O密集那样自我提升，实力足够的话也可以改变别人； 锁竞争：本文探索的主题，可以在线程转储信息中寻找等待锁的地方，因地制宜。 CPU忙碌 闲也不行，忙也不行，你还要我怎样？要怎样！ 如果CPU们已经很忙了，证明工作还是很饱和的，如果还想提高效率，可以考虑加派CPU了。不过并不是增加了CPU效率就一定会提升，增加CPU后可能又会变成上面两种情况，这是一个循环，当循环停止（无法通过上面的方式得到有效优化），我们的应用基本上达到一个所谓“极限”了。 不使用对象池线程池的应用范围很广，比如各种连接池。当应用创建比较耗时、耗资源时也常用对象池技术。但有时候，高并发下操作对象池带来的性能损耗（线程同步、锁竞争、阻塞…）可能比起在需要的时候直接new一直对象更大。 通常，对象分配操作的开销比线程同步的开销更低。 总结总的来说有3种方式可以降低锁的竞争程度，上面的操作基本都是围绕这3种方式来做的： 减少锁的持有时间（如：缩小锁范围） 降低锁的请求频率（如：锁分解，锁分段） 使用带有协调机制的独占锁（如：分段锁，读写锁） 参考书籍: 《Java并发编程实战》","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"},{"name":"并发","slug":"并发","permalink":"https://acupt.cn/tags/并发/"},{"name":"锁","slug":"锁","permalink":"https://acupt.cn/tags/锁/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"跨域Access-Control-Allow-Origin解决方案","slug":"access-control-allow-origin","date":"2019-07-31T11:00:00.000Z","updated":"2019-07-31T15:19:43.301Z","comments":true,"path":"2019/07/31/access-control-allow-origin/","link":"","permalink":"https://acupt.cn/2019/07/31/access-control-allow-origin/","excerpt":"","text":"前端访问其它域名的资源往往会失败，那是因为浏览器出于安全考虑禁止了不同源的资源。 同源策略 同源策略，它是由Netscape提出的一个著名的安全策略。现在所有支持JavaScript的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。同源策略是浏览器的行为，是为了保护本地数据不被JavaScript代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。 同源：协议 + 域名 + 端口 既然是浏览器的策略，则说明资源请求是可以正常返回的，只是浏览器不给用。 跨域报错本地启动了一个web服务，地址为 127.0.0.1:8882 ，然后通过一个本地静态页面去请求这个接口。虽然在同一台电脑，但依然是跨域的。 上面也说了这个限制是浏览器做的，看看接口，其实已经请求成功了，后端是执行了相关代码的。 后端修改Response支持跨域从上面控制台的输出可以看到，错误原因是请求的资源（接口）的header中没有”Access-Control-Allow-Origin“，那我们可以给它加上。在哪加？既然说是请求的资源没有，那当然是在请求的资源上加，也就是服务端。 1234567891011121314151617181920212223@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public Object test(HttpServletRequest request, HttpServletResponse response) &#123; // 跨域支持 response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST,GET,PUT,DELETE\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"*\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); return map; &#125;&#125; 再看看浏览器，已经可以正常访问接口了。 如果觉得每个接口里面都要配置一下response很麻烦，可以在一个拦截器里面做这个事情。 springboot支持跨域测试用例是一个springboot项目，可以用更简单的方式。通过一个继承了WebMvcConfigurerAdapter的bean，重写addCorsMappings方法，在方法里配置。 1234567891011121314151617181920212223242526@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA extends WebMvcConfigurerAdapter &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public Object test(HttpServletRequest request, HttpServletResponse response) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); return map; &#125; // 跨域支持 @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\") .maxAge(3600); &#125; jsonp支持跨域有前端经验的童鞋知道，有时我们会在自己的代码里直接引入其它域名的js、css等静态文件。为啥这些静态文件没被浏览器限制呢？通常为了减轻web服务器的压力，我们会把js、css，img等静态资源分离到另一台独立域名的服务器上，使其和前端分离开。基于这个原因，浏览器并没有限制这类静态资源的跨域访问。 我们可以动态地创建一个script，让浏览器以为我们要获取静态资源，从而网开一面。而服务器端也需要做一点改变，不能直接返回json，而是返回一个立即执行的函数，而前端请求的结果就作为函数的参数。 后端接口返回12345678910111213141516171819@SpringBootApplication@Configuration@RestControllerpublic class ApplicationA &#123; public static void main(String[] args) &#123; SpringApplication.run(ApplicationA.class, args); &#125; @RequestMapping(\"/test\") public String test(HttpServletRequest request, HttpServletResponse response, String callback) throws IOException &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"success\", true); map.put(\"msg\", \"我来自服务端\"); // 返回值如下： // callback(&#123;\"msg\":\"我来自服务端\",\"success\":true&#125;); return String.format(\"%s(%s);\", callback, JsonUtil.toJson(map)); &#125; js原生实现jsonp12345678910111213141516function test() &#123; // 外部域名，参数是和后端接口约定的callback指定接口返回后的回调函数 url = \"http://localhost:8882/test?callback=_ajax_callback\"; // 创建一个script元素 var script = document.createElement('script'); script.type = 'text/javascript'; script.src = url; document.head.appendChild(script);&#125;// 接口回调function _ajax_callback(res) &#123; console.log(\"被回调了\"); console.log(res);&#125; 接口返回： 回调函数执行： jQuery实现jsonp一般我们会使用jQuery来做ajax请求，这样需要增加一个jQuery的引用。 12345678// 没测，懒得测$.ajax(&#123; url: 'http://localhost:8882/test', type: 'get', dataType: 'jsonp', // 请求方式 jsonpCallback: \"_ajax_callback\", // 回调函数名 data: &#123;&#125;&#125;); vue.js实现jsonp现在前端vue.js用的也很多，再记录一个vue.js的用法。 1234567// 没测，懒得测this.$http.jsonp('http://localhost:8882/test', &#123; params: &#123;&#125;, jsonp: '_ajax_callback'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) jsonp缺点只能实现get请求。 其它方式支持跨域 nginx反向代理：前端访问相同域名，nginx再根据需要把请求转发到外部域名； 后端代理：在后端接口里先请求外部资源（比如用HttpClient），然后把结果返回给前端，这样就不是跨域了； 其它：借助iframe、postMessage等也可实现跨域。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.cn/categories/随笔/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"https://acupt.cn/tags/跨域/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.cn/categories/随笔/"}]},{"title":"探索JAVA并发 - 线程池详解","slug":"concurrent-thread-pool","date":"2019-07-30T13:55:00.000Z","updated":"2019-08-02T07:59:10.107Z","comments":true,"path":"2019/07/30/concurrent-thread-pool/","link":"","permalink":"https://acupt.cn/2019/07/30/concurrent-thread-pool/","excerpt":"","text":"线程池是并发编程中必不可少的一种工具，也是面试高频话题。 线程池，即管理着若干线程的资源池（字面意思）。相比于为每个任务分配一个线程，在线程池中执行任务优势更多： 线程复用：线程池中的线程是可以复用的，省去了创建、销毁线程的开销，提高了资源利用率（创建、销毁等操作都是要消耗系统资源的）和响应速度（任务提交过来线程已存在就不用等待线程创建了）； 合理利用资源：通过调整线程池大小，让所有处理器尽量保持忙碌，又能防止过多线程产生过多竞争浪费资源； 常用的线程池主要是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor(定时任务线程池，继承ThreadPoolExecutor)。 Executor框架 在JAVA中，任务执行的主要抽象不是Thread，而是Executor。Executor基于生产者-消费者模式，提交任务的操作相当于生产者，执行任务的线程相当于消费者。 所谓Executor框架，其实就是定义了一个接口，我们常用的线程池ThreadPoolExecutor就是对这个接口的一种实现。 12345678910111213public interface Executor &#123; /** * Executes the given command at some time in the future. The command * may execute in a new thread, in a pooled thread, or in the calling * thread, at the discretion of the &#123;@code Executor&#125; implementation. * * @param command 可执行的任务 * @throws RejectedExecutionException 任务可能被拒绝（当Executor处理不了的时候） * @throws NullPointerException if command is null */ void execute(Runnable command);&#125; Executors与常用线程池 Executors其实就是Executor(加s) Executors是一个Executor的工厂，有很多定义好的工厂方法，可以帮助懒惰的开发者快速创建一个线程池。下面是几个常用的工厂方法： newFixedThreadPool 固定长度线程池，每次提交任务都会创建一个新线程，直到线程数量达到指定阈值则不再创建新的； newCachedThreadPool 可缓存线程池，每次提交任务都会创建一个新线程（理论上无限制），部分任务执行完后如果没有新的任务，导致某些线程无用武之地，它们将被终结； newSingleThreadExecutor 只有一个线程的线程池； newScheduledThreadPool 可以延时或者定时执行任务的线程池。 12345678910111213141516171819202122232425public class Executors &#123; public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;&#125; 如果查看上述工厂方法的源码，会发现只是new了一个线程池对象返回给调用者而已，没什么花里胡哨的东西。不过看看构造参数还真不少，通过这种方式比起我们自己new一个线程池要简单多了（才怪）。 线程池构造参数了解线程池构造参数的意义，能让我们更清楚程序执行逻辑。 int corePoolSize : 核心线程数，有新任务来时，如果当前线程小于核心线程，则新建一个线程来执行该任务 int maximumPoolSize : 最大线程数，线程池最多拥有的线程数 long keepAliveTime : 空闲线程存活时间 TimeUnit unit : 空闲线程存活时间的单位 BlockingQueue workQueue : 存放待执行任务的阻塞队列，新任务来时，若当前线程数&gt;=最大核心线程数，则放到这个队列(具体逻辑更复杂，请看下面源码分析) ThreadFactory threadFactory : 创建新线程的工厂，一般用来给线程取个名字方便排查问题 RejectedExecutionHandler handler : 任务被拒绝后的处理器，默认的处理器会直接抛出异常，建议重新实现 配合源码，效果更佳： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ThreadPoolExecutor extends AbstractExecutorService &#123; // 构造函数 public ThreadPoolExecutor(int corePoolSize, // 核心线程数 int maximumPoolSize, // 最大线程数 long keepAliveTime, // 空闲线程存活时间 TimeUnit unit, // 空闲线程存活时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, // 存放待执行任务的阻塞队列 ThreadFactory threadFactory, // 创建新线程的工厂 RejectedExecutionHandler handler // 任务被拒绝后的处理器 ) &#123; // ... &#125; // 提交任务 public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * 没翻，懒得翻 * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. */ // 当前状态值 int c = ctl.get(); // 当前线程数 = workerCountOf(c) 小于 核心线程数 的上限时 // 直接创建一个线程来执行任务 if (workerCountOf(c) &lt; corePoolSize) &#123; // 并发提交场景下可能会失败 if (addWorker(command, true)) return; // 新增成功就可以结束了 // 失败就更新下线程池状态 c = ctl.get(); &#125; // 不能创建核心线程来执行，并不会直接创建非核心线程，而是把任务暂存到阻塞队列 // isRunning(c)判断线程池是否还在运行 // workQueue.offer(command)返回值表示是否成功提交到队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 成功放到队列里了，再检查一下线程池状态 int recheck = ctl.get(); // 如果线程池已经没有运行了，则尝试把新增的任务从队列移除 // remove(command)返回值表示是否移除成功 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); // 移除成功后，执行拒绝策略 // 检查下当前线程数是否为0，如果是的话新建一个线程 else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 线程池没有运行，或者放入队列失败（比如队列已满） // 则创建非核心线程去执行任务，这也失败就只能拒绝了 else if (!addWorker(command, false)) reject(command); &#125; 当对线程池的构造参数和任务处理逻辑有了以上大致的了解后，回想Executors提供的几个工厂方法，或许会感到所谓提供便利性的方法并不那么便利。因为从方法的名字上来看很难和线程池的配置准确关联，想要清除地知道这些方法创建的线程池如何运作，就需要知道他们用了怎样的构造参数，那为什么不直接使用构造方法呢？ 所以尽量使用构造方法是更好的编程习惯，这样不管是作者还是其他开发者，只要看看传了什么参数，就知道这个线程池是怎么运作的了。 线程池创建示例1234567891011121314151617181920212223242526272829303132import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; AtomicInteger threadCount = new AtomicInteger(); ThreadPoolExecutor executor = new ThreadPoolExecutor( 5, // 核心线程数 10, // 最大线程数 1, // 空闲线程存活时间 TimeUnit.MINUTES, // 空闲线程存活时间单位 new ArrayBlockingQueue&lt;&gt;(100), // 一个指定上限的阻塞队列，存放待执行任务 new ThreadFactory() &#123; // 自定义一个线程工厂来给线程池里的线程取名字 @Override public Thread newThread(Runnable r) &#123; return new Thread(r, \"pool-thread-\" + threadCount.incrementAndGet()); &#125; &#125;, new RejectedExecutionHandler() &#123; // 自定义一个拒绝处理策略，安慰被线程池拒之门外的小可怜 @Override public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) &#123; System.out.println(\"线程池拒绝了任务: \" + r); &#125; &#125; ); &#125;&#125; 有返回值的提交方式submitThreadPoolExecutor.execute()方法是没有返回值的，也就是说把任务提交给线程池后，我们就失去了它的消息，除非你还保留着它的引用，并且在里面有维护状态。如果不想这么麻烦，可以使用ThreadPoolExecutor.submit()来提交任务，这个方法会返回一个Future对象，通过这个对象可以知道任务何时被执行完。 123456789101112131415161718192021222324252627282930313233import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 线程池定义 // ... Future&lt;?&gt; future = executor.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"我要关注: 一杯82年的JAVA\"); &#125; &#125;); Object r = future.get(); System.out.println(\"返回：\" + r); executor.shutdown(); &#125;&#125;/* 输出: 我要关注: 一杯82年的JAVA返回：null*/ 可以看到Future.get()是有返回值的，但是上面的例子返回了null，因为任务是一个Runnable实现，run方法没有返回值。 submit Callable如果想任务有返回值，可以使用Callable作为任务定义。 12345678910111213141516171819202122232425262728293031323334import java.util.concurrent.*;import java.util.concurrent.atomic.AtomicInteger;public class Main &#123; public static void main(String[] args) throws Exception &#123; // 线程池定义 // ... Future&lt;String&gt; future = executor.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"I'm fine, and you?\"); return \"我要关注: 一杯82年的JAVA\"; &#125; &#125;); String r = future.get(); System.out.println(\"返回：\" + r); executor.shutdown(); &#125;&#125;/* 返回:I'm fine, and you?返回：我要关注: 一杯82年的JAVA*/ submit实现原理为什么submit就可以让用户等待、获取任务返回？从源码讲起： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public abstract class AbstractExecutorService implements ExecutorService &#123; public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); // 把任务用一个RunnableFuture又给包装了一下 RunnableFuture&lt;T&gt; ftask = newTaskFor(task); // 最后还是调用了没有返回值的execute execute(ftask); return ftask; &#125; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125;&#125;// 看看这个包装类public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; private Callable&lt;V&gt; callable; private volatile int state; // 也是Runable的一种实现，所以能在线程池中被执行 public void run() &#123; // 有个表示状态的标识 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 执行用户的逻辑，获得返回值 // 这个步骤可能需要点时间 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; &#125; // 获取执行结果，阻塞直到状态改变 public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s); &#125;&#125; 小结：submit时用一个FutureTask把用户提交的Callable包装起来，再把FutureTask提交给线程池执行，FutureTask.run运行时会执行Callable中的业务代码，并且过程中FutureTask会维护一个状态标识，根据状态标识，可以知道任务是否执行完成，也可以阻塞到状态为完成获取返回值。 关闭线程池为什么需要关闭线程池？ 如果线程池里的线程一直存活，而且这些线程又不是守护线程，那么会导致虚拟机无法正常退出； 如果直接粗暴地结束应用，线程池中的任务可能没执行完，业务将处于未知状态； 线程中有些该释放的资源没有被释放。 怎么关闭线程池？ shutdown 停止接收新任务（继续提交会被拒绝，执行拒绝策略），但已提交的任务会继续执行，全部完成后线程池彻底关闭； shutdownNow 立即停止线程池，并尝试终止正在进行的线程（通过中断），返回没执行的任务集合； awaitTermination 阻塞当前线程，直到全部任务执行完，或者等待超时，或者被中断。 由于shutdownNow的终止线程是通过中断，这个方式并不能保证线程会提前停止。（关于中断: 如何处理线程中断） 一般先调用shutdown让线程池停止接客，然后调用awaitTermination等待正在工作的线程完事。 123456// 你的池子对我打了烊executor.shutdown();// 等待一首歌的时间（bei~bei~~）// 如果超时还没结束返回false，你可以选择再等一首长点的歌，或者不等了boolean ok = executor.awaitTermination(4, TimeUnit.SECONDS); 扩展线程池线程池提供了一些扩展的方法，通过重写这些方法可以添加前置、后置操作，让使用更灵活。如beforeExecute、afterExecute、terminated … 总结线程池很好用，但使用不当会造成严重的后果，了解它各个属性表示的含义以及执行的流程能帮助我们少踩坑。 举个例子：如果设置了核心线程 &lt; 最大线程数不等（一般都这么设置），但是又设置了一个很大的阻塞队列，那么很可能只有几个核心线程在工作，普通线程一直没机会被创建，因为核心线程满了会优先放到队列里，而不是创建普通线程。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"},{"name":"线程池","slug":"线程池","permalink":"https://acupt.cn/tags/线程池/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"源码分析 - JVM关闭钩子的注册和调用","slug":"jvm-shutdown-hook","date":"2019-07-29T14:00:00.000Z","updated":"2019-07-29T15:22:52.264Z","comments":true,"path":"2019/07/29/jvm-shutdown-hook/","link":"","permalink":"https://acupt.cn/2019/07/29/jvm-shutdown-hook/","excerpt":"","text":"通过关闭钩子，我们可以在应用关闭时做一些自定义的操作，让程序更优雅的结束。 JAVA程序运行在虚拟机上(JVM)，JAVA程序执行完成，JVM也随之关闭。关闭的方式有多种，根据其行为的文明程度可大概分为两种： 正常关闭 所有普通线程（非守护线程）执行完毕 System.exit(status) Ctrl - C … 强行关闭 kill进程 Runtime.halt(status) … JVM关闭钩子DEMO123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws Exception &#123; Runtime.getRuntime().addShutdownHook(new MyHook()); System.out.println(\"结束吧\"); &#125; public static class MyHook extends Thread &#123; @Override public void run() &#123; System.out.println(\"你先走，我垫后\"); &#125; &#125;&#125;/* 输出:结束吧你先走，我垫后*/ 自定义钩子如何注册12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Runtime &#123; // 钩子对象必须是一个Thread（或其子类） public void addShutdownHook(Thread hook) &#123; // 看起来是个权限检查 SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkPermission(new RuntimePermission(\"shutdownHooks\")); &#125; // 真正的注册逻辑在这个类里面 ApplicationShutdownHooks.add(hook); &#125;&#125;class ApplicationShutdownHooks &#123; // 钩子集合 private static IdentityHashMap&lt;Thread, Thread&gt; hooks; // 注册一个钩子 static synchronized void add(Thread hook) &#123; if(hooks == null) throw new IllegalStateException(\"Shutdown in progress\"); // 看来注册前不能让Thread跑起来 if (hook.isAlive()) throw new IllegalArgumentException(\"Hook already running\"); // 同一个钩子不能重复注册 if (hooks.containsKey(hook)) throw new IllegalArgumentException(\"Hook previously registered\"); // 放进集合就算注册成功了？继续往下看 hooks.put(hook, hook); &#125; // 初始化，本来在最前面，为了跟随我的节奏被我移到后面了 static &#123; try &#123; // 看来这个类也不是真正实现钩子回调的地方 // 又在Shutdown注册了一个“钩子”，通过这个“钩子”来执行用户自定义的钩子 Shutdown.add(1 /* shutdown hook invocation order */, false /* not registered if shutdown in progress */, new Runnable() &#123; public void run() &#123; runHooks(); &#125; &#125; ); hooks = new IdentityHashMap&lt;&gt;(); &#125; catch (IllegalStateException e) &#123; // application shutdown hooks cannot be added if // shutdown is in progress. hooks = null; &#125; &#125; // 执行用户钩子的钩子函数 static void runHooks() &#123; Collection&lt;Thread&gt; threads; synchronized(ApplicationShutdownHooks.class) &#123; threads = hooks.keySet(); hooks = null; &#125; for (Thread hook : threads) &#123; hook.start(); &#125; for (Thread hook : threads) &#123; while (true) &#123; try &#123; hook.join(); break; &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125;&#125; 简单追踪了一下注册钩子的源码，发现是通过在Shutdown注册一个钩子来执行用户的钩子。那么Shutdown又是怎么在关闭时执行钩子的呢？ 钩子如何被调用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package java.lang;class Shutdown &#123; /* Shutdown state */ private static final int RUNNING = 0; private static final int HOOKS = 1; private static final int FINALIZERS = 2; private static int state = RUNNING; /* Should we run all finalizers upon exit? */ private static boolean runFinalizersOnExit = false; // The system shutdown hooks are registered with a predefined slot. // The list of shutdown hooks is as follows: // (0) Console restore hook // (1) Application hooks // (2) DeleteOnExit hook // 钩子集合容量，有点小，但是看注释目前就3个，倒是足够了，不知道有没有没列出来的 private static final int MAX_SYSTEM_HOOKS = 10; // 钩子集合 private static final Runnable[] hooks = new Runnable[MAX_SYSTEM_HOOKS]; // 注册一个钩子 static void add(int slot, boolean registerShutdownInProgress, Runnable hook) &#123; synchronized (lock) &#123; if (hooks[slot] != null) throw new InternalError(\"Shutdown hook at slot \" + slot + \" already registered\"); if (!registerShutdownInProgress) &#123; if (state &gt; RUNNING) throw new IllegalStateException(\"Shutdown in progress\"); &#125; else &#123; if (state &gt; HOOKS || (state == HOOKS &amp;&amp; slot &lt;= currentRunningHook)) throw new IllegalStateException(\"Shutdown in progress\"); &#125; // 刚才ApplicationShutdownHooks传的是：(1) Application hooks hooks[slot] = hook; &#125; &#125; // 除了add，这是唯一引用hooks的地方了 // 可以看出是顺序执行3种钩子 private static void runHooks() &#123; for (int i=0; i &lt; MAX_SYSTEM_HOOKS; i++) &#123; try &#123; Runnable hook; synchronized (lock) &#123; // acquire the lock to make sure the hook registered during // shutdown is visible here. currentRunningHook = i; hook = hooks[i]; &#125; if (hook != null) hook.run(); &#125; catch(Throwable t) &#123; if (t instanceof ThreadDeath) &#123; ThreadDeath td = (ThreadDeath)t; throw td; &#125; &#125; &#125; &#125; // 执行钩子的地方 private static void sequence() &#123; synchronized (lock) &#123; /* Guard against the possibility of a daemon thread invoking exit * after DestroyJavaVM initiates the shutdown sequence */ if (state != HOOKS) return; &#125; runHooks();//执行钩子 boolean rfoe; synchronized (lock) &#123; state = FINALIZERS; rfoe = runFinalizersOnExit; &#125; if (rfoe) runAllFinalizers(); &#125; // 下面两个方法是我们触发应用关闭的途径，均可执行钩子 /* Invoked by Runtime.exit, which does all the security checks. * Also invoked by handlers for system-provided termination events, * which should pass a nonzero status code. */ // 强行翻译：通过Runtime.exit调用 // 这是我们可以在程序中调用到的 static void exit(int status) &#123; boolean runMoreFinalizers = false; synchronized (lock) &#123; if (status != 0) runFinalizersOnExit = false; switch (state) &#123; case RUNNING: /* Initiate shutdown */ state = HOOKS; break; case HOOKS: /* Stall and halt */ break; case FINALIZERS: if (status != 0) &#123; /* Halt immediately on nonzero status */ halt(status); &#125; else &#123; /* Compatibility with old behavior: * Run more finalizers and then halt */ runMoreFinalizers = runFinalizersOnExit; &#125; break; &#125; &#125; if (runMoreFinalizers) &#123; runAllFinalizers(); halt(status); &#125; synchronized (Shutdown.class) &#123; /* Synchronize on the class object, causing any other thread * that attempts to initiate shutdown to stall indefinitely */ sequence();//执行钩子 halt(status); &#125; &#125; /* Invoked by the JNI DestroyJavaVM procedure when the last non-daemon * thread has finished. Unlike the exit method, this method does not * actually halt the VM. */ // 强行翻译：最后一个非守护线程结束后通过本地接口（JNI）调用。和exit方法不同，此方法没有真正停止虚拟机 // 这个方法没有找到调用的代码 static void shutdown() &#123; synchronized (lock) &#123; switch (state) &#123; case RUNNING: /* Initiate shutdown */ state = HOOKS; break; case HOOKS: /* Stall and then return */ case FINALIZERS: break; &#125; &#125; synchronized (Shutdown.class) &#123; sequence();// 执行钩子 &#125; &#125; 简单的看了下源码，知道了exit和shutdown时都会通过某种流程和规则去执行到用户定义的钩子。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.cn/tags/jvm/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}]},{"title":"JAVA泛型与类型擦除","slug":"java-generics-type-erasure","date":"2019-07-28T14:30:00.000Z","updated":"2019-07-28T16:00:10.665Z","comments":true,"path":"2019/07/28/java-generics-type-erasure/","link":"","permalink":"https://acupt.cn/2019/07/28/java-generics-type-erasure/","excerpt":"","text":"泛型的本质是参数化类型，这种参数类型可以用在类、接口和方法的创建中。泛型是在JAVA 1.5版本中才引入的，它能和以前的版本兼容的原因是泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，即类型擦除。 泛型的定义与使用根据使用情况可以分为以下三种： 泛型类 泛型方法 泛型接口 下面是一个常用的泛型类： 1234567891011121314151617181920212223242526// 一个泛型类，可以根据需要包装不同结果的返回值public class Result&lt;T&gt; &#123; private boolean success; private String message; private T data; // 一个泛型方法 // 返回值类型定义前的&lt;T&gt;是必须的，用来声明一个类型持有者名称，然后就可以把T当作一个类型代表来声明成员、参数和返回值类型。 public static &lt;T&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.success = true; r.data = data; return r; &#125; public static &lt;T&gt; Result&lt;T&gt; error(String message) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.message = message; return r; &#125; // getter &amp; setter&#125; 类型参数上面尖括号中的T即类型参数，代指任何类，使用时可以替换成任意类，如： 12345678public class Main &#123; public static void main(String[] args) &#123; Result&lt;Date&gt; r1 = Result.success(new Date()); Result&lt;List&lt;String&gt;&gt; r2 = Result.success(Arrays.asList(\"s1\", \"s2\")); &#125;&#125; 为什么要用T而不是其它字母？事实上是可以任意字符串（如Result&lt; something &gt;），但是为了显得专业，一般约定几个大写字母在不同场景使用。 T 最常用，一般代指任意类，不知道用啥就用它 E 代表Element，一般用在集合的泛型场景 K 代表Key，一般和Value一起出现在键值对场景（如Entry&lt;K,V&gt;） V 代表Value，一般和Key一起出现在键值对场景（如Entry&lt;K,V&gt;） 还有些不太常见的如S，U… 泛型通配符如果在某些场景下我们不关注（或者不那么关注）泛型对象的类型参数，可以使用泛型通配符。 &lt;?&gt; 无限制的通配符，表示操作和类型无关 &lt;? extends T&gt; 类型参数必须是T或者T的子类 &lt;? super T&gt; 类型参数必须是T或者T的父类 123456789101112131415161718import java.util.Date;public class Main &#123; public static void main(String[] args) &#123; // 由于这里只需要知道方法是否成功，不需要处理返回的对象，所以可以使用通配符，这样就算以后返回值改了这里也不用改 Result&lt;?&gt; r1 = checkDate(); System.out.println(r1.isSuccess() ? \"成功\" : \"失败\"); &#125; private static Result&lt;Date&gt; checkDate() &#123; if (Math.random() &gt; 0.5) &#123; return Result.success(new Date()); &#125; return Result.error(\"system error\"); &#125;&#125; 类型擦除 在Java SE 1.5之前，没有泛型的情况的下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。 12345678910111213141516171819202122232425import java.lang.reflect.Field;import java.util.Date;public class Main &#123; public static void main(String[] args) throws NoSuchFieldException &#123; Result&lt;Date&gt; r1 = Result.success(new Date()); Result&lt;Number&gt; r2 = Result.success(2.333); dataType(r1); dataType(r2); &#125; private static void dataType(Result&lt;?&gt; result) throws NoSuchFieldException &#123; Field field = result.getClass().getDeclaredField(\"data\"); System.out.println(field.getType().toString()); &#125;&#125;/* 输出:class java.lang.Objectclass java.lang.Object*/ 通过反射我们在运行时得到了data的类型，发现都是Object，证明代码编译后所谓泛型都没了，这就是泛型擦除。 但并不是任何时候都是Obejct，如果用了带限制的泛型又将不一样，大概这么个意思： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Result&lt;T extends Number&gt; &#123; private boolean success; private String message; private T data; public static &lt;T extends Number&gt; Result&lt;T&gt; success(T data) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.success = true; r.data = data; return r; &#125; public static &lt;T extends Number&gt; Result&lt;T&gt; error(String message) &#123; Result&lt;T&gt; r = new Result&lt;&gt;(); r.message = message; return r; &#125; // getter &amp; setter&#125;public class Main &#123; public static void main(String[] args) throws NoSuchFieldException &#123; Result&lt;Double&gt; r1 = Result.success(2.333); Result&lt;Long&gt; r2 = Result.success(Long.MAX_VALUE); dataType(r1); dataType(r2); &#125; private static void dataType(Result&lt;?&gt; result) throws NoSuchFieldException &#123; Field field = result.getClass().getDeclaredField(\"data\"); System.out.println(field.getType().toString()); &#125;&#125;/* 输出:class java.lang.Numberclass java.lang.Number*/ 通过反射绕过泛型限制从上面例子可以感受到，所谓泛型，不过是编译过程及其之前才有的概念，主要还是为了方便开发。 最后搞个骚操作，通过反射绕过泛型限制。 12345678910111213141516171819202122232425262728293031import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //正规途径 list.add(1); //反射大法 Method m = list.getClass().getMethod(\"add\", Object.class); m.invoke(list, 2); m.invoke(list, 3.21); m.invoke(list, \"对不起，我是字符串\"); m.invoke(list, new Date()); for (Integer x : list) &#123; System.out.println(x.getClass().getName() + \":\\t\" + x); &#125; &#125;&#125;/* 输出:java.lang.Integer: 1java.lang.Integer: 2Exception in thread \"main\" java.lang.ClassCastException: java.lang.Double cannot be cast to java.lang.Integer at Main.main(Main.java:20)*/ 竟然报错了（当然是故意的，真的），看看错误信息，因为要把Double转为Integer导致异常。但我们发现前面的两个输出是成功的，证明程序能编译成功并运行。 略作调整： 1234567891011121314151617181920212223242526272829303132import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Date;public class Main &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); //正规途径 list.add(1); //反射大法 Method m = list.getClass().getMethod(\"add\", Object.class); m.invoke(list, 2); m.invoke(list, 3.21); m.invoke(list, \"对不起，我是字符串\"); m.invoke(list, new Date()); for (Object x : list) &#123; System.out.println(x.getClass().getName() + \":\\t\" + x); &#125; &#125;&#125;/* 输出:java.lang.Integer: 1java.lang.Integer: 2java.lang.Double: 3.21java.lang.String: 对不起，我是字符串java.util.Date: Sun Jul 28 23:49:34 CST 2019*/ 总结","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}],"tags":[{"name":"泛型","slug":"泛型","permalink":"https://acupt.cn/tags/泛型/"},{"name":"类型擦除","slug":"类型擦除","permalink":"https://acupt.cn/tags/类型擦除/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}]},{"title":"探索JAVA并发 - 如何处理线程中断","slug":"concurrent-interrupt","date":"2019-07-25T14:40:00.000Z","updated":"2019-07-25T16:00:22.032Z","comments":true,"path":"2019/07/25/concurrent-interrupt/","link":"","permalink":"https://acupt.cn/2019/07/25/concurrent-interrupt/","excerpt":"","text":"中断是一种协作机制，通过这种机制可以要求指定线程在可以暂停的地方停止当前任务，但这个要求可以无视，我们也经常这么做（虽然不好），那应该这么对待其它线程发来的中断要求呢？ 在上一篇如何优雅地取消线程任务中提到了通过中断可以取消线程正在进行的任务，现在针对中断这件事情再来简单聊聊。 阻塞库如何抛出中断JAVA中有很多带阻塞方法的工具类，这种方法往往会声明一个受检查的异常InterruptedException，如果被中断，它会尝试提前结束阻塞状态，并抛给调用者一个InterruptedException异常，让对方决定何去何从。 用ArrayBlockingQueue.offer(E, long, TimeUnit)为例。 1234567891011121314151617181920212223242526public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; checkNotNull(e); long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; // 这里可能抛出中断异常： // 获取锁时如果线程已中断 or 等待锁时线程被中断 lock.lockInterruptibly(); try &#123; while (count == items.length) &#123; if (nanos &lt;= 0) return false; // 这里可能抛出中断异常：如果当前线程被中断 nanos = notFull.awaitNanos(nanos); &#125; enqueue(e); return true; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 传递中断如果捕获到一个中断异常不知道怎么处理它，那么可以考虑把这个烫手山芋扔出去，扔给你的上级（调用者），即传递中断。 传递方式1: 不捕获中断异常只要在方法上添加一个InterruptedException的声明，就能轻松把这个锅甩给调用者，因为此时你也成为了可中断大军的一员。既然解决不了，那就加入。 12345678910import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); queue.offer(new Object(), 1L, TimeUnit.MINUTES); &#125;&#125; 传递方式2: 捕获再抛出如果希望发生中断时自己可以做点扫尾操作，那么可以捕获中断异常，做点小动作后再抛出这个异常（你也可以抛出其它自定义异常）。 123456789101112131415import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.TimeUnit;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; ArrayBlockingQueue&lt;Object&gt; queue = new ArrayBlockingQueue&lt;&gt;(100); try &#123; queue.offer(new Object(), 1L, TimeUnit.MINUTES); &#125; catch (InterruptedException e) &#123; System.out.println(\"有人想中断我，我从了\"); throw e; &#125; &#125;&#125; 恢复中断当我们捕获到中断异常的时候，如果再去调用Thread.isInterrupted()往往得到的是false，因为这件事只有一个人来处理就够了，所以抛出异常后会清除中断状态，比如Thread,sleep()。 123456789public class Thread implements Runnable &#123; /** * 强行翻译: 算了不翻译了，上篇写过 * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException; 因此，线程不方便抛出异常的时候（比如在实现Runnable，我们知道run()方法没有声明异常），我们可以捕获到中断异常后再次把线程状态置为中断。这件事我管不了， 谁爱管谁管。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new Thread() &#123; @Override public void run() &#123; while (true) &#123; try &#123; System.out.println(\"可有人想中断我？\" + isInterrupted()); sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(\"有人想中断我，我拒绝\"); System.out.println(isInterrupted()); interrupt(); &#125; &#125; &#125; &#125;; thread.start(); Thread.sleep(3000); thread.interrupt(); &#125;&#125;/* 输出可有人想中断我？false可有人想中断我？false可有人想中断我？false // 虽然下一步就捕获到中断，但这里依然是false，证明是在sleep时才被中断的有人想中断我，我拒绝false // 捕获到异常后，当前线程状态是“非中断”，但被我设为中断了可有人想中断我？true // 因为已经被我设为中断了有人想中断我，我拒绝 // 那人就是你自己啊false // 无限模式启动可有人想中断我？true有人想中断我，我拒绝false(略...)*/ 总结 线程处于中断状态表明有人想让它赶紧结束，但得到这个信号的线程可以做出自己的选择； 不要捕获到它却冷漠的不做任何响应（可以不爱，莫要伤害）。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 如何优雅地取消线程任务","slug":"concurrent-thread-cancel","date":"2019-07-24T14:00:00.000Z","updated":"2019-07-24T16:06:01.840Z","comments":true,"path":"2019/07/24/concurrent-thread-cancel/","link":"","permalink":"https://acupt.cn/2019/07/24/concurrent-thread-cancel/","excerpt":"","text":"通过线程启动一个异步的任务很容易，但想让它提前安全且快速地结束确并不简单。如果线程外部的代码可以提前把目标线程置为“完成”状态，那么这个目标线程就是可取消的。 线程任务取消的原因一般有如下几种： 用户请求取消: 比如用户发起一个耗时操作后，不想等了，就点击了取消按钮，此时我们应该把还在执行的任务叫停； 时间限制: 某些流程可能很费时，我们要控制等待时间，当超时后需要取消掉任务； 程序事件: 某些线程之间可能正在配合完成某项工作，其中一个达到目标后告诉其它同事可以提前下班了； 系统异常: 如果由于依赖的服务或资源发生异常，导致工作干不下去了，那么可以提前取消； 程序关闭: 比如系统要重启，那么还在进行的任务应该取消。 取消标志一种常用的方法是在任务代码中加入一个“是否取消”的标志，任务定期去查看这个标志是否改变，如果被改变了就取消剩下的任务，此时如果想取消这个任务只需要修改它的标志，然后安静地等待其退出即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Worker worker = new Worker(); worker.start(); Thread.sleep(3000); worker.cancel(); &#125; public static class Worker extends Thread &#123; private volatile boolean cancelled; @Override public void run() &#123; while (!cancelled) &#123; System.out.println(\"搬砖五分钟，划水两小时\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; // 注意这里，后面会提到 e.printStackTrace(); &#125; &#125; System.out.println(\"溜了溜了\"); &#125; /** * 取消任务 */ public void cancel() &#123; cancelled = true; &#125; &#125;&#125;/* 输出:搬砖五分钟，划水两小时搬砖五分钟，划水两小时搬砖五分钟，划水两小时溜了溜了*/ 这种方式最为简单，而且非常安全，因为我们可以自己在代码中控制什么时候可以取消（如示例中每次执行一个循环都可以取消）。 缺点：调用取消的方法后线程并不能保证很快就退出，这取决于一个循环的执行速度，更可怕的是，如果里面有个阻塞操作，它可能永远无法退出。 解决：对于阻塞操作设置超时等待，防止永远阻塞。 中断线程中断是一种协作机制，通过这个机制通知某个线程，让它可以在合适的或可能的情况下停止任务。那么什么是合适/可能的情况呢？ 线程有个“interrupted”（被打断/中断）的状态，通过Thread的以下方法可以查看/修改这个状态 12345678910111213141516171819202122232425public class Thread implements Runnable &#123; // 中断目标线程 public void interrupt() &#123; //... &#125; // 返回是否中断 public boolean isInterrupted() &#123; return isInterrupted(false); &#125; // 清除中断状态，并返回在此之前是否中断 // 如果返回true，证明有人想中断这个线程，你需要正式这个问题: // 1.无视这个人的请求 // 2.帮他继续这个请求(再次调用interrupt恢复为中断状态) // 3.其它处理方式 // PS: 注意这是个static方法 public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125; // 返回是否中断，参数为是否清除中断状态 private native boolean isInterrupted(boolean ClearInterrupted);&#125; 调用中断方法 interrupt() 并不会让目标线程立即停止任务，只是传递一个“可以停止”的信息给它。 当线程调用wait、sleep、join等会抛出InterruptedException的方法时，就是可以响应中断信号的时刻（因此这些时刻也被称为取消点） 12345678910111213public class Thread implements Runnable &#123; /** * 学渣强行翻译： * 如果任意线程中断了当前线程就会抛出此异常； * 这个异常抛出后当前线程的“中断”状态会被清空，即捕获异常后再调用isInterrupted()返回false * @throws InterruptedException * if any thread has interrupted the current thread. The * &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is * cleared when this exception is thrown. */ public static native void sleep(long millis) throws InterruptedException;&#125; 因此我们可以在程序中适当使用“取消点”方法，并对中断异常进行处理，回到上面的代码，线程每次输出一句话后都会sleep一秒，针对sleep方法抛出的异常，线程补捕获到后并没有做任何处理，而是把它吃了，现在我要充分利用它。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; Worker worker = new Worker(); worker.start(); Thread.sleep(3000); worker.interrupt(); &#125; public static class Worker extends Thread &#123; private volatile boolean cancelled; @Override public void run() &#123; while (!cancelled) &#123; System.out.println(\"搬砖五分钟，划水两小时\"); try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; System.out.println(\"老板让我提前下班咯\"); break; &#125; &#125; System.out.println(\"溜了溜了\"); &#125; /** * 取消任务 */ public void cancel() &#123; cancelled = true; &#125; &#125;&#125;/* 输出: 搬砖五分钟，划水两小时搬砖五分钟，划水两小时搬砖五分钟，划水两小时老板让我提前下班咯溜了溜了*/ 使用了中断，我们的程序似乎提升了些许逼格，但阻塞操作带来的问题依然没有解决。不过我们还是建议使用中断来取消线程，甚至说通常情况下，中断是实现取消的最合理方式。 为什么这么说，因为很多包含阻塞操作的库函数实现了和中断机制的交互，简单说就是很多阻塞操作本身就会抛出InterruptedException异常。 举个例子，阻塞队列，它的阻塞方法定义了抛出异常InterruptedException，通过注释知道在等待时如果被中断了就会抛出这个异常。 12345678910111213public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; /** * (去掉无关注释) * * Inserts the specified element into this queue, waiting up to the * specified wait time if necessary for space to become available. * * @throws InterruptedException if interrupted while waiting */ boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException;&#125; 让我们善用线程中断机制吧~","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - 同步工具类","slug":"concurrent-sync-tool","date":"2019-07-23T14:00:00.000Z","updated":"2019-07-23T16:36:58.325Z","comments":true,"path":"2019/07/23/concurrent-sync-tool/","link":"","permalink":"https://acupt.cn/2019/07/23/concurrent-sync-tool/","excerpt":"","text":"同步工具类是个笼统的概念，它可以根据自身状态来协调线程的控制流，了解JAVA中常用的同步工具能帮助开发者写出更好的并发代码。 闭锁 CountDownLatch闭锁的作用相当于一扇门，在这扇门没打开前，任何线程执行到这里都会被无情扣押，直到有人打开了这扇门，那些阻塞在门外的线程才会继续进行门后的流程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.CountDownLatch;public class Main &#123; public static void main(String[] args) throws InterruptedException &#123; //第一扇门，需要1次触发即可打开 CountDownLatch firstDoor = new CountDownLatch(1); //第二扇门，需要3次触发才可打开 CountDownLatch lastDoor = new CountDownLatch(3); //启动3个线程 for (int i = 1; i &lt;= 3; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; System.out.println(id + \"号靓仔到达第一扇门前\"); firstDoor.await(); Thread.sleep((long) (Math.random() * 5000));//随机休息一会 System.out.println(id + \"号靓仔到达第二扇门前并触发\"); lastDoor.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; Thread.sleep(1000); //主线程打开第一扇门，让其他线程可以通过 firstDoor.countDown(); //等待其他线程合力打开第二扇门 lastDoor.await(); System.out.println(\"bye~\"); &#125;&#125;/* 输出:1号靓仔到达第一扇门前3号靓仔到达第一扇门前2号靓仔到达第一扇门前1号靓仔到达第二扇门前并触发2号靓仔到达第二扇门前并触发3号靓仔到达第二扇门前并触发bye~*/ 闭锁 FutureTaskFutureTask也可以用作闭锁，常与线程池一起使用，提交到线程池后，主线程（提交任务的线程）调用get()方法阻塞线程直到异步任务执行完毕或超时。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.concurrent.Callable;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 方式1：传入一个Callable，即业务代码执行完直接return FutureTask&lt;Liangzai&gt; callableTask = new FutureTask&lt;&gt;(new Callable&lt;Liangzai&gt;() &#123; @Override public Liangzai call() throws Exception &#123; Thread.sleep(1000); Liangzai liangzai = new Liangzai(); liangzai.name = \"callable\"; return liangzai; &#125; &#125;); // 方式2：传入一个runnable和一个存储结果的对象，在runnable中修改结果对象 Liangzai runableLiangzai = new Liangzai(); FutureTask&lt;Liangzai&gt; runableTask = new FutureTask&lt;&gt;(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); runableLiangzai.name = \"runable\"; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;, runableLiangzai); // 异步给靓仔取名 new Thread(callableTask).start(); // 等待名字确定完毕 Liangzai liangzai = callableTask.get(); System.out.println(liangzai); // 异步给靓仔取名 new Thread(runableTask).start(); // 等待名字确定完毕 liangzai = runableTask.get(); System.out.println(liangzai); &#125; public static class Liangzai &#123; String name; @Override public String toString() &#123; return \"Liangzai&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125; &#125;&#125;/* 输出:Liangzai&#123;name='callable'&#125;Liangzai&#123;name='runable'&#125;*/ 信号量 Semaphore信号量用来控制同时“访问资源”或“执行操作”的线程数量，也可以用来实现资源池等。它管理着一组虚拟的“许可”，每当线程想访问某个特殊资源，需要先向它申请一个许可，用完后再返还许可，许可不足时将阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 初始化2个许可 Semaphore semaphore = new Semaphore(2); // 不想用线程池，用这个实现主线程等待所有子线程执行完毕 int n = 10; CountDownLatch countDownLatch = new CountDownLatch(n); for (int i = 1; i &lt;= n; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; // 申请一个许可 System.out.println(id + \"号想要1个许可\"); semaphore.acquire(); System.out.println(id + \"号得到1个许可\"); // 持有许可一段时间 Thread.sleep((long) (Math.random() * 10000)); // 归还许可 semaphore.release(); System.out.println(id + \"号归还1个许可\"); // 此线程完毕 countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:1号想要1个许可2号想要1个许可1号得到1个许可2号得到1个许可3号想要1个许可4号想要1个许可5号想要1个许可6号想要1个许可7号想要1个许可8号想要1个许可9号想要1个许可10号想要1个许可2号归还1个许可3号得到1个许可1号归还1个许可4号得到1个许可3号归还1个许可5号得到1个许可4号归还1个许可6号得到1个许可5号归还1个许可7号得到1个许可6号归还1个许可8号得到1个许可7号归还1个许可9号得到1个许可9号归还1个许可10号得到1个许可10号归还1个许可8号归还1个许可done~*/ 上面的代码，由于只有两个许可，所有前两个线程一说想要马上就得到了，第三个开始就开始了不算漫长的等待，下一次有线程得到许可是在有一个线程归还许可之后。 栅栏 CyclicBarrierCyclicBarrier类似于CountDownLatch，也是阻塞一组线程直到某个时间点，区别如下。 闭锁 CountDownLatch：等待一组线程全部完成某个任务，然后等待线程继续执行后续动作。结束后状态不会再改变 栅栏 CyclicBarrier：等待一组线程全部到达某个位置，然后该组线程继续执行后续动作，该组线程互相等待。状态可以重置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; // 定义一个栅栏，等待3个人到达后一起嗨皮 int n = 3; CyclicBarrier barrier = new CyclicBarrier(n, new Runnable() &#123; @Override public void run() &#123; // 全部人就绪后执行的操作 System.out.println(\"大家都到齐了，开始happy去\"); &#125; &#125;); // 不想用线程池，用这个实现主线程等待所有子线程执行完毕 CountDownLatch countDownLatch = new CountDownLatch(n); for (int i = 1; i &lt;= n; i++) &#123; int id = i; new Thread(() -&gt; &#123; try &#123; // 每个人出门打扮需要的时间都是不同的 Thread.sleep((long) (Math.random() * 5000)); // 等待其他人到达这里 System.out.println(id + \": 我到地方了\"); barrier.await(); System.out.println(id + \": let's go\"); // 此线程完毕 countDownLatch.countDown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;).start(); &#125; countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:3: 我到地方了2: 我到地方了1: 我到地方了大家都到齐了，开始happy去1: let's go3: let's go2: let's godone~*/ 栅栏 ExchangerExchanger是一种两方的栅栏，用于两方之间交换数据，一方发出消息后会阻塞直到对方接受到消息并返回一个消息，达到一人一句的和谐交流。当两方的操作不对称时很有用，比如一个线程往缓冲区写数据，一个线程从缓冲区读数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.*;public class Main &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; Exchanger&lt;String&gt; exchanger = new Exchanger&lt;&gt;(); CountDownLatch countDownLatch = new CountDownLatch(2); new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep((long) (Math.random() * 5000)); String fromKun = exchanger.exchange(\"我是小菜，No.\" + i); System.out.println(\"小菜收到消息：\" + fromKun); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;).start(); new Thread(() -&gt; &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep((long) (Math.random() * 5000)); String fromKun = exchanger.exchange(\"我是阿坤，No.\" + i); System.out.println(\"阿坤收到消息：\" + fromKun); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; countDownLatch.countDown(); &#125;).start(); countDownLatch.await(); System.out.println(\"done~\"); &#125;&#125;/* 输出:小菜收到消息：我是阿坤，No.0阿坤收到消息：我是小菜，No.0阿坤收到消息：我是小菜，No.1小菜收到消息：我是阿坤，No.1阿坤收到消息：我是小菜，No.2小菜收到消息：我是阿坤，No.2小菜收到消息：我是阿坤，No.3阿坤收到消息：我是小菜，No.3阿坤收到消息：我是小菜，No.4小菜收到消息：我是阿坤，No.4done~*/ 总结所谓同步工具类并不特指实现某种功能的类，它们主要的价值就在于能帮助多线程之间更好地相互配合完成工作，只要对自己的需求清晰，对JAVA自带的类熟悉，就能选择合适的同步工具类，甚至实现自己需要的同步工具类。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"},{"name":"并发","slug":"并发","permalink":"https://acupt.cn/tags/并发/"},{"name":"同步","slug":"同步","permalink":"https://acupt.cn/tags/同步/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"探索JAVA并发 - ThreadLocal","slug":"concurrent_threadlocal","date":"2019-07-22T14:00:00.000Z","updated":"2019-07-22T16:30:10.048Z","comments":true,"path":"2019/07/22/concurrent_threadlocal/","link":"","permalink":"https://acupt.cn/2019/07/22/concurrent_threadlocal/","excerpt":"","text":"使用ThreadLocal可以维持线程封闭性，使线程中的某个值与保存值的对象关联，防止对可变的单例变量或全局变量进行共享，但使用不当也会造成内存泄漏，先了解它，再使用它​。​ 从SimpleDateFormat说起SimpleDateFormat是我们常用的日期格式化工具，但熟悉的朋友都知道它是线程不安全的。 SimpleDateFormat用法1234567public class Acuptest &#123; public static void main(String[] args) &#123; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); System.out.println(sdf.format(new Date())); &#125;&#125; SimpleDateFormat线程不安全场景上面的用法完全没有问题，但现在spring无处不在，很多类都是以bean的形式存在于spring容器被各种共享，一不小心就会写成下面这种样子。 12345678public class Acuptest &#123; private SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); public String format(Date date) &#123; return sdf.format(date); &#125;&#125; 只是这样还看不出什么问题，但既然提到了SimpleDateFormat是线程不安全的，那么就看看为什么不安全。 SimpleDateFormat线程不安全分析进入源码，只看关键部分。 1234567891011121314151617181920212223242526272829303132333435public abstract class DateFormat extends Format &#123; // 一个成员变量 protected Calendar calendar; // 一个抽象方法 public abstract StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); // 提供给外部使用的方法 public final String format(Date date)&#123; return format(date, new StringBuffer(), DontCareFieldPosition.INSTANCE).toString(); &#125;&#125;public class SimpleDateFormat extends DateFormat &#123; // 实现了父类的抽象方法 @Override public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos)&#123; pos.beginIndex = pos.endIndex = 0; return format(date, toAppendTo, pos.getFieldDelegate()); &#125; private StringBuffer format(Date date, StringBuffer toAppendTo, FieldDelegate delegate) &#123; // 到这里就能发现问题了，竟然给成员变量设置成了传进来的参数 // 在并发情况下calendar的值就不可信了，可能线程A前脚刚设置完准备执行下一条语句，线程B紧随其后就把值给改了 // Convert input date to time field list calendar.setTime(date); boolean useDateFormatSymbols = useDateFormatSymbols(); // 略 &#125;&#125; SimpleDateFormat线程安全用法使用局部变量只要不让多线程访问同一个对象，每次要用就new一个对象即可。 使用ThreadLocal很多时候某些对象往往不适合频繁创建、销毁，但它又像SimpleDateFormat那样线程不安全。这时候ThreadLocal就有用武之地了。 1234567891011121314public class Acuptest &#123; // 为每个线程单独分配一个SimpleDateFormat，线程内部可以复用，线程之间不能共享。 private ThreadLocal&lt;SimpleDateFormat&gt; sdf = new ThreadLocal&lt;SimpleDateFormat&gt;() &#123; @Override protected SimpleDateFormat initialValue() &#123; // get()方法获取不到当前线程的SimpleDateFormat对象时，会调用此方法创建一个并绑定到线程 return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss,SSS\"); &#125; &#125;; public String format(Date date) &#123; return sdf.get().format(date); &#125; ThreadLocal源码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class ThreadLocal&lt;T&gt; &#123; //... // 获取当前线程绑定的对象，如果没有，将调用initialValue生成一个并绑定 public T get() &#123; // 获取当前线程 Thread t = Thread.currentThread(); // 从当前线程中取到一个MAP // key: ThreadLocal // value: ThreadLocal的泛型 &lt;T&gt; ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; // Thread对象可能还没创建ThreadLocalMap成员变量 // 或者ThreadLocalMap里没有当前ThreadLocal对象对应的&lt;T&gt;值 // 此时需要设置初始值 return setInitialValue(); &#125; // 获取线程里的MAP ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; // 设置初始值 private T setInitialValue() &#123; // 创建一个新的对象 T value = initialValue(); // 重新获取当前线程，因为没有参数接收线程信息 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); // 设置初始值 else createMap(t, value); // 创建MAP并设置初始值 return value; &#125; // 初始化一个对象，默认返回null，可在使用时重写此方法 protected T initialValue() &#123; return null; &#125; // ...&#125; Thread源码分析上面的源码中看到ThreadLocal多次使用Thread中的成员变量threadLocals，于是对Thread对象的结构再做个简单了解。 123456789101112131415161718192021222324252627282930313233343536public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; // 略&#125;public class ThreadLocal&lt;T&gt; &#123; static class ThreadLocalMap &#123; static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; &#125;&#125; threadLocals和inheritableThreadLocals从Thread源码中可以看到ThreadLocal.ThreadLocalMa类型的成员变量有两个，有个是之前没有见过的inheritableThreadLocals，这个变量不是给ThreadLocal用的，而是给另一个类似的工具InheritableThreadLocal用的。 1234567891011121314public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123; protected T childValue(T parentValue) &#123; return parentValue; &#125; ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals; &#125; void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue); &#125;&#125; 从源码上看，InheritableThreadLocal继承了ThreadLocal，然后使用的MAP换了，其他就没什么特别的。 但InheritableThreadLocal有着特殊的功能：它可以使用父线程的inheritableThreadLocals变量，实现父子线程共享变量。 InheritableThreadLocal为什么可以让子线程使用父线程的变量，关键的地方不在它，而在Thread类的初始化流程，Thread初始化时， 123456789101112131415161718public class Thread implements Runnable &#123; private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; // 略 Thread parent = currentThread(); // 略 // inheritThreadLocals默认为true // 父线程inheritableThreadLocals不为空则复制一份 // 值复制，非引用复制 // 只是复制父线程当前拥有的对象 if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); // 略 &#125;&#125; ThreadLocal中的弱引用(WeakReference)从上面的源码中注意到: ThreadLocal.ThreadLocalMap.Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; Entry的key是ThreadLocal&lt;?&gt;，是个弱引用（被GC扫描到就回收）。如果不这样，当ThreadLocal&lt;?&gt;用完了，但线程还没结束，因此Thread里面还持有着ThreadLocal&lt;?&gt;的强引用，那么它永远不会被回收，可以认为内存泄漏了。 ThreadLocal的内存泄漏就算是使用了弱引用，依然存在内存泄漏的可能。因为弱引用仅仅是Entry的key(ThreadLocal)，value（泛型T）并不是弱引用。最终可能出现的结果就是，ThreadLocal被回收了，Thread里的MAP中KEY就没了，但value还在，这样一来这个value永远不会被get()方法返回，确又存在于内存不愿消散。 内部实现尽量避免内存泄漏： 在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。 如果没有调用这些方法去触发这个过程，依然会内存泄漏，所以在线程用完这个对象后，可以显示调用remove方法使其清除。","categories":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}],"tags":[{"name":"线程","slug":"线程","permalink":"https://acupt.cn/tags/线程/"},{"name":"并发","slug":"并发","permalink":"https://acupt.cn/tags/并发/"}],"keywords":[{"name":"并发编程","slug":"并发编程","permalink":"https://acupt.cn/categories/并发编程/"}]},{"title":"死锁的四大条件与处理策略","slug":"deadlock","date":"2019-07-21T14:40:00.000Z","updated":"2019-07-21T15:33:08.997Z","comments":true,"path":"2019/07/21/deadlock/","link":"","permalink":"https://acupt.cn/2019/07/21/deadlock/","excerpt":"","text":"死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 比如：两个线程A、B各自持有一个无法共享的资源，并且他们都需要获取对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取，于是A等待B，B也在等待A。如此这般，死锁就产生了。 产生死锁的四个条件死锁的发生必须具备以下四个必要条件 互斥条件（Mutual exclusion）资源不能被共享，只能由一个进程使用。 请求与保持条件（Hold and wait）已经得到资源的进程可以再次申请新的资源。 不可剥夺条件（No pre-emption）已经分配的资源不能从相应的进程中被强制地剥夺。 环路/循环等待条件（Circular wait）系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。 了解四个必要条件后再来看看开始的例子： 两个线程各自持有一个无法共享(互斥条件)的资源，并且他们都需要获取（请求与保持条件）对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取(不可剥夺条件)，于是A等待B，B也在等待A（环路等待条件）。如此这般，死锁就产生了。 预防死锁通过破坏四个必要条件中的一个或多个，使死锁永远无法满足。实现简单，但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。 预先资源分配法一次性申请所有需要的资源，只要有一种资源不满足要求，哪怕其它需要的资源都足够，也不做任何分配。这样一来就没有“保持”资源的状态，只有“请求”资源的状态，破坏了请求与保持条件。 有序资源分配法在申请不同类资源时，必须按指定顺序申请，破坏了环路等待条件。 正例：线程A、B申请资源顺序均为R1-&gt;R2； 反例：A申请顺序为R1-&gt;R2，B申请顺序为R2-&gt;R1。 避免死锁也是预发死锁，但不会事先去破坏死锁的必要条件，只是有人请求资源时，用某种方法防止系统进入不安全的状态（死锁），从而避免发生死锁。 银行家算法基本思想是分配资源之前，判断系统是否是安全的；若是，才分配。 检测死锁和解除不采取措施防止死锁产生，允许系统产生死锁，但是可以通过一些手段检测出死锁，然后将死锁解除。 检测方法： 定时检测 效率低时检测 进程等待时检测 解除死锁方法： 根据具体业务场景，可以撤销或挂起死锁的进程/线程，使资源释放。","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}],"tags":[{"name":"死锁","slug":"死锁","permalink":"https://acupt.cn/tags/死锁/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}]},{"title":"JAVA中的String真的不可变吗","slug":"java-string","date":"2019-07-17T15:00:00.000Z","updated":"2019-07-18T16:19:15.719Z","comments":true,"path":"2019/07/17/java-string/","link":"","permalink":"https://acupt.cn/2019/07/17/java-string/","excerpt":"","text":"String是不可变的吗？是的！真想变？也行~ 我们都知道，String是不可变对象，即一旦创建，那么就不能改变它的状态。对此，我们来分析一波。 String的内部构造小心翼翼进入String的内部，我们可以看到它是一个final类，那么没人能继承它，很好，很丁克。 然后直接看向它的灵魂，一个char数组，也是final，于是我们知道它怎么不可变了。 1234567891011121314public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; // 略...&#125; 创建对象直接用常量给String变量赋值，不管在几个地方，几次，它们都是用的同一个数据。 除非new一个新的String。 123456789101112public class StringTest &#123; public static void main(String[] args) &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 123两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 利用反射修改值上面的代码后面再加点东西，尝试修改s1的值。 123456789101112131415161718192021222324252627282930313233public class StringTest &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); // 通过反射得到被String藏起来的value字段 Field f = String.class.getDeclaredField(\"value\"); // 让它敞开心扉 f.setAccessible(true); // 获取s1的内部value数组 char[] v = (char[]) f.get(s1); // 改掉它第一个字母 v[0] = 'x'; System.out.println(\"改变过后...\"); System.out.println(\"s1 = \" + s1); System.out.println(\"s2 = \" + s2); System.out.println(\"s3 = \" + s3); System.out.println(\"s4 = \" + s4); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 1234567891011两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false改变过后...s1 = xbcds2 = xbcds3 = xbcds4 = xbcd两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 总结1、String内部的value通过反射真的可以改变2、直接改动value会导致其它相同值的String对象也被改变（所以可以猜测底层实际上用的同一份数据？）3、虽然值都改变了，但作为对象，4个变量的关系依然没有改变（new的两个String和其他两个依然不等）4、这样做很危险5、这样做很无聊","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://acupt.cn/tags/java/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.cn/categories/JAVA/"}]},{"title":"CPU占用高如何排查","slug":"interview-cup-thread","date":"2019-07-17T14:30:00.000Z","updated":"2019-07-17T14:59:39.306Z","comments":true,"path":"2019/07/17/interview-cup-thread/","link":"","permalink":"https://acupt.cn/2019/07/17/interview-cup-thread/","excerpt":"","text":"程序里少不了运算，如果不是环境太恶劣，CPU基本是能支撑应用运行的。但如果发现CPU居高不下，就需要思考是否程序有问题。 当服务器CPU居高不下，可以从下面几个方面入手定位问题。 找到JAVA进程 pid方法一: jps那个jar就是我的一个java程序 123456[root@iZba13i1mo82ot7a3lhq5oZ ~]# jps17616 Jps26016 jar9353 Bootstrap26028 Bootstrap16812 Bootstrap 方法二: ps -ef|grep 应用关键词和方法一找到的pid是相同的，26016 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -ef|grep acupjavaroot 17638 17550 0 22:34 pts/0 00:00:00 grep --color=auto acupjavaroot 26016 1 0 7月08 ? 00:05:11 java -jar acupjava-1.0-SNAPSHOT.jar 找到进程中CPU高的线程 tid打印出线程线程基本信息，找到cpu百分比高的一个或几个线程，记住它们的tid。 PS：栗子质量不好，全是0.0%，不要在意~ 123456789[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -mp 26016 -o THREAD,tid,timeUSER %CPU PRI SCNT WCHAN USER SYSTEM TID TIMEroot 0.0 - - - - - - 00:05:11root 0.0 19 - futex_ - - 26016 00:00:00root 0.0 19 - futex_ - - 26017 00:00:02root 0.0 19 - futex_ - - 26018 00:00:00root 0.0 19 - futex_ - - 26019 00:00:00root 0.0 19 - futex_ - - 26020 00:00:11(略...) 打印线程栈选择一个线程，把tid从10进制转为16进制 12[root@iZba13i1mo82ot7a3lhq5oZ ~]# printf \"%x\\n\" 2601765a1 为了方便查看可以把线程栈打印到文件里，jstack pid &gt;&gt; 文件名 使用ls查看文件已经存在 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# jstack 26016 &gt;&gt; stack.txt[root@iZba13i1mo82ot7a3lhq5oZ ~]# lstest stack.txt 找到占用CPU高的线程打开文件，搜索tid所在位置，可以看到线程栈，由此分析定位可能有问题的代码。 12345\"http-nio-9527-AsyncTimeout\" #29 daemon prio=5 os_prio=0 tid=0x00007fbf68973800 nid=0x65a1 waiting on condition [0x00007fbf48ab0000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1200) at java.lang.Thread.run(Thread.java:748) 如此这般，CPU高的问题基本就能定位出来了。（PS: 以上数据做了些许脱敏处理）","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"https://acupt.cn/tags/cpu/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}]},{"title":"内存泄漏如何排查","slug":"interview-oom-check","date":"2019-07-16T13:45:00.000Z","updated":"2019-07-16T15:00:32.013Z","comments":true,"path":"2019/07/16/interview-oom-check/","link":"","permalink":"https://acupt.cn/2019/07/16/interview-oom-check/","excerpt":"","text":"JAVA的垃圾回收机制给了程序猿便利，我们可以不需要显式释放资源。但想高枕无忧却是不能，OOM像个隐藏在暗处的幽(hua)灵(nong)，威胁着可怜、弱小又漂亮的程序猿。 一般来说，一个健康的程序，它是不应该出现OOM的。内存里的对象从生到死，井然有序。但由于一些人为的失误，往往会让一些对象逃过GC的制裁，跳出GC外，不在垃圾中。这个时候，内存泄漏就发生了。 内存泄露，是指程序在申请内存并且用完这块内存后（对象不再需要了），没有释放已申请的内存空间。少数偶然的内存泄漏，虽然不太好，但问题不大，我们也不至于对那点内存抠抠搜搜的。但如果是内存不断泄漏，直到新的对象没有足够的空间生成，就会导致OOM。 什么时候可能内存泄漏抛出OOM异常当程序抛出OutOfMemoryError，如果你自认不是太抠，给了这个程序足够的空间，那么可以怀疑有内存泄漏 内存持续上升一个健康的程序应该有平稳的新陈代谢，内存占用应该维持在一定范围。但如果内存持续飙升，甚至到达了一个危险的值，那么可以怀疑有内存泄漏。 查看GC情况首先获取到应用的pid，可以使用java的jps命令，或者ps -ef|grep 应用名关键词 1234567891011121314151617/** * 启动个应用，持续造对象 */public class AcuptMain &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;Liangzai&gt; liangzais = new ArrayList&lt;&gt;(); while (true) &#123; liangzais.add(new Liangzai()); Thread.sleep(1000); &#125; &#125; private static class Liangzai &#123; byte[] body = new byte[1024 * 1024]; &#125;&#125; 1234567// 执行命令jps查看java进程➜ ~ jps11617 Launcher11618 AcuptMain1353 RemoteMavenServer1322 11627 Jps 123// 根据关键词查看，进程id为 11618 ，和jps查到的一致➜ ~ ps -ef|grep acupt 501 11618 1322 0 10:44下午 ?? 0:00.39 /Library/Java/JavaVirtualMachines... 123456789101112131415# 查看gc总体情况，各个区的使用率变化，3秒更新一次➜ ~ jstat -gcutil 11618 3000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 56.20 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 60.89 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 65.58 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 70.26 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 74.95 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 79.64 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 84.33 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 89.01 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 93.70 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 98.39 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 98.48 5.02 26.91 79.14 82.73 1 0.021 0 0.000 0.021 (以下略...) 可以看到Eden(E)持续造对象，并且满了之后，老年代(O)增加，E区腾空后继续造对象。（程序多执行一段时间，或者造对象速度提快点，最终会抛出OOM） 查看存活对象1234567891011121314// 查看存活对象，可以看到排名第一的是byte数组，而且多观察会会发现其数量也是一直在增加➜ ~ jmap -histo:live 11618 num #instances #bytes class name---------------------------------------------- 1: 644 103949616 [B 2: 4342 416736 [C 3: 4326 103824 java.lang.String 4: 721 82056 java.lang.Class 5: 746 49224 [Ljava.lang.Object; 6: 738 29520 java.util.LinkedHashMap$Entry 7: 609 19488 java.util.HashMap$Node 8: 303 19392 java.net.URL 9: 303 13560 [Ljava.lang.String; 根据存活对象的不正常增长情况，分析程序中哪些地方用到了这种对象，也可以大致推断出可能的内存泄漏处。","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.cn/tags/jvm/"},{"name":"oom","slug":"oom","permalink":"https://acupt.cn/tags/oom/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}]},{"title":"JAVA GC 简析","slug":"interview-gc","date":"2019-07-15T15:00:00.000Z","updated":"2019-07-16T13:47:33.758Z","comments":true,"path":"2019/07/15/interview-gc/","link":"","permalink":"https://acupt.cn/2019/07/15/interview-gc/","excerpt":"","text":"作为一个落魄的JAVA开发，在面试中常被问道：你是什么垃圾？哦不，是你对JAVA的垃圾回收机制有了解吗？ 接下来就对GC做一个全方位的总结，希望下次可以自信地回答面试官：我是可以被贵公司回收的那种。 GC的时机首先，根据内存区域不同，JVM工作模式不同，GC也有一些差别。 新生代（minor GC/young GC） PS: 新生代的内存空间可分为3个，Eden区(产生新生命的伊甸园)，from区和to区（GC时倒腾对象用的两个盘子） 当JVM无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以如果程序疯狂造对象，就会频繁触发GC。 老年代/永久代（major GC）/整个堆（full GC） 当一个对象经历了太多GC而不死，它会突破旧规则的束缚，飞升到老年代/永久代，成为新的存在，但并不代表着它可以不死，没有谁可以不死，尤其是新的地方也缺少资源的时候。而Major GC通常是跟full GC是等价的，收集整个GC堆。 升到永久代的对象大于永久代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc。 其它GC时机： 在程序中调用System.gc()函数，建议JVM做GC（注意只是建议，JVM有权无视程序猿的建议） 调参控制进入老年代/永久代的年龄（如果我记得肯定会写出来的，没搜，懒得搜） OOM之前（在放弃治疗抛出异常前总要做最后的努力吧） GC的目标 - 不使用的对象 当然是不使用的对象，还在使用的对象给回收了谁知道程序会跑成什么样子 那么什么是不使用的对象呢？ 超出作用域的对象/引用计数为空 引用计数法: 有人引用+1，被人抛弃-1。 优点：一旦没有引用即可释放内存，不需要等待特定时机，回收的时机也比较平均。 缺点：维护计数消耗资源（但问题不大），循环引用（大） 可达性分析，有gc root无法到达的对象 通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，无法到达的对象就是没用的。可以被当做root的对象，如：线程对象、本地变量、全局变量等。 这里又引入了引用的概念，强度从强到弱依次如下： 强引用：最常见的如 Object a = new Object()，即使OOM也不回收 软引用（SoftReference）：内存不够时回收 弱引用（WeakReference）：正常gc，被扫描到就回收 幻想引用（PhantomReference）：不可以获取/复活对象, 在垃圾回收时得到通知 GC的行为简单的说就是删除对象，回收空间。根据算法不同，具体的行为也有所不同，快没电了，就不写了（主要也没准备） 举个栗子： 1、停止其他线程，标记对象2、清理对象2.1、新生代-复制清理： Eden和from的存活对象复制到to，然后from和to交换，存活对象年龄+1，年龄到达阈值进入老年代/永久代2.2、老年代-标记清理/整理： 标记清理速度快，但有内存碎片 标记整理会移动存活对象，排除内存碎片","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.cn/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"https://acupt.cn/tags/gc/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.cn/categories/面试杂谈/"}]},{"title":"从0.5到1写个rpc框架 - 7:网关支持(gateway)","slug":"acuprpc-7","date":"2019-07-13T08:15:00.000Z","updated":"2019-08-06T16:25:10.551Z","comments":true,"path":"2019/07/13/acuprpc-7/","link":"","permalink":"https://acupt.cn/2019/07/13/acuprpc-7/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 微服务除了在内部相互调用，有时某些服务也会提供给外部应用。当然不能让外部应用也加入到“大家庭”里，毕竟知人知面不知源码，我们可以派出一个“前台”去接待它们，这就是“网关”。 网关负责对接外部来宾，因此要做好安全措施，什么登陆、权限该上就上。 流程如下： 网关收到请求 解析请求（服务名，方法，参数等） 选择一个实例（来自注册中心） RPC调用 结果返回给请求方 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api\")public class ApiController &#123; /** * 动态调用rpc服务的关键，在acuprpc-spring-boot-starter中已经生成，可以随时引用 */ private RpcClientManager rpcClientManager; public ApiController(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @RequestMapping(method = RequestMethod.POST, produces = \"application/json\") public Object invoke(@RequestBody RpcRequestDTO requestDTO) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(requestDTO.getApp(), requestDTO.getService()); RpcClient client = rpcClientManager.lookup(serviceInfo);//获取一个可以提供所需服务的连接 RpcRequest request = new RpcRequest(requestDTO.getApp(), requestDTO.getService(), requestDTO.getMethod()); if (requestDTO.getParameters() != null) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); requestDTO.getParameters().forEach((k, v) -&gt; map.put(k, JsonUtil.toJson(v))); request.setNamedParameter(map); &#125; return client.invoke(request);//调用服务获得返回的json字符串 &#125;&#125; 这个demo作为一个子模块（acuprpc-spring-boot-starter-gateway）加入了框架的全家桶，直接引入依赖就能使用这个功能。 基于这个方法，可以实现更加复杂的也无需求，这里就不细讲了，本系列结束。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.cn/tags/eureka/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 6:调用异常节点自动重试","slug":"acuprpc-6","date":"2019-07-13T07:00:00.000Z","updated":"2019-08-06T16:25:08.011Z","comments":true,"path":"2019/07/13/acuprpc-6/","link":"","permalink":"https://acupt.cn/2019/07/13/acuprpc-6/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc eureka client每隔30s向注册中心发送心跳来给自己续命，当注册中心长时间没收到client的信号，就会认为它挂掉了，把它提出群聊。再加上其它服务也按照一定频率更新本地缓存，因此往往不会那么及时地发现曾经的小伙伴已经下线了。导致的后果就是，会向不再存在的节点发送请求，结果连接异常。 对此，我们可以从框架层面加入一个重试机制，spring里面类似的机制也有，但既然在写自己的框架，那就自己实现一个。 在第一章里已经实现了通过动态代理执行远程调用，那么直接从这里入手，通过判断捕获的异常来判断是否需要重试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public Object invoke(Object proxy, Method method, Object[] args) &#123; if (\"toString\".equals(method.getName()) &amp;&amp; (args == null || args.length == 0)) &#123; return rpcServiceInfo.toString();//debug时老是被ide调用然后抛异常，很烦 &#125; RpcRequest rpcRequest = new RpcRequest(rpcServiceInfo.getAppName(), rpcServiceInfo.getServiceName(), method.getName()); if (args != null &amp;&amp; args.length &gt; 0) &#123; rpcRequest.setOrderedParameter(Arrays.stream(args).map(JsonUtil::toJson).collect(Collectors.toList())); &#125; int n = 3; // 最多重试3次，改成可配置的更好 int i = 0; RpcClient client = null; while (i++ &lt; n) &#123; try &#123; client = getRpcClient(); String res = client.invoke(rpcRequest); return JsonUtil.fromJson(res, TypeFactory.defaultInstance().constructType(method.getGenericReturnType())); &#125; catch (Exception e) &#123; if (client == null) &#123; throw e; &#125; boolean rediscover = needRediscover(e) &amp;&amp; i &lt; n; log.error(\"invoke &#123;&#125;/&#123;&#125; &#123;&#125; &#123;&#125; error=&#123;&#125; msg=&#123;&#125; rediscover=&#123;&#125;\", i, n, rpcRequest.getKey(), client.getNodeInfo(), e.getClass().getName(), e.getMessage(), rediscover); if (rediscover) &#123; try &#123; NodeInfo nodeInfo = rpcClientManager.selectNode(rpcServiceInfo, client.getNodeInfo()); client.reconnect(nodeInfo); continue; &#125; catch (RpcNotFoundException e1) &#123; e.addSuppressed(e1); &#125; &#125; throw e; &#125; &#125; throw new RuntimeException(\"invoke error\"); &#125; /** * 根据异常类型判断是否需要换个实例 */ private boolean needRediscover(Throwable e) &#123; while (e != null) &#123; if (e instanceof HttpStatusException) &#123; // 我自定义的异常类型，这里如果是服务不可用（程序虽然正常但不再提供服务） if (((HttpStatusException) e).getStatus() == NOT_AVAILABLE) &#123; return true; &#125; &#125; else if (e instanceof ConnectException) &#123; // 连接异常，想必是不在了 return true; &#125; e = e.getCause(); &#125; return false; &#125; 有了重试机制，就不怕某些家伙突然掉链子了，当然如果全部掉链子那就没得玩了。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.cn/tags/eureka/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 5:服务监控和管理(actuator)","slug":"acuprpc-5","date":"2018-11-29T06:00:00.000Z","updated":"2019-08-06T16:25:05.513Z","comments":true,"path":"2018/11/29/acuprpc-5/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-5/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc springboot项目中只要引入spring-boot-starter-actuator就可以得到一些管理服务的接口，比如停止服务，获取服务信息等。他用的并不是controller，而是Endpoint，不过主要功能差不多。 借住上节实现的filter机制，可以在不改动框架核心代码的基础上实现这个功能。作为实践写两个功能：获取服务端的统计数据、服务状态控制 新建模块 acuprpc-spring-boot-starter-actuator。 为了统一管理这个框架的endpoint，定义一个父类。所有子类的id默认加上“rpc”前缀 12345678910111213public abstract class AbstractRpcEndpoint&lt;T&gt; extends AbstractEndpoint&lt;T&gt; &#123; private static final String PREFIX = \"rpc\"; public AbstractRpcEndpoint(String id) &#123; super(PREFIX + id); &#125; public AbstractRpcEndpoint(String id, boolean sensitive) &#123; super(PREFIX + id, sensitive); &#125; public AbstractRpcEndpoint(String id, boolean sensitive, boolean enabled) &#123; super(PREFIX + id, sensitive, enabled); &#125;&#125; 数据统计MonitorFilter使用filter拦截请求，统计处理请求的数量。 12345678910111213141516171819202122232425262728293031323334@Getterpublic class MonitorFilter implements RpcFilter &#123; private Map&lt;String, RequestCount&gt; requestCountMap = new ConcurrentHashMap&lt;&gt;(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; RequestCount count = requestCountMap.computeIfAbsent(request.getKey(), RequestCount::new); count.received.increment(); count.invoking.increment(); try &#123; filterChain.doFilter(request, response); count.success.increment(); &#125; catch (Exception e) &#123; count.failed.increment(); throw e; &#125; finally &#123; count.invoking.decrement(); &#125; &#125; @Getter public static class RequestCount &#123; private String key; private LongAdder received = new LongAdder();//已接收 private LongAdder invoking = new LongAdder();//执行中 private LongAdder success = new LongAdder();//处理成功 private LongAdder failed = new LongAdder();//处理失败 public RequestCount(String key) &#123; this.key = key; &#125; &#125;&#125; RpcStatEndpoint提供http接口，通过 /rpcstat 即可获取invoke()的返回值。 1234567891011121314151617public class RpcStatEndpoint extends AbstractRpcEndpoint&lt;Map&lt;String, Object&gt;&gt; &#123; private MonitorFilter filter; public RpcStatEndpoint(MonitorFilter filter) &#123; super(\"stat\"); this.filter = filter; &#125; @Override public Map&lt;String, Object&gt; invoke() &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); Collection&lt;MonitorFilter.RequestCount&gt; counts = filter.getRequestCountMap().values(); result.put(\"counts\", counts); result.put(\"serving\", counts.stream().anyMatch(t -&gt; t.getInvoking().sum() &gt; 0L)); return result; &#125;&#125; 服务管理RejectFilter使用filter拦截请求，并在filter中维护一个下线状态，如果下线了则拒绝所有请求（针对这种返回值，客户端可以重新发现其他节点）。 123456789101112131415@Datapublic class RejectFilter implements RpcFilter &#123; private boolean reject = false; //拒绝请求的处理逻辑也可以自定义 private BiConsumer&lt;RpcRequest, RpcResponse&gt; rejectFunction = (rpcRequest, response) -&gt; response.reject(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; if (reject) &#123; rejectFunction.accept(request, response); return; &#125; filterChain.doFilter(request, response); &#125;&#125; EndpointMvcAdapterEndpoint使用很方便，但是相对controller不是那么灵活，比如我要让接口支持参数，就需要一些其他操作，将Endpoint使用EndpointMvcAdapter包装一次。为了复用，我写了个通用的EndpointMvcAdapter，通过反射去调用参数指定的方法。 1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class ReflectEndpointMvcAdapter extends EndpointMvcAdapter implements RpcCode &#123; private Map&lt;String, Method&gt; methodMap = new HashMap&lt;&gt;(); private Set&lt;String&gt; ipWhiteList = new HashSet&lt;&gt;(); public ReflectEndpointMvcAdapter(Endpoint&lt;?&gt; delegate, String ipWhiteList) &#123; super(delegate); Method[] methods = delegate.getClass().getMethods(); //... &#125; @RequestMapping(value = \"/&#123;name:.*&#125;\", method = RequestMethod.GET, produces = &#123; ActuatorMediaTypes.APPLICATION_ACTUATOR_V1_JSON_VALUE, MediaType.APPLICATION_JSON_VALUE &#125;) @ResponseBody @HypermediaDisabled public Object invoke(HttpServletRequest request, HttpServletResponse response, @PathVariable String name) &#123; if (!checkIp(request)) &#123; //... &#125; Method method = methodMap.get(name); //... try &#123; return method.invoke(getDelegate()); &#125; catch (Exception e) &#123; //... &#125; &#125; private boolean checkIp(HttpServletRequest request) &#123; //... &#125; private String getIp(HttpServletRequest request) &#123; //... &#125;&#125; RpcEndpoint因为要用ReflectEndpointMvcAdapter，invoke方法暂时没想到用什么（ /rpc 时调用），就返回null。 1234567891011121314151617181920212223242526272829public class RpcEndpoint extends AbstractRpcEndpoint&lt;Object&gt; implements RpcCode &#123; private RejectFilter filter; public RpcEndpoint(RejectFilter filter) &#123; super(\"\"); this.filter = filter; &#125; @Override public Object invoke() &#123; return null; &#125; public void online() &#123; filter.setReject(false); &#125; public void offline() &#123; filter.setReject(true); &#125; public int status() &#123; if (filter.isReject()) &#123; throw new HttpStatusException(NOT_AVAILABLE); &#125; return 0; &#125;&#125; 定义bean时包装 123456789@Beanpublic ReflectEndpointMvcAdapter rpcEndpoint(RejectFilter rejectFilter) &#123; return new ReflectEndpointMvcAdapter(process(new RpcEndpoint(rejectFilter)), ipWhiteList);&#125;private &lt;T extends AbstractRpcEndpoint&lt;?&gt;&gt; T process(T endpoint) &#123; endpoint.setSensitive(sensitive); return endpoint;&#125; 现在只要引入acuprpc-spring-boot-starter-actuator就能得到这几个http接口了，借助这几个接口服务可以优雅地重发。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"},{"name":"actuator","slug":"actuator","permalink":"https://acupt.cn/tags/actuator/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 4:request filter","slug":"acuprpc-4","date":"2018-11-29T05:00:00.000Z","updated":"2019-08-06T16:25:02.873Z","comments":true,"path":"2018/11/29/acuprpc-4/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-4/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 为了后续扩展方便，搞个filter支持，就抄一个servlet的filter吧。 servlet filter 分析在写mvc项目时，经常会用到filter，可以给一个请求做前置或者后置处理。如下： 1234567891011121314151617181920@WebFilter(filterName = \"requestFilter\", urlPatterns = \"/*\")public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"filter init\"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"我进来了\"); chain.doFilter(request, response); System.out.println(\"我要走了\"); &#125; @Override public void destroy() &#123; System.out.println(\"filter destroy\"); &#125;&#125; 这是一种责任链模式的实现，debug看下调用栈可以了解框架是怎么实现的。 每次请求生成一个FilterChain对象，并使其持有所有filter的数组，初始化成员变量pos=0（表示应该执行第几个filter） 从FilterChain.doFilter开始调用整个链路，从第一个filter开始，调用时会把chain本身传给filter，pos自增 某个filter如果不拦截这个请求，则调用FilterChain.doFilter，由于pos已经自增，则会调用下一个filter filter全部调用后（pos=filters.length）,开始真正执行请求 请求返回后会依次再经过之前经过的所有filter（倒序） rpc filter 实现定义filter接口，使用者如果要添加过滤逻辑需要集成这个接口。 123public interface RpcFilter &#123; void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain);&#125; filter持有者 1234567891011121314151617181920212223242526272829public class RpcFilterChain implements RpcCode &#123; private RpcFilter[] filters = new RpcFilter[0]; private int pos; private RpcServiceInfo serviceInfo; private RpcServiceExecutor serviceExecutor;//最终要执行请求的处理器 public RpcFilterChain(List&lt;RpcFilter&gt; filterList, RpcServiceInfo serviceInfo, RpcServiceExecutor serviceExecutor) &#123; if (filterList != null &amp;&amp; !filterList.isEmpty()) &#123; this.filters = new RpcFilter[filterList.size()]; this.filters = filterList.toArray(this.filters); &#125; this.serviceInfo = serviceInfo; this.serviceExecutor = serviceExecutor; &#125; public void doFilter(RpcRequest request, RpcResponse response) &#123; if (pos &lt; filters.length) &#123; RpcFilter filter = filters[pos++]; filter.doFilter(request, response, this); return; &#125; if (serviceExecutor == null) &#123; response.error(SERVICE_NOT_FOUND, \"service not exist: \" + serviceInfo); return; &#125; serviceExecutor.execute(request, response); &#125;&#125; rpc server 接收到请求后先初始化一个责任链，然后触发。 1234567891011public RpcResponse execute(RpcRequest rpcRequest) &#123; RpcServiceInfo rpcServiceInfo = new RpcServiceInfo(rpcRequest.getAppName(), rpcRequest.getServiceName()); RpcFilterChain chain = new RpcFilterChain(filters, rpcServiceInfo, serviceExecutorMap.get(rpcServiceInfo)); RpcResponse rpcResponse = new RpcResponse(); try &#123; chain.doFilter(rpcRequest, rpcResponse); &#125; catch (Exception e) &#123; rpcResponse.error(e); &#125; return rpcResponse;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"},{"name":"filter","slug":"filter","permalink":"https://acupt.cn/tags/filter/"},{"name":"责任链","slug":"责任链","permalink":"https://acupt.cn/tags/责任链/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 3:远程服务调用(thrift)","slug":"acuprpc-3","date":"2018-11-29T04:00:00.000Z","updated":"2019-08-06T16:24:59.301Z","comments":true,"path":"2018/11/29/acuprpc-3/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-3/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc thrift是Facebook开源的rpc框架，基于TPC，默认使用二进制。 需要先掌握thrift的基本用法: thrift-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-thrift //基于thrift实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 thrift 通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 resources/service.thrift 123456789101112131415161718namespace java com.acupt.acuprpc.protocol.thrift.protoservice ThriftService&#123; InvokeResponse invokeMethod(1:InvokeRequest invokeRequest)&#125;struct InvokeRequest&#123;1: required string appName;2: required string serviceName;3: required string methodName;4: required list&lt;string&gt; orderedParameter;5: required map&lt;string,string&gt; namedParameter;&#125;struct InvokeResponse&#123;1: required i32 code;2: optional string message;3: optional string result;&#125; thrift-service这个类负责接收 thrift-client 发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给 thrift-client。 123456789101112131415161718192021222324public class ThriftService implements com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface &#123; private RpcServer rpcServer; public ThriftService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public InvokeResponse invokeMethod(InvokeRequest invokeRequest) &#123; RpcRequest rpcRequest = new RpcRequest( invokeRequest.getAppName(), invokeRequest.getServiceName(), invokeRequest.getMethodName(), invokeRequest.getOrderedParameter(), invokeRequest.getNamedParameter()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = new InvokeResponse(); response.setCode(rpcResponse.getCode()); response.setMessage(rpcResponse.getMessage()); response.setResult(rpcResponse.getResultString()); return response; &#125;&#125; thrift-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 由于thrift server 调用serve()方法后会阻塞线程，因此需要另外启动一个线程去开启服务。 123456789101112131415161718192021222324252627282930313233public class ThriftServer extends RpcServer &#123; private static final int nThreads = 100; private TServer server; public ThriftServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @Override protected void startRpc() &#123; new Thread(() -&gt; &#123; TProcessor tprocessor = new com.acupt.acuprpc.protocol.thrift.proto.ThriftService. Processor&lt;com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface&gt;(new ThriftService(this)); TServerTransport serverTransport = null; try &#123; serverTransport = new TServerSocket(getRpcInstance().getRpcConf().getPort()); &#125; catch (TTransportException e) &#123; throw new RpcException(e); &#125; TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.executorService(Executors.newFixedThreadPool(nThreads)); server = new TThreadPoolServer(tArgs); server.serve();//阻塞 &#125;).start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.setShouldStop(true); &#125; &#125;&#125; thrift-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成thrift支持的结构，并调用thrift的请求方法，再把远程服务返回的结果返回给代理类。 thrift client 是线程不安全的，从它提供的方法就能够看出来。 12345678910111213public void send_invokeMethod(InvokeRequest invokeRequest)&#123; //...&#125;public InvokeResponse recv_invokeMethod()&#123; //...&#125;public InvokeResponse invokeMethod(InvokeRequest invokeRequest) throws org.apache.thrift.TException&#123; send_invokeMethod(invokeRequest); return recv_invokeMethod();&#125; 为了简单直接在把方法设为 synchronized ，后续再使用对象池 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ThriftClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;ThriftService.Client&gt; clientRef; public ThriftClient(NodeInfo nodeInfo) &#123; super(nodeInfo); clientRef = new AtomicReference&lt;&gt;(getClient(nodeInfo)); &#125; //todo client线程不安全，使用连接池管理 @Override @SneakyThrows protected synchronized String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest request = new InvokeRequest(); request.setAppName(rpcRequest.getAppName()); request.setServiceName(rpcRequest.getServiceName()); request.setMethodName(rpcRequest.getMethodName()); request.setOrderedParameter(rpcRequest.getOrderedParameter()); InvokeResponse response = clientRef.get().invokeMethod(request); if (response.getCode() != SUCCESS) &#123; throw new HttpStatusException(response.getCode(), response.getMessage()); &#125; return response.getResult(); &#125; @Override protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //... &#125; @Override public void shutdownRpc() &#123; close(clientRef.get()); &#125; private ThriftService.Client getClient(NodeInfo nodeInfo) &#123; //... &#125; private void close(ThriftService.Client client) &#123; //... &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.cn/tags/thrift/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 2:远程服务调用(grpc)","slug":"acuprpc-2","date":"2018-11-29T03:00:00.000Z","updated":"2019-08-06T16:24:56.198Z","comments":true,"path":"2018/11/29/acuprpc-2/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-2/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc gRPC是Google开源的跨语言远程服务调用(RPC)框架，通信协议用的HTTP/2，数据传输默认用的protocol buffers（一种轻便高效的结构化数据存储格式，想比json更小更快，不过没有可读性）。 需要先掌握grpc的基本用法: gRPC-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-grpc //基于grpc实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 grpc通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 1234567891011121314151617181920212223242526syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.acuprpc.protocol.grpc.proto\";option java_outer_classname = \"GrpcServiceProto\";package com.acupt.acuprpc.protocol.grpc.proto;service GrpcService &#123; rpc invokeMethod (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string appName = 1; string serviceName = 2; string methodName = 3; repeated string orderedParameter = 4; map&lt;string, string&gt; namedParameter = 5;&#125;message InvokeResponse &#123; int32 code = 1; string message = 2; string result = 3;&#125; grpc-service这个类负责接收grpc-client发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给grpc-client。 1234567891011121314151617181920212223242526public class GrpcService extends GrpcServiceGrpc.GrpcServiceImplBase &#123; private RpcServer rpcServer; public GrpcService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void invokeMethod(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; RpcRequest rpcRequest = new RpcRequest( request.getAppName(), request.getServiceName(), request.getMethodName(), request.getOrderedParameterList(), request.getNamedParameterMap()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = InvokeResponse.newBuilder() .setCode(rpcResponse.getCode()) .setMessage(rpcResponse.getMessage()) .setResult(rpcResponse.getResultString()) .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; grpc-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 123456789101112131415161718192021222324public class GrpcServer extends RpcServer &#123; private Server server; public GrpcServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @SneakyThrows @Override protected void startRpc() &#123; server = ServerBuilder .forPort(getRpcInstance().getRpcConf().getPort()) .addService(new GrpcService(this)) .build().start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.shutdown(); &#125; &#125;&#125; grpc-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成grpc支持的结构，并调用grpc的请求方法，再把远程服务返回的结果返回给代理类。 12345678910111213141516171819202122232425262728293031323334353637public class GrpcClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;GrpcServiceGrpc.GrpcServiceFutureStub&gt; stubRef; public GrpcClient(NodeInfo nodeInfo) &#123; super(nodeInfo); this.stubRef = new AtomicReference&lt;&gt;(getStub(nodeInfo)); &#125; @Override protected String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest.Builder builder = InvokeRequest.newBuilder() .setAppName(rpcRequest.getAppName()) .setServiceName(rpcRequest.getServiceName()) .setMethodName(rpcRequest.getMethodName()); // ... ListenableFuture&lt;InvokeResponse&gt; future = stubRef.get().invokeMethod(builder.build()); InvokeResponse response = null; //... return response.getResult(); &#125; @Override @SneakyThrows protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //...使用参数中的ip和端口建立新连接，并断开老的连接，可用于重新负载和异常节点重试 &#125; @Override @SneakyThrows public void shutdownRpc() &#123; //...主动断开和服务端的连接 &#125; private GrpcServiceGrpc.GrpcServiceFutureStub getStub(NodeInfo nodeInfo) &#123; //...和服务端建立连接，使用参数中的ip和端口 &#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.cn/tags/grpc/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 1:服务注册/发现(eureka)","slug":"acuprpc-1","date":"2018-11-29T02:00:00.000Z","updated":"2019-08-06T16:24:53.860Z","comments":true,"path":"2018/11/29/acuprpc-1/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-1/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 123- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 Eureka Serverspring-cloud-starter-eureka-server Eureka Client原理就是利用eureka提供的客户端类来向Eureka Server发送注册请求，把自己提供服务的地址和端口（rpc服务端口，不是springboot启动的\bhttp端口）告诉注册中心，这样其他客户端（包括自身）就可以请求Eureka Server获取需要的服务节点信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 在服务中心注册的实例 */@Getter@Slf4jpublic class RpcInstance &#123; private EurekaClient eurekaClient; private ApplicationInfoManager applicationInfoManager; private RpcConf rpcConf; public RpcInstance(RpcConf rpcConf) &#123; RpcEurekaInstanceConfig instanceConfig = new RpcEurekaInstanceConfig(); instanceConfig.setAppGroupName(rpcConf.getAppGroup()); instanceConfig.setAppname(rpcConf.getAppName()); instanceConfig.setNonSecurePort(rpcConf.getPort()); instanceConfig.setIpAddress(IpUtil.INTRANET_IP); instanceConfig.setHostname(IpUtil.HOSTNAME); RpcEurekaClientConfig clientConfig = new RpcEurekaClientConfig(); clientConfig.getServiceUrl().put(\"default\", rpcConf.getDiscoveryServiceUrl()); clientConfig.setRegisterWithEureka(rpcConf.isRegisterWithDiscovery()); InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get(); this.applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo); this.eurekaClient = new DiscoveryClient(applicationInfoManager, clientConfig); this.rpcConf = rpcConf; log.info(\"protocol server -&gt; \" + rpcConf.getRpcServerClass()); log.info(\"protocol client -&gt; \" + rpcConf.getRpcClientClass()); &#125; public void start() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.STARTING); &#125; public void started() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP); &#125; public void shutdown() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN); eurekaClient.shutdown(); &#125; /** * 创建一个rpc server，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcServer newRpcServer() &#123; return rpcConf.getRpcServerClass().getConstructor(RpcInstance.class).newInstance(this); &#125; /** * 创建一个rpc client，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcClient newRpcClient(NodeInfo nodeInfo) &#123; return rpcConf.getRpcClientClass().getConstructor(NodeInfo.class).newInstance(nodeInfo); &#125;&#125; starter构建一个自己的spring boot starter，这样别的项目只需要引入这个依赖，就能使用starter提供的服务了。 1234- resources - META-INF spring.factories // 定义@Configuration类的路径，有了这个声明依赖starter的项目就能获得starter中提供的bean spring-configuration-metadata.json // 配置信息（可选），有了它在IDE中编辑application配置文件可以看到提示信息 rpc server 服务管理作为rpc服务提供者，需要在应用启动时把有注解（@Rpc）的服务管理起来，这样接收到rpc请求后可以快速查询到指定对象，执行指定方法。 实现接口BeanPostProcessor的bean即可得到处理spring中的所有bean（每个bean初始化完成后会调用接口方法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RpcServiceScanner implements BeanPostProcessor &#123; private RpcServer rpcServer; public RpcServiceScanner(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // AOP代理类需要拿到原始的类，不然读不到类上的注解 Class&lt;?&gt; beanClass = AopUtils.isAopProxy(bean) ? AopUtils.getTargetClass(bean) : bean.getClass(); val nrpc = beanClass.getAnnotation(Rpc.class); if (nrpc == null) &#123; return bean; &#125; Method[] methods = beanClass.getDeclaredMethods(); if (methods.length == 0) &#123; return bean; &#125; Map&lt;String, MethodInfo&gt; methodInfoMap = new HashMap&lt;&gt;(); for (Method method : methods) &#123; methodInfoMap.put(method.getName(), new MethodInfo(method)); &#125; Class&lt;?&gt;[] interfaces = beanClass.getInterfaces(); if (interfaces.length == 0) &#123; return bean; &#125; // client是通过接口调用server的，因此并不知道具体实现类的路径，只有接口名，因此把所有接口都注册一遍 for (Class&lt;?&gt; serviceInterface : interfaces) &#123; rpcServer.registerService( new RpcServiceInfo(rpcServer.getRpcInstance().getRpcConf().getAppName(), serviceInterface.getCanonicalName()), bean, serviceInterface, methodInfoMap); &#125; return bean; &#125;&#125; rpc client 远程服务代理作为服务调用者，可以通过接口像调用本地代码一样调用远程服务，原理就是为接口创建一个代理，在代理中进行远程调用。 这里使用主动创建代理的方式。 1234567891011121314151617public class RpcServiceConsumer &#123; private RpcClientManager rpcClientManager; public RpcServiceConsumer(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @SuppressWarnings(\"unchecked\") public &lt;T&gt; T create(String appName, Class&lt;T&gt; serviceInterface) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(appName, serviceInterface.getCanonicalName()); return (T) Proxy.newProxyInstance( serviceInterface.getClassLoader(), new Class&lt;?&gt;[]&#123;serviceInterface&#125;, new RpcInvocationHandler(serviceInfo, rpcClientManager)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class RpcInvocationHandler implements InvocationHandler &#123; private RpcServiceInfo rpcServiceInfo; private RpcServiceManager rpcServiceManager; private RpcClient rpcClient; public RpcInvocationHandler(RpcServiceInfo rpcServiceInfo, RpcServiceManager rpcServiceManager) &#123; this.rpcServiceInfo = rpcServiceInfo; this.rpcServiceManager = rpcServiceManager; tryInitRpcClient(false); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; RpcMethodInfo methodInfo = new RpcMethodInfo(rpcServiceInfo, method.getName(), method.getGenericReturnType()); return tryGetRpcClient().invoke(methodInfo, args); &#125; private RpcClient tryGetRpcClient() &#123; if (rpcClient == null) &#123; tryInitRpcClient(true); &#125; return rpcClient; &#125; private synchronized void tryInitRpcClient(boolean throwError) &#123; if (rpcClient != null) &#123; return; &#125; try &#123; rpcClient = rpcServiceManager.lookup(rpcServiceInfo); &#125; catch (Exception e) &#123; if (throwError) &#123; throw e; &#125; &#125; &#125;&#125; 注册一个ApplicationListener，接收springboot程序准备完后的信号，然后告诉注册中心准备好了。 12345678910111213public class RpcApplicationListener implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123; private RpcServer rpcServer; public RpcApplicationListener(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void onApplicationEvent(ApplicationReadyEvent event) &#123; rpcServer.started(); &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.cn/tags/eureka/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 0:前言","slug":"acuprpc-0","date":"2018-11-29T01:00:00.000Z","updated":"2019-08-06T16:25:15.463Z","comments":true,"path":"2018/11/29/acuprpc-0/","link":"","permalink":"https://acupt.cn/2018/11/29/acuprpc-0/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 最近在新公司开始接触微服务，在此之前并没有微服务的开发经验。对比了spring cloud和公司的rpc框架，对微服务这套东西终于有了一点粗浅的认知，为了加深理解，自己动手写个rpc框架玩玩。顺便记录下来，不然玩过的东西过段时间就忘了。 我的spring cloud的入门读物: 史上最简单的 SpringCloud 教程 我的学习成果: acuprpc 设计方案总的来说就是在现有工具上的二次开发。 服务注册/发现: eureka 这个模块spring cloud已经集成的非常易用了，实在没兴趣再整些骚操作，引入spring-cloud-starter-eureka-server依赖，启动类加个注解@EnableEurekaServer就是一个注册中心了。 远程服务调用: grpc/thrift grpc是Google开源的rpc框架，thrift是Facebook开源的rpc框架，而且他们都支持跨语言，都是很厉害的东西，需要用它们的规则定义数据结构，\b每个\b服务都定义一次是挺累的，如果只定义一个通用的服务，然后在这个服务里面通过Java反射去执行对应方法就可以少很多工作量了（把工作量变成了Java代码编写）。 至于选择这两种，因为都想试试，所以最终设计rpc框架是可以切换通信方式的，把这部分抽出来做成可扩展的即可。 目录// 只要列出来，总有一天会写完。 从0.5到1写个rpc框架 - 1:服务注册/发现(eureka) 从0.5到1写个rpc框架 - 2:远程服务调用(grpc) 从0.5到1写个rpc框架 - 3:远程服务调用(thrift) 从0.5到1写个rpc框架 - 4:request filter 从0.5到1写个rpc框架 - 5:服务监控和管理(actuator) 从0.5到1写个rpc框架 - 6:调用异常节点自动重试 从0.5到1写个rpc框架 - 7:网关支持(gateway)","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/tags/微服务/"},{"name":"rpc","slug":"rpc","permalink":"https://acupt.cn/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.cn/tags/grpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.cn/tags/thrift/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.cn/tags/eureka/"},{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"thrift-Java 示例","slug":"thrift-start","date":"2018-11-20T12:00:00.000Z","updated":"2018-11-20T12:05:26.055Z","comments":true,"path":"2018/11/20/thrift-start/","link":"","permalink":"https://acupt.cn/2018/11/20/thrift-start/","excerpt":"","text":"安装thriftmac brew install thrift 安装完成检查 thrift –version 新建maven项目pom.xml 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;libthrift&lt;/artifactId&gt; &lt;version&gt;0.11.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;thrift-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.10.0&lt;/version&gt; &lt;configuration&gt; &lt;thriftExecutable&gt;/usr/local/bin/thrift&lt;/thriftExecutable&gt; &lt;!--thrift安装路径--&gt; &lt;thriftSourceRoot&gt;src/main/resources&lt;/thriftSourceRoot&gt; &lt;!--thrift配置文件路径--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;thrift-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 定义服务新建文件 src/main/resources/service.thrift 1234namespace java com.acupt.thritf.serviceservice HelloService&#123; string hello(1:string name)&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现thrift远程调用。 target/generated-sources/thrift/com/acupt/thritf/service/HelloService.java 如果在项目中无法直接引用上面的类，IDEA右键\bthrift文件夹 -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 123456789101112131415package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TException;/** * 服务实现类 */public class HelloServiceImpl implements HelloService.Iface &#123; @Override public String hello(String name) throws TException &#123; return \"hello,\" + name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TProcessor;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.server.TServer;import org.apache.thrift.server.TSimpleServer;import org.apache.thrift.transport.TServerSocket;/** * 服务提供方 */public class MyServer &#123; public static void main(String args[]) &#123; try &#123; TProcessor tprocessor = new HelloService.Processor&lt;HelloService.Iface&gt;(new HelloServiceImpl()); TServerSocket serverTransport = new TServerSocket(50005); TServer.Args tArgs = new TServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.protocolFactory(new TBinaryProtocol.Factory()); TServer server = new TSimpleServer(tArgs); System.out.println(\"server starting\"); //定时关闭 new Thread(() -&gt; &#123; try &#123; System.out.println(\"server wait stop\"); Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"server stopping\"); server.stop(); System.out.println(\"server stop\"); &#125;).start(); server.serve();//会阻塞 System.out.println(\"server finish\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.protocol.TProtocol;import org.apache.thrift.transport.TSocket;import org.apache.thrift.transport.TTransport;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; TTransport transport = null; try &#123; transport = new TSocket(\"localhost\", 50005); TProtocol protocol = new TBinaryProtocol(transport); HelloService.Client client = new HelloService.Client(protocol); transport.open(); String result = client.hello(\"tom\"); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != transport) &#123; transport.close(); &#125; &#125; &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient。 和grpc用法\b差不多，gRPC-Java 示例","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.cn/tags/rpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.cn/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"spring rabbitmq 异常重试源码分析","slug":"spring-rabbitmq-retry","date":"2018-11-15T03:00:00.000Z","updated":"2019-07-12T14:14:55.510Z","comments":true,"path":"2018/11/15/spring-rabbitmq-retry/","link":"","permalink":"https://acupt.cn/2018/11/15/spring-rabbitmq-retry/","excerpt":"","text":"springboot集成rabbitMQ\b发消息123456789@Resourceprivate RabbitTemplate rabbitTemplate;@Value(\"$&#123;my.exchange&#125;\")private String exchange;public void send(Object obj) &#123; rabbitTemplate.convertAndSend(exchange, \"\", JsonUtils.toJson(obj));&#125; 处理消息1234@RabbitListener(queues = \"$&#123;msg.queue.my.exchange&#125;\")public void receive(String msg) &#123; //...&#125; 默认情况下，如果处理消息时抛出了异常，这个消息会一直重复消费（重复调用receive方法），直到没有抛异常。 消息接收/处理流程分析在@RabbitListener注解的方法里打个断点，观察下调用栈。 末端是个实现了Runnable的内部类SimpleMessageListenerContainer$AsyncMessageProcessingConsumer 123456789101112@Overridepublic void run() &#123; //…… //从这里可以看出只要这个消费者（consumer）状态满足会一直轮询去接收消息和消费消息 while (isActive(this.consumer) || this.consumer.hasDelivery() || !this.consumer.cancelled()) &#123; try &#123; boolean receivedOk = receiveAndExecute(this.consumer); // At least one message received //…… &#125; //…… &#125;&#125; 12345678910111213141516171819202122232425private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Throwable &#123; //NOSONAR Channel channel = consumer.getChannel(); for (int i = 0; i &lt; this.txSize; i++) &#123; logger.trace(\"Waiting for message from consumer.\"); Message message = consumer.nextMessage(this.receiveTimeout); if (message == null) &#123;break;&#125; try &#123; //如果获取到了消息就会去消费，这里最终会执行到我们写的listener方法 executeListener(channel, message); &#125; //当我们写的方法抛异常的时候就会来到这里 //发现嫌疑代码：consumer.rollbackOnExceptionIfNecessary(ex) catch (ImmediateAcknowledgeAmqpException e) &#123;/*……*/&#125; catch (Throwable ex) &#123; //NOSONAR if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;/*……*/&#125; if (this.transactionManager != null) &#123;/*没开事务，忽略*/&#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125; return consumer.commitIfNecessary(isChannelLocallyTransacted(channel));&#125; 12345678910111213141516171819202122public void rollbackOnExceptionIfNecessary(Throwable ex) throws Exception &#123; boolean ackRequired = !this.acknowledgeMode.isAutoAck() &amp;&amp; !this.acknowledgeMode.isManual(); try &#123; if (this.transactional) &#123;/*……*/&#125; if (ackRequired) &#123; boolean shouldRequeue = RabbitUtils.shouldRequeue(this.defaultRequeuRejected, ex, logger); for (Long deliveryTag : this.deliveryTags) &#123; // 最终会执行到这里 // With newer RabbitMQ brokers could use basicNack here... this.channel.basicReject(deliveryTag, shouldRequeue); &#125; if (this.transactional) &#123;/*……*/&#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"Application exception overridden by rollback exception\", ex); throw e; &#125; finally &#123; this.deliveryTags.clear(); &#125;&#125; 由上可看出，导致无限重试的两个值： ackRequired: 和ack模式相关 shouldRequeue: 和defaultRequeuRejected以及抛出的异常类型有关 根据需要修改acknowledgeMode或者defaultRequeuRejected即可，在配置文件中根据IDE补全提示可以找到这两个属性。 12spring.rabbitmq.listener.acknowledge-mode=nonespring.rabbitmq.listener.default-requeue-rejected=false 如果只是不想异常时重试，直接在业务代码中try…catch全部代码不让抛异常也行。 PS：验证这两个配置的时候发现不生效，一番debug发现项目里面自定义了一个工厂bean，创建消费者相关对象时用的那个工厂bean，而不是根据配置属性生成。 1234567@Beanpublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(new Jackson2JsonMessageConverter()); return factory;&#125; 注释掉这个bean那两个配置才生效，当然也可以在这个bean里设置那两个属性。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.cn/categories/随笔/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://acupt.cn/tags/rabbitmq/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.cn/categories/随笔/"}]},{"title":"spring cloud 自定义配置源及配置刷新","slug":"spring-cloud-source-diy","date":"2018-10-29T07:19:56.000Z","updated":"2019-08-06T16:25:22.266Z","comments":true,"path":"2018/10/29/spring-cloud-source-diy/","link":"","permalink":"https://acupt.cn/2018/10/29/spring-cloud-source-diy/","excerpt":"","text":"通过自定义配置源可以接入自己的配置服务，配合ContextRefresher可以让应用运行中自动更新配置。 实现PropertySourceLocator123456789101112131415161718/** * 自定义配置源 */public class MyPropertySourceLocator implements PropertySourceLocator &#123; @Override public PropertySource&lt;?&gt; locate(Environment environment) &#123; String msg = new SimpleDateFormat(\"HH:mm:ss\").format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"demo.diy.msg\", msg); System.err.println(\"MyPropertySourceLocator, demo.diy.msg = \" + msg); //spring自带的一个简单的map结构配置集合，也可以继承PropertySource自定义 MapPropertySource source = new MapPropertySource(\"my-source\", map); return source; &#125;&#125; 配置类123456789@Configurationpublic class MyConfigBootstrapConfiguration &#123; @Bean public MyPropertySourceLocator myPropertySourceLocator() &#123; return new MyPropertySourceLocator(); &#125;&#125; 用Java代码声明bean，还需要在resources/META-INF/spring.factories中声明 12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\com.netease.ag.demoweb.MyConfigBootstrapConfiguration Spring中类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 使用自定义配置123456789101112131415@RefreshScope //可更新@Component@Datapublic class ValueConfig &#123; @Value(\"$&#123;demo.copy.msg&#125;\") private String copyMsg; @Value(\"$&#123;demo.diy.msg&#125;\") private String diyMsg; public ValueConfig() &#123; System.err.println(\"ValueConfig init\"); &#125;&#125; application.properties中可以引用自定义配置 1demo.copy.msg=$&#123;demo.diy.msg&#125; springboot应用启动12345678910111213141516171819202122232425262728@SpringBootApplication@RestControllerpublic class DemowebApplication &#123; @Resource private ValueConfig valueConfig; @Resource private ContextRefresher contextRefresher; public DemowebApplication() &#123; System.err.println(\"DemowebApplication init\"); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemowebApplication.class, args); &#125; @RequestMapping(\"/t\") public String t() &#123; return valueConfig.toString(); &#125; //更新bean属性 @RequestMapping(\"/r\") public Object r() &#123; return contextRefresher.refresh(); &#125; 启动日志1234567891011121314 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)MyPropertySourceLocator, demo.diy.msg = 17:18:22...DemowebApplication init...ValueConfig init...Tomcat started on port(s): 8080 (http) 查询，多次请求返回一致 请求：http://localhost:8080/t响应：ValueConfig(copyMsg=17:18:22, diyMsg=17:18:22) 更新 请求：http://localhost:8080/r响应：[“demo.diy.msg”] 日志输出：1MyPropertySourceLocator, demo.diy.msg = 17:27:44 再次调用查询接口，发现值改变，并且输出日志 1ValueConfig init 证明更新字段实际是重新生成了一个bean","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://acupt.cn/tags/spring/"},{"name":"config","slug":"config","permalink":"https://acupt.cn/tags/config/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"gRPC-Java 示例","slug":"grpc-start","date":"2018-10-23T12:19:56.000Z","updated":"2018-11-28T07:41:22.877Z","comments":true,"path":"2018/10/23/grpc-start/","link":"","permalink":"https://acupt.cn/2018/10/23/grpc-start/","excerpt":"","text":"新建maven项目pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-all&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.3.0:exe:$&#123;os.detected.classifier&#125; &lt;/protocArtifact&gt; &lt;pluginId&gt;grpc-java&lt;/pluginId&gt; &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.5.0:exe:$&#123;os.detected.classifier&#125; &lt;/pluginArtifact&gt; &lt;!--*.proto文件目录--&gt; &lt;protoSourceRoot&gt;src/main/resources&lt;/protoSourceRoot&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;compile-custom&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 定义服务新建文件 src/main/resources/test.proto 1234567891011121314151617181920syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.grpc.proto\";option java_outer_classname = \"HelloProto\";package com.acupt.grpc;service HelloService &#123; rpc hello (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string name = 1;&#125;message InvokeResponse &#123; string msg = 1;&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现gRPC远程调用。 但在项目中还无法直接引用上面的类，右键\b -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 1234567891011121314151617181920212223package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.stub.StreamObserver;/** * 服务实现类 */public class HelloService extends HelloServiceGrpc.HelloServiceImplBase &#123; @Override public void hello(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; System.out.println(\"request -&gt; \" + request); String name = request.getName();//自定义的字段名 name InvokeResponse response = InvokeResponse.newBuilder() .setMsg(\"hello,\" + name)//自定义的字段名 msg .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; 12345678910111213141516171819202122232425package com.acupt.grpc;import io.grpc.Server;import io.grpc.ServerBuilder;import java.io.IOException;/** * 服务提供方 * * @author liujie */public class MyServer &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; int port = 50051; Server server = ServerBuilder.forPort(port) .addService(new HelloService()) .build() .start(); System.out.println(\"started\"); Thread.sleep(1000 * 60 * 2); server.shutdown(); System.out.println(\"shutdown\"); &#125;&#125; 123456789101112131415161718192021package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.Channel;import io.grpc.ManagedChannelBuilder;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; InvokeRequest request = InvokeRequest.newBuilder().setName(\"tom\").build(); Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 50051).usePlaintext(true).build(); HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); InvokeResponse response = blockingStub.hello(request); System.out.println(response.getMsg()); &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient 请求方式1.阻塞\b同步请求，接口返回前是阻塞的。 123HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);InvokeResponse response = blockingStub.hello(request);System.out.println(response.getMsg()); 2.Future调用后返回guava包里继承了Future的接口ListenableFuture（增加了listener支持），可以控制超时时间。 12345678910111213141516HelloServiceGrpc.HelloServiceFutureStub futureStub = HelloServiceGrpc.newFutureStub(channel);ListenableFuture&lt;InvokeResponse&gt; future = futureStub.hello(request);future.addListener( () -&gt; System.out.println(\"listener 1\"), command -&gt; &#123; System.out.println(\"execute 1 \" + command); command.run(); &#125;);future.addListener( () -&gt; System.out.println(\"listener 2\"), command -&gt; &#123; System.out.println(\"execute 2 \" + command); command.run(); &#125;);System.out.println(future.get(10, TimeUnit.SECONDS)); 3.回调调用接口传入回调函数，调用后马上返回。 123456789101112131415161718192021222324MyClient.done = false;HelloServiceGrpc.HelloServiceStub stub = HelloServiceGrpc.newStub(channel);stub.hello(request, new StreamObserver&lt;InvokeResponse&gt;() &#123; @Override public void onNext(InvokeResponse value) &#123; System.out.println(\"onNext \" + value); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \" + t.getMessage()); t.printStackTrace(); MyClient.done = true; &#125; @Override public void onCompleted() &#123; System.out.println(\"onCompleted\"); MyClient.done = true; &#125;&#125;);while (!MyClient.done) &#123; Thread.sleep(1000);&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.cn/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.cn/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.cn/categories/微服务/"}]},{"title":"github+hexo搭建个人主页","slug":"github-hexo-homepage","date":"2018-05-20T07:41:09.000Z","updated":"2019-08-04T14:55:33.481Z","comments":true,"path":"2018/05/20/github-hexo-homepage/","link":"","permalink":"https://acupt.cn/2018/05/20/github-hexo-homepage/","excerpt":"","text":"作为技术人员，谁不曾想过有一个属于自己的网站。但因为种种原因（没时间、没技术、没钱…），往往只是想想。现在，一套完整的解决方案来帮助彷徨的你实现梦想~ 在下以前也尝试过搭建个人主页，前端+后端+服务器+域名，等这些都弄过一遍后，发现系统设计的太挫没有使用的欲望，也没有写博客的欲望。某天突然醒悟了，别搞那些花里胡哨的，好好找个现成的工具能搭建自己的网站就行，我都能想到，别人肯定早做出来了。 hexo，快速、简洁且高效的博客框架。hexo快速搭建博客（不写代码），基本无缝接入自己的md文档，配合github，服务器和域名也有了。 macOS Sierra github git nodejs hexo github个人主页创建官方教程 新建仓库我的github用户名是acupt，新建仓库，名为 acupt.github.io， git地址为 git@github.com:acupt/acupt.github.io.git github给你的个人主页地址为 https://acupt.github.io 修改主页访问主页地址将展示根目录下的index.html，如果没有的话展示README.md，也没有？告辞！ 这时候可以在index.html里面写主页代码了，不想写的继续往下。 hexo搭建个人主页安装hexo准备工作，请自行安装 nodejs git 开始安装hexo，新建一个文件夹并进入它 123npm install hexo-cli -ghexo initnpm install 启动hexo12hexo g # 生成文件，同 hexo generatehexo s # 启动服务，同 hexo server 启动成功后在浏览器访问 http://localhost:4000 写文章主目录下执行命令可新建一个md文件，也可以自己新建到source/_posts目录下 12345678hexo new &quot;文件名&quot; #新建文章hexo new page &quot;页面名&quot; #新建页面 # 常用简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 修改主题如果默认模板就能满足，此步骤可以跳过，但不找个酷炫的模板还怎么zhuangbility。 下载主题先找到你想象中的滑板鞋（ 官方模板库 ），克隆模板到hexo的themes目录下。 12# 我好不容易找到的酷炫模板git clone https://github.com/miccall/hexo-theme-Mic_Theme.git 但这个项目名不太友好，克隆成功后需要把文件夹重命名为模板名。 1mv hexo-theme-Mic_Theme miccall 主题模板配置编辑hexo主目录下的_config.yml，修改theme参数为新的主题名miccall 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: yiliatheme: miccall 修改模板的配置文件，在模板文件夹内也有个_config.yml，和hexo主目录下的_config.yml负责的东西不一样，hexo的配置管通用属性，模板的配置管个性参数，模板的项目首页一般都有配置教程。 模板可能有些地方不符合自己的需求，如果没法配置的话，除了给作者提issue，还可以自己改模板代码（反正代码在本地，可以为所欲为），比如我把这个模板的group（团队）布局用来展示自己的作品，那我就不需要QQ微信微博，只要个链接就行了，看文档没有相关参数隐藏，去代码里搜索了下，注释掉了那几行代码。 重启服务如果之前启动着，Ctrl+C关闭，后台运行的就kill掉。 123hexo clean # 清除缓存，会删除主目录下的public目录和数据库数据hexo ghexo s hexo发布个人主页到github编辑hexo主目录下的_config.yml，修改deploy配置 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:acupt/acupt.github.io.git branch: master 此配置表示用部署到git上，不过需要再安装一个插件。 1npm install hexo-deployer-git --save 发布 12hexo ghexo d 访问自己的github个人页面（如 https://acupt.github.io/ )，查看效果。 感谢miccall@github提供的酷炫模板，https://github.com/miccall/hexo-theme-Mic_Theme 技术性改进虽然这个主题很酷炫，但不可能每一点都如我所愿，如果主题作者未提供可配置选项，就需要对模板源代码做些改动。 先去主题项目的github主页fork一份到自己的github，再clone到本地。 links布局配置可选此主题的团队页面布局我很喜欢，但我并没有小伙伴想贴上去，那就做成作品展示页面好了。但是这个布局设计之初是为了展示人，所以有QQ、微信等信息配置，但我只想要一个‘链接’属性，其它的显示出来有点碍事。 IDE打开本地代码，全局搜索，就用属性名做关键词，果断在一个page-links.ejs文件中发现。 123456&lt;ul class=&quot;social&quot;&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 网上查一下语法，加个if判断。 1234567891011121314&lt;ul class=&quot;social&quot;&gt; &lt;% if (site.data.links[i].link != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].qq != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].wachat != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].weibo != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ul&gt; 妥了 https站内访问http资源受限部署到github后第二天发现我酷炫的作品展示页面不再酷炫了，样式有点诡异，打开调试界面 显然最上面那两个异常是问题所在（下面那个异常没影响，有空再研究） https协议的网站如果用http访问外部资源，往往会收到这种限制，这种情况最好统一一下，大家用同样的协议即可，显然我不能改github的协议，那只能改主题代码了 还是一波全局搜索，还是那个文件 12&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 改成https即可，但可以再优雅点 12&lt;link href=&quot;//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 发布，验证，搞定，顺便提了个pull request。 氪金项目:绑定自己的域名 友情提示：到了这步，再往下就需要氪金了。。。 虽然博客已经可以用了，但毕竟是个二级域名（acupt.github.io），如果想让自己的博客更有逼格，可以绑定一个自己的域名。 域名一般在阿里云或者腾讯云就可以买，比较方便，而且因为github服务器在国外，可以直接解析你的域名到github页面，无须备案。如果是自己买的国内服务器，那么想绑定域名则需要备案（在哪买服务器在哪备案），比较麻烦。 购买域名：国内玩家首选 阿里云 配置域名解析：购买域名后进入阿里云控制台，添加域名解析，记录类型选择CNAME，记录值为你的博客地址（acupt.github.io） 添加CNAME文件：在acupt.github.io仓库根目录添加一个文件CNAME（没有扩展名），内容是你的域名： 参考 我的 12acupt.cnwww.acupt.cn 我配置了两个域名，一个主域名acupt.cn，一个大家比较熟悉的www.acupt.cn（最后还是被重定向到主域名了），如果访问acupt.github.io也会被重定向到acupt.cn。 HTTPS支持：使用自己的域名后一般会变成http访问，因为你没有SSL证书。这个也是可以支持的，但由于我没操作过，就不写了。但我的网站仍然是https，为何？一开始我的绑定域名后是http，过了一两天有一个页面访问时被重定向成https，令人困惑。又过了几天，全部都是https了。。。网上没找到太多资料，似乎这是github一个没完全开放的功能？ 氪金项目:使用自己的服务器 不氪金，你怎么变强？ github虽好，速度是硬伤，如果想自己的博客访问速度更快，拥有一台服务器很重要。 当然开源中国的码云也提供了个人主页功能，速度虽然快点，但限制颇多，比如绑定自己的域名也要收钱（是的，还要再给开源中国钱，这钱买个服务器岂不快哉）。 推荐几个云服务器选择： 亚马逊：国外的公司，网站不太服务国人习惯，而且反馈问题一般要用英文，不太方便。 亚马逊可以薅羊毛，新用户绑定信用卡后有个最低级的云服务器一年使用权，注意要信用卡。当初搞了个一年的服务器，因为在国外，就趁机搭建了一个翻墙服务器爽了几天。 薅羊毛注意：一年到期不会自动消失，会开始扣费（信用卡），注意提前关闭，或者留意官方的英文提醒邮件，不然。。。（我想静静） 腾讯云：用过，没啥毛病，每天参与秒杀，运气好可以抢到很便宜而且性能不错的服务器。 阿里云：依然是国内玩家首选， 腾讯云和阿里云都有针对学生党的优惠，月租很便宜，相当于一个视频会员，社会人也没关系，新人也是有优惠的，不是新人？都是老相识了该氪就氪吧~ The End这篇帖子是2018年写的了，今天（2019-08-02）我又翻出来编bian辑shi了一下。所以我的博客其实已经换了个低调的主题了（时间会使人成熟）。 改进项目： 新增域名绑定 新增两项氪金项目 维护博客是一件长期的事，把它当成一件爱好，或者一个目标，可以更好的坚持下去。欢迎关注我，一起交流如何把博客做的更好。","categories":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.cn/categories/实践笔记/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.cn/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://acupt.cn/tags/hexo/"}],"keywords":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.cn/categories/实践笔记/"}]},{"title":"github搭建个人maven仓库","slug":"github-repository","date":"2018-05-20T07:00:00.000Z","updated":"2019-07-24T13:37:13.505Z","comments":true,"path":"2018/05/20/github-repository/","link":"","permalink":"https://acupt.cn/2018/05/20/github-repository/","excerpt":"","text":"Maven对Java开发者来说是很常见的工具，有了它只需要在pom文件加几行代码就能引入第三方代码。如果想我们自己写的工具类也让别人通过这种方式使用，不妨借助github搭建个免费仓库。 核心原理就是在github上建立一个代码仓库来存储我们发布的jar包，不需要自己买服务器，买域名，这些github都能帮我们实现。 新建仓库 在github新建一个普通的仓库即可，我的仓库地址 https://github.com/acupt/repository.git 克隆到本地 123456789101112➜ github git clone https://github.com/acupt/repository.gitCloning into &apos;repository&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.➜ github cd repository ➜ repository git:(master) lsREADME.md➜ repository git:(master) pwd/Users/acupt/github/repository 发布到本地 用deploy命令发布项目，指定打包的文件输出到上一步克隆的本地仓库，在项目（我们需要发布到仓库的代码/jar包）根目录下执行以下指令 1mvn deploy -DaltDeploymentRepository=acupt-repository::default::file:/Users/acupt/github/repository/ 同步到远程仓库 不想用master可以新建个分支 123git branch snapshotgit push origin snapshotgit checkout snapshot git add/commit/push 12345678910111213141516171819202122232425262728➜ repository git:(snapshot) ✗ git add com/➜ repository git:(snapshot) ✗ git commit -m &quot;acupsession&quot;[snapshot 4409029] acupsession 12 files changed, 74 insertions(+) create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.sha1 create mode 100644 com/acupt/acupsession/maven-metadata.xml create mode 100644 com/acupt/acupsession/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/maven-metadata.xml.sha1 ➜ repository git:(snapshot) ✗ git pushCounting objects: 18, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (18/18), 12.50 KiB | 6.25 MiB/s, done.Total 18 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To https://github.com/acupt/repository.git 3951922..4409029 snapshot -&gt; snapshot➜ repository git:(snapshot) ✗ 测试到这里已经ok了，通过GitHub提供的域名可以下载maven依赖（但无法查看列表），地址： https://raw.github.com/acupt/repository/snapshot 接下来新建一个项目试着引用前面发布的jar包，需要在pom文件中增加远程仓库地址，当然也可以在maven配置文件中做全局配置。 新建maven项目 修改pom.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;acupt-repository&lt;/id&gt; &lt;url&gt;https://raw.github.com/acupt/repository/snapshot&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupsession&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 查看本地maven仓库，看看jar包有没有下载成功 12345678➜ acupsession cd ~/.m2/repository/com/acupt/acupsession/1.0-SNAPSHOT ➜ 1.0-SNAPSHOT lsacupsession-1.0-20180519.110225-1.jar acupsession-1.0-SNAPSHOT.jaracupsession-1.0-20180519.110225-1.jar.sha1 acupsession-1.0-SNAPSHOT.pomacupsession-1.0-20180519.110225-1.jar.tmp.sha1.tmp maven-metadata-acupt-repository.xmlacupsession-1.0-20180519.110225-1.pom maven-metadata-acupt-repository.xml.sha1acupsession-1.0-20180519.110225-1.pom.sha1 maven-metadata-acupt-repository.xml.tmp.sha1.tmpacupsession-1.0-20180519.110225-1.pom.tmp.sha1.tmp maven-metadata-snapshots.xml 可以看到已经有jar包了，至此一个属于你自己的maven仓库就完成了。 如果想让别人不需要添加你的仓库地址就能用你的jar包，那么就不能用自己搭建的私人仓库了，需要发布到大家公用的仓库里去，有专门的提供这种服务的公司，网上一搜就有，但不是免费的，告辞。","categories":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.cn/categories/实践笔记/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.cn/tags/github/"},{"name":"maven","slug":"maven","permalink":"https://acupt.cn/tags/maven/"}],"keywords":[{"name":"实践笔记","slug":"实践笔记","permalink":"https://acupt.cn/categories/实践笔记/"}]}]}