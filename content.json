{"meta":{"title":"一杯82年的JAVA","subtitle":null,"description":null,"author":"ACUPT","url":"https://acupt.github.io"},"pages":[{"title":"","date":"2018-09-21T10:01:16.566Z","updated":"2018-09-21T10:01:16.566Z","comments":true,"path":"README.html","permalink":"https://acupt.github.io/README.html","excerpt":"","text":"sourcemy hexo source"},{"title":"about me","date":"2018-05-20T08:00:00.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"about/index.html","permalink":"https://acupt.github.io/about/index.html","excerpt":"","text":"I’m fine, fuck you."},{"title":"Gallery","date":"2017-01-17T13:39:03.000Z","updated":"2018-09-21T10:01:16.570Z","comments":true,"path":"gallery/index.html","permalink":"https://acupt.github.io/gallery/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-17T13:39:14.000Z","updated":"2018-09-21T10:01:16.687Z","comments":true,"path":"tag/index.html","permalink":"https://acupt.github.io/tag/index.html","excerpt":"","text":""},{"title":"group","date":"2017-01-17T13:05:04.000Z","updated":"2018-09-21T10:01:16.688Z","comments":true,"path":"work/index.html","permalink":"https://acupt.github.io/work/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA中的String真的不可变吗","slug":"java-string","date":"2019-07-17T15:00:00.000Z","updated":"2019-07-18T16:11:31.594Z","comments":true,"path":"2019/07/17/java-string/","link":"","permalink":"https://acupt.github.io/2019/07/17/java-string/","excerpt":"","text":"String是不可变的吗？是的！真想变？也行~ 我们都知道，String是不可变对象，即一旦创建，那么就不能改变它的状态。对此，我们来分析一波。 String的内部构造小心翼翼进入String的内部，我们可以看到它是一个final类，那么没人能继承它，很好，很丁克。 然后直接看向它的灵魂，一个char数组，也是final，于是我们知道它怎么不可变了。 1234567891011121314public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; // 略...&#125; 创建对象直接用常量给String变量赋值，不管在几个地方，几次，它们都是用的同一个数据。 除非new一个新的String。 123456789101112public class StringTest &#123; public static void main(String[] args) &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 123两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 利用反射修改值上面的代码后面再加点东西，尝试修改s1的值。 123456789101112131415161718192021222324252627282930313233public class StringTest &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; String s1 = \"abcd\"; String s2 = \"abcd\"; String s3 = new String(\"abcd\"); String s4 = new String(\"abcd\"); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); // 通过反射得到被String藏起来的value字段 Field f = String.class.getDeclaredField(\"value\"); // 让它敞开心扉 f.setAccessible(true); // 获取s1的内部value数组 char[] v = (char[]) f.get(s1); // 改掉它第一个字母 v[0] = 'x'; System.out.println(\"改变过后...\"); System.out.println(\"s1 = \" + s1); System.out.println(\"s2 = \" + s2); System.out.println(\"s3 = \" + s3); System.out.println(\"s4 = \" + s4); System.out.println(\"两个常量赋值\\t s1==s2:\" + (s1 == s2)); System.out.println(\"常量与新对象\\t s1==s3:\" + (s1 == s3)); System.out.println(\"两个新对象\\t s3==s4:\" + (s3 == s4)); &#125;&#125; 输出 1234567891011两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false改变过后...s1 = xbcds2 = xbcds3 = xbcds4 = xbcd两个常量赋值 s1==s2:true常量与新对象 s1==s3:false两个新对象 s3==s4:false 总结1、String内部的value通过反射真的可以改变2、直接改动value会导致其它相同值的String对象也被改变（所以可以猜测底层实际上用的同一份数据？）3、虽然值都改变了，但作为对象，4个变量的关系依然没有改变（new的两个String和其他两个依然不等）4、这样做很危险5、这样做很无聊","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}],"tags":[{"name":"java","slug":"java","permalink":"https://acupt.github.io/tags/java/"}],"keywords":[{"name":"JAVA","slug":"JAVA","permalink":"https://acupt.github.io/categories/JAVA/"}]},{"title":"CPU占用高如何排查","slug":"interview-cup-thread","date":"2019-07-17T14:30:00.000Z","updated":"2019-07-17T14:59:39.306Z","comments":true,"path":"2019/07/17/interview-cup-thread/","link":"","permalink":"https://acupt.github.io/2019/07/17/interview-cup-thread/","excerpt":"","text":"程序里少不了运算，如果不是环境太恶劣，CPU基本是能支撑应用运行的。但如果发现CPU居高不下，就需要思考是否程序有问题。 当服务器CPU居高不下，可以从下面几个方面入手定位问题。 找到JAVA进程 pid方法一: jps那个jar就是我的一个java程序 123456[root@iZba13i1mo82ot7a3lhq5oZ ~]# jps17616 Jps26016 jar9353 Bootstrap26028 Bootstrap16812 Bootstrap 方法二: ps -ef|grep 应用关键词和方法一找到的pid是相同的，26016 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -ef|grep acupjavaroot 17638 17550 0 22:34 pts/0 00:00:00 grep --color=auto acupjavaroot 26016 1 0 7月08 ? 00:05:11 java -jar acupjava-1.0-SNAPSHOT.jar 找到进程中CPU高的线程 tid打印出线程线程基本信息，找到cpu百分比高的一个或几个线程，记住它们的tid。 PS：栗子质量不好，全是0.0%，不要在意~ 123456789[root@iZba13i1mo82ot7a3lhq5oZ ~]# ps -mp 26016 -o THREAD,tid,timeUSER %CPU PRI SCNT WCHAN USER SYSTEM TID TIMEroot 0.0 - - - - - - 00:05:11root 0.0 19 - futex_ - - 26016 00:00:00root 0.0 19 - futex_ - - 26017 00:00:02root 0.0 19 - futex_ - - 26018 00:00:00root 0.0 19 - futex_ - - 26019 00:00:00root 0.0 19 - futex_ - - 26020 00:00:11(略...) 打印线程栈选择一个线程，把tid从10进制转为16进制 12[root@iZba13i1mo82ot7a3lhq5oZ ~]# printf \"%x\\n\" 2601765a1 为了方便查看可以把线程栈打印到文件里，jstack pid &gt;&gt; 文件名 使用ls查看文件已经存在 123[root@iZba13i1mo82ot7a3lhq5oZ ~]# jstack 26016 &gt;&gt; stack.txt[root@iZba13i1mo82ot7a3lhq5oZ ~]# lstest stack.txt 找到占用CPU高的线程打开文件，搜索tid所在位置，可以看到线程栈，由此分析定位可能有问题的代码。 12345\"http-nio-9527-AsyncTimeout\" #29 daemon prio=5 os_prio=0 tid=0x00007fbf68973800 nid=0x65a1 waiting on condition [0x00007fbf48ab0000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1200) at java.lang.Thread.run(Thread.java:748) 如此这般，CPU高的问题基本就能定位出来了。（PS: 以上数据做了些许脱敏处理）","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"cpu","slug":"cpu","permalink":"https://acupt.github.io/tags/cpu/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"内存泄漏如何排查","slug":"interview-oom-check","date":"2019-07-16T13:45:00.000Z","updated":"2019-07-16T15:00:32.013Z","comments":true,"path":"2019/07/16/interview-oom-check/","link":"","permalink":"https://acupt.github.io/2019/07/16/interview-oom-check/","excerpt":"","text":"JAVA的垃圾回收机制给了程序猿便利，我们可以不需要显式释放资源。但想高枕无忧却是不能，OOM像个隐藏在暗处的幽(hua)灵(nong)，威胁着可怜、弱小又漂亮的程序猿。 一般来说，一个健康的程序，它是不应该出现OOM的。内存里的对象从生到死，井然有序。但由于一些人为的失误，往往会让一些对象逃过GC的制裁，跳出GC外，不在垃圾中。这个时候，内存泄漏就发生了。 内存泄露，是指程序在申请内存并且用完这块内存后（对象不再需要了），没有释放已申请的内存空间。少数偶然的内存泄漏，虽然不太好，但问题不大，我们也不至于对那点内存抠抠搜搜的。但如果是内存不断泄漏，直到新的对象没有足够的空间生成，就会导致OOM。 什么时候可能内存泄漏抛出OOM异常当程序抛出OutOfMemoryError，如果你自认不是太抠，给了这个程序足够的空间，那么可以怀疑有内存泄漏 内存持续上升一个健康的程序应该有平稳的新陈代谢，内存占用应该维持在一定范围。但如果内存持续飙升，甚至到达了一个危险的值，那么可以怀疑有内存泄漏。 查看GC情况首先获取到应用的pid，可以使用java的jps命令，或者ps -ef|grep 应用名关键词 1234567891011121314151617/** * 启动个应用，持续造对象 */public class AcuptMain &#123; public static void main(String[] args) throws InterruptedException &#123; List&lt;Liangzai&gt; liangzais = new ArrayList&lt;&gt;(); while (true) &#123; liangzais.add(new Liangzai()); Thread.sleep(1000); &#125; &#125; private static class Liangzai &#123; byte[] body = new byte[1024 * 1024]; &#125;&#125; 1234567// 执行命令jps查看java进程➜ ~ jps11617 Launcher11618 AcuptMain1353 RemoteMavenServer1322 11627 Jps 123// 根据关键词查看，进程id为 11618 ，和jps查到的一致➜ ~ ps -ef|grep acupt 501 11618 1322 0 10:44下午 ?? 0:00.39 /Library/Java/JavaVirtualMachines... 123456789101112131415# 查看gc总体情况，各个区的使用率变化，3秒更新一次➜ ~ jstat -gcutil 11618 3000 S0 S1 E O M CCS YGC YGCT FGC FGCT GCT 0.00 0.00 56.20 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 60.89 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 65.58 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 70.26 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 74.95 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 79.64 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 84.33 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 89.01 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 93.70 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 0.00 98.39 0.00 17.39 19.90 0 0.000 0 0.000 0.000 0.00 98.48 5.02 26.91 79.14 82.73 1 0.021 0 0.000 0.021 (以下略...) 可以看到Eden(E)持续造对象，并且满了之后，老年代(O)增加，E区腾空后继续造对象。（程序多执行一段时间，或者造对象速度提快点，最终会抛出OOM） 查看存活对象1234567891011121314// 查看存活对象，可以看到排名第一的是byte数组，而且多观察会会发现其数量也是一直在增加➜ ~ jmap -histo:live 11618 num #instances #bytes class name---------------------------------------------- 1: 644 103949616 [B 2: 4342 416736 [C 3: 4326 103824 java.lang.String 4: 721 82056 java.lang.Class 5: 746 49224 [Ljava.lang.Object; 6: 738 29520 java.util.LinkedHashMap$Entry 7: 609 19488 java.util.HashMap$Node 8: 303 19392 java.net.URL 9: 303 13560 [Ljava.lang.String; 根据存活对象的不正常增长情况，分析程序中哪些地方用到了这种对象，也可以大致推断出可能的内存泄漏处。","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.github.io/tags/jvm/"},{"name":"oom","slug":"oom","permalink":"https://acupt.github.io/tags/oom/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"JAVA GC 简析","slug":"interview-gc","date":"2019-07-15T15:00:00.000Z","updated":"2019-07-16T13:47:33.758Z","comments":true,"path":"2019/07/15/interview-gc/","link":"","permalink":"https://acupt.github.io/2019/07/15/interview-gc/","excerpt":"","text":"作为一个落魄的JAVA开发，在面试中常被问道：你是什么垃圾？哦不，是你对JAVA的垃圾回收机制有了解吗？ 接下来就对GC做一个全方位的总结，希望下次可以自信地回答面试官：我是可以被贵公司回收的那种。 GC的时机首先，根据内存区域不同，JVM工作模式不同，GC也有一些差别。 新生代（minor GC/young GC） PS: 新生代的内存空间可分为3个，Eden区(产生新生命的伊甸园)，from区和to区（GC时倒腾对象用的两个盘子） 当JVM无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以如果程序疯狂造对象，就会频繁触发GC。 老年代/永久代（major GC）/整个堆（full GC） 当一个对象经历了太多GC而不死，它会突破旧规则的束缚，飞升到老年代/永久代，成为新的存在，但并不代表着它可以不死，没有谁可以不死，尤其是新的地方也缺少资源的时候。而Major GC通常是跟full GC是等价的，收集整个GC堆。 升到永久代的对象大于永久代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc。 其它GC时机： 在程序中调用System.gc()函数，建议JVM做GC（注意只是建议，JVM有权无视程序猿的建议） 调参控制进入老年代/永久代的年龄（如果我记得肯定会写出来的，没搜，懒得搜） OOM之前（在放弃治疗抛出异常前总要做最后的努力吧） GC的目标 - 不使用的对象 当然是不使用的对象，还在使用的对象给回收了谁知道程序会跑成什么样子 那么什么是不使用的对象呢？ 超出作用域的对象/引用计数为空 引用计数法: 有人引用+1，被人抛弃-1。 优点：一旦没有引用即可释放内存，不需要等待特定时机，回收的时机也比较平均。 缺点：维护计数消耗资源（但问题不大），循环引用（大） 可达性分析，有gc root无法到达的对象 通过一系列称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，无法到达的对象就是没用的。可以被当做root的对象，如：线程对象、本地变量、全局变量等。 这里又引入了引用的概念，强度从强到弱依次如下： 强引用：最常见的如 Object a = new Object()，即使OOM也不回收 软引用（SoftReference）：内存不够时回收 弱引用（WeakReference）：正常gc，被扫描到就回收 幻想引用（PhantomReference）：不可以获取/复活对象, 在垃圾回收时得到通知 GC的行为简单的说就是删除对象，回收空间。根据算法不同，具体的行为也有所不同，快没电了，就不写了（主要也没准备） 举个栗子： 1、停止其他线程，标记对象2、清理对象2.1、新生代-复制清理： Eden和from的存活对象复制到to，然后from和to交换，存活对象年龄+1，年龄到达阈值进入老年代/永久代2.2、老年代-标记清理/整理： 标记清理速度快，但有内存碎片 标记整理会移动存活对象，排除内存碎片","categories":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://acupt.github.io/tags/jvm/"},{"name":"gc","slug":"gc","permalink":"https://acupt.github.io/tags/gc/"}],"keywords":[{"name":"面试杂谈","slug":"面试杂谈","permalink":"https://acupt.github.io/categories/面试杂谈/"}]},{"title":"从0.5到1写个rpc框架 - 7:网关支持(gateway)","slug":"acuprpc-7","date":"2019-07-13T08:15:00.000Z","updated":"2019-07-13T08:39:29.148Z","comments":true,"path":"2019/07/13/acuprpc-7/","link":"","permalink":"https://acupt.github.io/2019/07/13/acuprpc-7/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 微服务除了在内部相互调用，有时某些服务也会提供给外部应用。当然不能让外部应用也加入到“大家庭”里，毕竟知人知面不知源码，我们可以派出一个“前台”去接待它们，这就是“网关”。 网关负责对接外部来宾，因此要做好安全措施，什么登陆、权限该上就上。 流程如下： 网关收到请求 解析请求（服务名，方法，参数等） 选择一个实例（来自注册中心） RPC调用 结果返回给请求方 1234567891011121314151617181920212223242526@RestController@RequestMapping(\"/api\")public class ApiController &#123; /** * 动态调用rpc服务的关键，在acuprpc-spring-boot-starter中已经生成，可以随时引用 */ private RpcClientManager rpcClientManager; public ApiController(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @RequestMapping(method = RequestMethod.POST, produces = \"application/json\") public Object invoke(@RequestBody RpcRequestDTO requestDTO) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(requestDTO.getApp(), requestDTO.getService()); RpcClient client = rpcClientManager.lookup(serviceInfo);//获取一个可以提供所需服务的连接 RpcRequest request = new RpcRequest(requestDTO.getApp(), requestDTO.getService(), requestDTO.getMethod()); if (requestDTO.getParameters() != null) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); requestDTO.getParameters().forEach((k, v) -&gt; map.put(k, JsonUtil.toJson(v))); request.setNamedParameter(map); &#125; return client.invoke(request);//调用服务获得返回的json字符串 &#125;&#125; 这个demo作为一个子模块（acuprpc-spring-boot-starter-gateway）加入了框架的全家桶，直接引入依赖就能使用这个功能。 基于这个方法，可以实现更加复杂的也无需求，这里就不细讲了，本系列结束。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 6:调用异常节点自动重试","slug":"acuprpc-6","date":"2019-07-13T07:00:00.000Z","updated":"2019-07-13T08:16:36.330Z","comments":true,"path":"2019/07/13/acuprpc-6/","link":"","permalink":"https://acupt.github.io/2019/07/13/acuprpc-6/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc eureka client每隔30s向注册中心发送心跳来给自己续命，当注册中心长时间没收到client的信号，就会认为它挂掉了，把它提出群聊。再加上其它服务也按照一定频率更新本地缓存，因此往往不会那么及时地发现曾经的小伙伴已经下线了。导致的后果就是，会向不再存在的节点发送请求，结果连接异常。 对此，我们可以从框架层面加入一个重试机制，spring里面类似的机制也有，但既然在写自己的框架，那就自己实现一个。 在第一章里已经实现了通过动态代理执行远程调用，那么直接从这里入手，通过判断捕获的异常来判断是否需要重试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Override public Object invoke(Object proxy, Method method, Object[] args) &#123; if (\"toString\".equals(method.getName()) &amp;&amp; (args == null || args.length == 0)) &#123; return rpcServiceInfo.toString();//debug时老是被ide调用然后抛异常，很烦 &#125; RpcRequest rpcRequest = new RpcRequest(rpcServiceInfo.getAppName(), rpcServiceInfo.getServiceName(), method.getName()); if (args != null &amp;&amp; args.length &gt; 0) &#123; rpcRequest.setOrderedParameter(Arrays.stream(args).map(JsonUtil::toJson).collect(Collectors.toList())); &#125; int n = 3; // 最多重试3次，改成可配置的更好 int i = 0; RpcClient client = null; while (i++ &lt; n) &#123; try &#123; client = getRpcClient(); String res = client.invoke(rpcRequest); return JsonUtil.fromJson(res, TypeFactory.defaultInstance().constructType(method.getGenericReturnType())); &#125; catch (Exception e) &#123; if (client == null) &#123; throw e; &#125; boolean rediscover = needRediscover(e) &amp;&amp; i &lt; n; log.error(\"invoke &#123;&#125;/&#123;&#125; &#123;&#125; &#123;&#125; error=&#123;&#125; msg=&#123;&#125; rediscover=&#123;&#125;\", i, n, rpcRequest.getKey(), client.getNodeInfo(), e.getClass().getName(), e.getMessage(), rediscover); if (rediscover) &#123; try &#123; NodeInfo nodeInfo = rpcClientManager.selectNode(rpcServiceInfo, client.getNodeInfo()); client.reconnect(nodeInfo); continue; &#125; catch (RpcNotFoundException e1) &#123; e.addSuppressed(e1); &#125; &#125; throw e; &#125; &#125; throw new RuntimeException(\"invoke error\"); &#125; /** * 根据异常类型判断是否需要换个实例 */ private boolean needRediscover(Throwable e) &#123; while (e != null) &#123; if (e instanceof HttpStatusException) &#123; // 我自定义的异常类型，这里如果是服务不可用（程序虽然正常但不再提供服务） if (((HttpStatusException) e).getStatus() == NOT_AVAILABLE) &#123; return true; &#125; &#125; else if (e instanceof ConnectException) &#123; // 连接异常，想必是不在了 return true; &#125; e = e.getCause(); &#125; return false; &#125; 有了重试机制，就不怕某些家伙突然掉链子了，当然如果全部掉链子那就没得玩了。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 5:服务监控和管理(actuator)","slug":"acuprpc-5","date":"2018-11-29T06:00:00.000Z","updated":"2019-07-11T14:13:43.500Z","comments":true,"path":"2018/11/29/acuprpc-5/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-5/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc springboot项目中只要引入spring-boot-starter-actuator就可以得到一些管理服务的接口，比如停止服务，获取服务信息等。他用的并不是controller，而是Endpoint，不过主要功能差不多。 借住上节实现的filter机制，可以在不改动框架核心代码的基础上实现这个功能。作为实践写两个功能：获取服务端的统计数据、服务状态控制 新建模块 acuprpc-spring-boot-starter-actuator。 为了统一管理这个框架的endpoint，定义一个父类。所有子类的id默认加上“rpc”前缀 12345678910111213public abstract class AbstractRpcEndpoint&lt;T&gt; extends AbstractEndpoint&lt;T&gt; &#123; private static final String PREFIX = \"rpc\"; public AbstractRpcEndpoint(String id) &#123; super(PREFIX + id); &#125; public AbstractRpcEndpoint(String id, boolean sensitive) &#123; super(PREFIX + id, sensitive); &#125; public AbstractRpcEndpoint(String id, boolean sensitive, boolean enabled) &#123; super(PREFIX + id, sensitive, enabled); &#125;&#125; 数据统计MonitorFilter使用filter拦截请求，统计处理请求的数量。 12345678910111213141516171819202122232425262728293031323334@Getterpublic class MonitorFilter implements RpcFilter &#123; private Map&lt;String, RequestCount&gt; requestCountMap = new ConcurrentHashMap&lt;&gt;(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; RequestCount count = requestCountMap.computeIfAbsent(request.getKey(), RequestCount::new); count.received.increment(); count.invoking.increment(); try &#123; filterChain.doFilter(request, response); count.success.increment(); &#125; catch (Exception e) &#123; count.failed.increment(); throw e; &#125; finally &#123; count.invoking.decrement(); &#125; &#125; @Getter public static class RequestCount &#123; private String key; private LongAdder received = new LongAdder();//已接收 private LongAdder invoking = new LongAdder();//执行中 private LongAdder success = new LongAdder();//处理成功 private LongAdder failed = new LongAdder();//处理失败 public RequestCount(String key) &#123; this.key = key; &#125; &#125;&#125; RpcStatEndpoint提供http接口，通过 /rpcstat 即可获取invoke()的返回值。 1234567891011121314151617public class RpcStatEndpoint extends AbstractRpcEndpoint&lt;Map&lt;String, Object&gt;&gt; &#123; private MonitorFilter filter; public RpcStatEndpoint(MonitorFilter filter) &#123; super(\"stat\"); this.filter = filter; &#125; @Override public Map&lt;String, Object&gt; invoke() &#123; Map&lt;String, Object&gt; result = new HashMap&lt;&gt;(); Collection&lt;MonitorFilter.RequestCount&gt; counts = filter.getRequestCountMap().values(); result.put(\"counts\", counts); result.put(\"serving\", counts.stream().anyMatch(t -&gt; t.getInvoking().sum() &gt; 0L)); return result; &#125;&#125; 服务管理RejectFilter使用filter拦截请求，并在filter中维护一个下线状态，如果下线了则拒绝所有请求（针对这种返回值，客户端可以重新发现其他节点）。 123456789101112131415@Datapublic class RejectFilter implements RpcFilter &#123; private boolean reject = false; //拒绝请求的处理逻辑也可以自定义 private BiConsumer&lt;RpcRequest, RpcResponse&gt; rejectFunction = (rpcRequest, response) -&gt; response.reject(); @Override public void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain) &#123; if (reject) &#123; rejectFunction.accept(request, response); return; &#125; filterChain.doFilter(request, response); &#125;&#125; EndpointMvcAdapterEndpoint使用很方便，但是相对controller不是那么灵活，比如我要让接口支持参数，就需要一些其他操作，将Endpoint使用EndpointMvcAdapter包装一次。为了复用，我写了个通用的EndpointMvcAdapter，通过反射去调用参数指定的方法。 1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class ReflectEndpointMvcAdapter extends EndpointMvcAdapter implements RpcCode &#123; private Map&lt;String, Method&gt; methodMap = new HashMap&lt;&gt;(); private Set&lt;String&gt; ipWhiteList = new HashSet&lt;&gt;(); public ReflectEndpointMvcAdapter(Endpoint&lt;?&gt; delegate, String ipWhiteList) &#123; super(delegate); Method[] methods = delegate.getClass().getMethods(); //... &#125; @RequestMapping(value = \"/&#123;name:.*&#125;\", method = RequestMethod.GET, produces = &#123; ActuatorMediaTypes.APPLICATION_ACTUATOR_V1_JSON_VALUE, MediaType.APPLICATION_JSON_VALUE &#125;) @ResponseBody @HypermediaDisabled public Object invoke(HttpServletRequest request, HttpServletResponse response, @PathVariable String name) &#123; if (!checkIp(request)) &#123; //... &#125; Method method = methodMap.get(name); //... try &#123; return method.invoke(getDelegate()); &#125; catch (Exception e) &#123; //... &#125; &#125; private boolean checkIp(HttpServletRequest request) &#123; //... &#125; private String getIp(HttpServletRequest request) &#123; //... &#125;&#125; RpcEndpoint因为要用ReflectEndpointMvcAdapter，invoke方法暂时没想到用什么（ /rpc 时调用），就返回null。 1234567891011121314151617181920212223242526272829public class RpcEndpoint extends AbstractRpcEndpoint&lt;Object&gt; implements RpcCode &#123; private RejectFilter filter; public RpcEndpoint(RejectFilter filter) &#123; super(\"\"); this.filter = filter; &#125; @Override public Object invoke() &#123; return null; &#125; public void online() &#123; filter.setReject(false); &#125; public void offline() &#123; filter.setReject(true); &#125; public int status() &#123; if (filter.isReject()) &#123; throw new HttpStatusException(NOT_AVAILABLE); &#125; return 0; &#125;&#125; 定义bean时包装 123456789@Beanpublic ReflectEndpointMvcAdapter rpcEndpoint(RejectFilter rejectFilter) &#123; return new ReflectEndpointMvcAdapter(process(new RpcEndpoint(rejectFilter)), ipWhiteList);&#125;private &lt;T extends AbstractRpcEndpoint&lt;?&gt;&gt; T process(T endpoint) &#123; endpoint.setSensitive(sensitive); return endpoint;&#125; 现在只要引入acuprpc-spring-boot-starter-actuator就能得到这几个http接口了，借助这几个接口服务可以优雅地重发。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"actuator","slug":"actuator","permalink":"https://acupt.github.io/tags/actuator/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 4:request filter","slug":"acuprpc-4","date":"2018-11-29T05:00:00.000Z","updated":"2019-07-11T14:13:38.714Z","comments":true,"path":"2018/11/29/acuprpc-4/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-4/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 为了后续扩展方便，搞个filter支持，就抄一个servlet的filter吧。 servlet filter 分析在写mvc项目时，经常会用到filter，可以给一个请求做前置或者后置处理。如下： 1234567891011121314151617181920@WebFilter(filterName = \"requestFilter\", urlPatterns = \"/*\")public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(\"filter init\"); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(\"我进来了\"); chain.doFilter(request, response); System.out.println(\"我要走了\"); &#125; @Override public void destroy() &#123; System.out.println(\"filter destroy\"); &#125;&#125; 这是一种责任链模式的实现，debug看下调用栈可以了解框架是怎么实现的。 每次请求生成一个FilterChain对象，并使其持有所有filter的数组，初始化成员变量pos=0（表示应该执行第几个filter） 从FilterChain.doFilter开始调用整个链路，从第一个filter开始，调用时会把chain本身传给filter，pos自增 某个filter如果不拦截这个请求，则调用FilterChain.doFilter，由于pos已经自增，则会调用下一个filter filter全部调用后（pos=filters.length）,开始真正执行请求 请求返回后会依次再经过之前经过的所有filter（倒序） rpc filter 实现定义filter接口，使用者如果要添加过滤逻辑需要集成这个接口。 123public interface RpcFilter &#123; void doFilter(RpcRequest request, RpcResponse response, RpcFilterChain filterChain);&#125; filter持有者 1234567891011121314151617181920212223242526272829public class RpcFilterChain implements RpcCode &#123; private RpcFilter[] filters = new RpcFilter[0]; private int pos; private RpcServiceInfo serviceInfo; private RpcServiceExecutor serviceExecutor;//最终要执行请求的处理器 public RpcFilterChain(List&lt;RpcFilter&gt; filterList, RpcServiceInfo serviceInfo, RpcServiceExecutor serviceExecutor) &#123; if (filterList != null &amp;&amp; !filterList.isEmpty()) &#123; this.filters = new RpcFilter[filterList.size()]; this.filters = filterList.toArray(this.filters); &#125; this.serviceInfo = serviceInfo; this.serviceExecutor = serviceExecutor; &#125; public void doFilter(RpcRequest request, RpcResponse response) &#123; if (pos &lt; filters.length) &#123; RpcFilter filter = filters[pos++]; filter.doFilter(request, response, this); return; &#125; if (serviceExecutor == null) &#123; response.error(SERVICE_NOT_FOUND, \"service not exist: \" + serviceInfo); return; &#125; serviceExecutor.execute(request, response); &#125;&#125; rpc server 接收到请求后先初始化一个责任链，然后触发。 1234567891011public RpcResponse execute(RpcRequest rpcRequest) &#123; RpcServiceInfo rpcServiceInfo = new RpcServiceInfo(rpcRequest.getAppName(), rpcRequest.getServiceName()); RpcFilterChain chain = new RpcFilterChain(filters, rpcServiceInfo, serviceExecutorMap.get(rpcServiceInfo)); RpcResponse rpcResponse = new RpcResponse(); try &#123; chain.doFilter(rpcRequest, rpcResponse); &#125; catch (Exception e) &#123; rpcResponse.error(e); &#125; return rpcResponse;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"filter","slug":"filter","permalink":"https://acupt.github.io/tags/filter/"},{"name":"责任链","slug":"责任链","permalink":"https://acupt.github.io/tags/责任链/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 3:远程服务调用(thrift)","slug":"acuprpc-3","date":"2018-11-29T04:00:00.000Z","updated":"2019-07-11T14:13:32.202Z","comments":true,"path":"2018/11/29/acuprpc-3/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-3/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc thrift是Facebook开源的rpc框架，基于TPC，默认使用二进制。 需要先掌握thrift的基本用法: thrift-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-thrift //基于thrift实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 thrift 通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 resources/service.thrift 123456789101112131415161718namespace java com.acupt.acuprpc.protocol.thrift.protoservice ThriftService&#123; InvokeResponse invokeMethod(1:InvokeRequest invokeRequest)&#125;struct InvokeRequest&#123;1: required string appName;2: required string serviceName;3: required string methodName;4: required list&lt;string&gt; orderedParameter;5: required map&lt;string,string&gt; namedParameter;&#125;struct InvokeResponse&#123;1: required i32 code;2: optional string message;3: optional string result;&#125; thrift-service这个类负责接收 thrift-client 发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给 thrift-client。 123456789101112131415161718192021222324public class ThriftService implements com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface &#123; private RpcServer rpcServer; public ThriftService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public InvokeResponse invokeMethod(InvokeRequest invokeRequest) &#123; RpcRequest rpcRequest = new RpcRequest( invokeRequest.getAppName(), invokeRequest.getServiceName(), invokeRequest.getMethodName(), invokeRequest.getOrderedParameter(), invokeRequest.getNamedParameter()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = new InvokeResponse(); response.setCode(rpcResponse.getCode()); response.setMessage(rpcResponse.getMessage()); response.setResult(rpcResponse.getResultString()); return response; &#125;&#125; thrift-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 由于thrift server 调用serve()方法后会阻塞线程，因此需要另外启动一个线程去开启服务。 123456789101112131415161718192021222324252627282930313233public class ThriftServer extends RpcServer &#123; private static final int nThreads = 100; private TServer server; public ThriftServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @Override protected void startRpc() &#123; new Thread(() -&gt; &#123; TProcessor tprocessor = new com.acupt.acuprpc.protocol.thrift.proto.ThriftService. Processor&lt;com.acupt.acuprpc.protocol.thrift.proto.ThriftService.Iface&gt;(new ThriftService(this)); TServerTransport serverTransport = null; try &#123; serverTransport = new TServerSocket(getRpcInstance().getRpcConf().getPort()); &#125; catch (TTransportException e) &#123; throw new RpcException(e); &#125; TThreadPoolServer.Args tArgs = new TThreadPoolServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.executorService(Executors.newFixedThreadPool(nThreads)); server = new TThreadPoolServer(tArgs); server.serve();//阻塞 &#125;).start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.setShouldStop(true); &#125; &#125;&#125; thrift-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成thrift支持的结构，并调用thrift的请求方法，再把远程服务返回的结果返回给代理类。 thrift client 是线程不安全的，从它提供的方法就能够看出来。 12345678910111213public void send_invokeMethod(InvokeRequest invokeRequest)&#123; //...&#125;public InvokeResponse recv_invokeMethod()&#123; //...&#125;public InvokeResponse invokeMethod(InvokeRequest invokeRequest) throws org.apache.thrift.TException&#123; send_invokeMethod(invokeRequest); return recv_invokeMethod();&#125; 为了简单直接在把方法设为 synchronized ，后续再使用对象池 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ThriftClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;ThriftService.Client&gt; clientRef; public ThriftClient(NodeInfo nodeInfo) &#123; super(nodeInfo); clientRef = new AtomicReference&lt;&gt;(getClient(nodeInfo)); &#125; //todo client线程不安全，使用连接池管理 @Override @SneakyThrows protected synchronized String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest request = new InvokeRequest(); request.setAppName(rpcRequest.getAppName()); request.setServiceName(rpcRequest.getServiceName()); request.setMethodName(rpcRequest.getMethodName()); request.setOrderedParameter(rpcRequest.getOrderedParameter()); InvokeResponse response = clientRef.get().invokeMethod(request); if (response.getCode() != SUCCESS) &#123; throw new HttpStatusException(response.getCode(), response.getMessage()); &#125; return response.getResult(); &#125; @Override protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //... &#125; @Override public void shutdownRpc() &#123; close(clientRef.get()); &#125; private ThriftService.Client getClient(NodeInfo nodeInfo) &#123; //... &#125; private void close(ThriftService.Client client) &#123; //... &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 2:远程服务调用(grpc)","slug":"acuprpc-2","date":"2018-11-29T03:00:00.000Z","updated":"2019-07-11T14:13:29.401Z","comments":true,"path":"2018/11/29/acuprpc-2/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-2/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc gRPC是Google开源的跨语言远程服务调用(RPC)框架，通信协议用的HTTP/2，数据传输默认用的protocol buffers（一种轻便高效的结构化数据存储格式，想比json更小更快，不过没有可读性）。 需要先掌握grpc的基本用法: gRPC-Java 示例 项目结构1234- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-protocol-grpc //基于grpc实现远程调用 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 grpc通信接口定义定义服务提供者（server）和服务调用者（client）交流所用的数据结构，client需要告诉server要调用的类名、方法名以及参数（json格式的字符串，在server端再反序列化）。 1234567891011121314151617181920212223242526syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.acuprpc.protocol.grpc.proto\";option java_outer_classname = \"GrpcServiceProto\";package com.acupt.acuprpc.protocol.grpc.proto;service GrpcService &#123; rpc invokeMethod (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string appName = 1; string serviceName = 2; string methodName = 3; repeated string orderedParameter = 4; map&lt;string, string&gt; namedParameter = 5;&#125;message InvokeResponse &#123; int32 code = 1; string message = 2; string result = 3;&#125; grpc-service这个类负责接收grpc-client发过来的请求，取出请求中的参数，转换成通用的结构，交给core层的RpcServer去执行对应方法，然后将返回值序列化成json返回给grpc-client。 1234567891011121314151617181920212223242526public class GrpcService extends GrpcServiceGrpc.GrpcServiceImplBase &#123; private RpcServer rpcServer; public GrpcService(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void invokeMethod(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; RpcRequest rpcRequest = new RpcRequest( request.getAppName(), request.getServiceName(), request.getMethodName(), request.getOrderedParameterList(), request.getNamedParameterMap()); RpcResponse rpcResponse = rpcServer.execute(rpcRequest); InvokeResponse response = InvokeResponse.newBuilder() .setCode(rpcResponse.getCode()) .setMessage(rpcResponse.getMessage()) .setResult(rpcResponse.getResultString()) .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; grpc-server作物服务提供者的具体实现类，只需要实现两个方法：启动服务和关闭服务，其他的交给core层的父类即可。 123456789101112131415161718192021222324public class GrpcServer extends RpcServer &#123; private Server server; public GrpcServer(RpcInstance rpcInstance) &#123; super(rpcInstance); &#125; @SneakyThrows @Override protected void startRpc() &#123; server = ServerBuilder .forPort(getRpcInstance().getRpcConf().getPort()) .addService(new GrpcService(this)) .build().start(); &#125; @Override protected void shutdownRpc() &#123; if (server != null) &#123; server.shutdown(); &#125; &#125;&#125; grpc-client作为服务调用者，需要把\b动态代理类传来的请求信息包装成grpc支持的结构，并调用grpc的请求方法，再把远程服务返回的结果返回给代理类。 12345678910111213141516171819202122232425262728293031323334353637public class GrpcClient extends RpcClient implements RpcCode &#123; private AtomicReference&lt;GrpcServiceGrpc.GrpcServiceFutureStub&gt; stubRef; public GrpcClient(NodeInfo nodeInfo) &#123; super(nodeInfo); this.stubRef = new AtomicReference&lt;&gt;(getStub(nodeInfo)); &#125; @Override protected String remoteInvoke(RpcRequest rpcRequest) &#123; InvokeRequest.Builder builder = InvokeRequest.newBuilder() .setAppName(rpcRequest.getAppName()) .setServiceName(rpcRequest.getServiceName()) .setMethodName(rpcRequest.getMethodName()); // ... ListenableFuture&lt;InvokeResponse&gt; future = stubRef.get().invokeMethod(builder.build()); InvokeResponse response = null; //... return response.getResult(); &#125; @Override @SneakyThrows protected NodeInfo reconnectRpc(NodeInfo nodeInfo) &#123; //...使用参数中的ip和端口建立新连接，并断开老的连接，可用于重新负载和异常节点重试 &#125; @Override @SneakyThrows public void shutdownRpc() &#123; //...主动断开和服务端的连接 &#125; private GrpcServiceGrpc.GrpcServiceFutureStub getStub(NodeInfo nodeInfo) &#123; //...和服务端建立连接，使用参数中的ip和端口 &#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 1:服务注册/发现(eureka)","slug":"acuprpc-1","date":"2018-11-29T02:00:00.000Z","updated":"2019-07-11T14:13:22.585Z","comments":true,"path":"2018/11/29/acuprpc-1/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-1/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 123- acuprpc + acuprpc-core //server/client核心处理逻辑 + acuprpc-spring-boot-starter //server端服务扫描，client端动态代理，\b服务注册/发现 Eureka Serverspring-cloud-starter-eureka-server Eureka Client原理就是利用eureka提供的客户端类来向Eureka Server发送注册请求，把自己提供服务的地址和端口（rpc服务端口，不是springboot启动的\bhttp端口）告诉注册中心，这样其他客户端（包括自身）就可以请求Eureka Server获取需要的服务节点信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 在服务中心注册的实例 */@Getter@Slf4jpublic class RpcInstance &#123; private EurekaClient eurekaClient; private ApplicationInfoManager applicationInfoManager; private RpcConf rpcConf; public RpcInstance(RpcConf rpcConf) &#123; RpcEurekaInstanceConfig instanceConfig = new RpcEurekaInstanceConfig(); instanceConfig.setAppGroupName(rpcConf.getAppGroup()); instanceConfig.setAppname(rpcConf.getAppName()); instanceConfig.setNonSecurePort(rpcConf.getPort()); instanceConfig.setIpAddress(IpUtil.INTRANET_IP); instanceConfig.setHostname(IpUtil.HOSTNAME); RpcEurekaClientConfig clientConfig = new RpcEurekaClientConfig(); clientConfig.getServiceUrl().put(\"default\", rpcConf.getDiscoveryServiceUrl()); clientConfig.setRegisterWithEureka(rpcConf.isRegisterWithDiscovery()); InstanceInfo instanceInfo = new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get(); this.applicationInfoManager = new ApplicationInfoManager(instanceConfig, instanceInfo); this.eurekaClient = new DiscoveryClient(applicationInfoManager, clientConfig); this.rpcConf = rpcConf; log.info(\"protocol server -&gt; \" + rpcConf.getRpcServerClass()); log.info(\"protocol client -&gt; \" + rpcConf.getRpcClientClass()); &#125; public void start() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.STARTING); &#125; public void started() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.UP); &#125; public void shutdown() &#123; applicationInfoManager.setInstanceStatus(InstanceInfo.InstanceStatus.DOWN); eurekaClient.shutdown(); &#125; /** * 创建一个rpc server，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcServer newRpcServer() &#123; return rpcConf.getRpcServerClass().getConstructor(RpcInstance.class).newInstance(this); &#125; /** * 创建一个rpc client，根据配置的调用方式（实现类）生成对象 */ @SneakyThrows public RpcClient newRpcClient(NodeInfo nodeInfo) &#123; return rpcConf.getRpcClientClass().getConstructor(NodeInfo.class).newInstance(nodeInfo); &#125;&#125; starter构建一个自己的spring boot starter，这样别的项目只需要引入这个依赖，就能使用starter提供的服务了。 1234- resources - META-INF spring.factories // 定义@Configuration类的路径，有了这个声明依赖starter的项目就能获得starter中提供的bean spring-configuration-metadata.json // 配置信息（可选），有了它在IDE中编辑application配置文件可以看到提示信息 rpc server 服务管理作为rpc服务提供者，需要在应用启动时把有注解（@Rpc）的服务管理起来，这样接收到rpc请求后可以快速查询到指定对象，执行指定方法。 实现接口BeanPostProcessor的bean即可得到处理spring中的所有bean（每个bean初始化完成后会调用接口方法）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RpcServiceScanner implements BeanPostProcessor &#123; private RpcServer rpcServer; public RpcServiceScanner(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // AOP代理类需要拿到原始的类，不然读不到类上的注解 Class&lt;?&gt; beanClass = AopUtils.isAopProxy(bean) ? AopUtils.getTargetClass(bean) : bean.getClass(); val nrpc = beanClass.getAnnotation(Rpc.class); if (nrpc == null) &#123; return bean; &#125; Method[] methods = beanClass.getDeclaredMethods(); if (methods.length == 0) &#123; return bean; &#125; Map&lt;String, MethodInfo&gt; methodInfoMap = new HashMap&lt;&gt;(); for (Method method : methods) &#123; methodInfoMap.put(method.getName(), new MethodInfo(method)); &#125; Class&lt;?&gt;[] interfaces = beanClass.getInterfaces(); if (interfaces.length == 0) &#123; return bean; &#125; // client是通过接口调用server的，因此并不知道具体实现类的路径，只有接口名，因此把所有接口都注册一遍 for (Class&lt;?&gt; serviceInterface : interfaces) &#123; rpcServer.registerService( new RpcServiceInfo(rpcServer.getRpcInstance().getRpcConf().getAppName(), serviceInterface.getCanonicalName()), bean, serviceInterface, methodInfoMap); &#125; return bean; &#125;&#125; rpc client 远程服务代理作为服务调用者，可以通过接口像调用本地代码一样调用远程服务，原理就是为接口创建一个代理，在代理中进行远程调用。 这里使用主动创建代理的方式。 1234567891011121314151617public class RpcServiceConsumer &#123; private RpcClientManager rpcClientManager; public RpcServiceConsumer(RpcClientManager rpcClientManager) &#123; this.rpcClientManager = rpcClientManager; &#125; @SuppressWarnings(\"unchecked\") public &lt;T&gt; T create(String appName, Class&lt;T&gt; serviceInterface) &#123; RpcServiceInfo serviceInfo = new RpcServiceInfo(appName, serviceInterface.getCanonicalName()); return (T) Proxy.newProxyInstance( serviceInterface.getClassLoader(), new Class&lt;?&gt;[]&#123;serviceInterface&#125;, new RpcInvocationHandler(serviceInfo, rpcClientManager)); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class RpcInvocationHandler implements InvocationHandler &#123; private RpcServiceInfo rpcServiceInfo; private RpcServiceManager rpcServiceManager; private RpcClient rpcClient; public RpcInvocationHandler(RpcServiceInfo rpcServiceInfo, RpcServiceManager rpcServiceManager) &#123; this.rpcServiceInfo = rpcServiceInfo; this.rpcServiceManager = rpcServiceManager; tryInitRpcClient(false); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; RpcMethodInfo methodInfo = new RpcMethodInfo(rpcServiceInfo, method.getName(), method.getGenericReturnType()); return tryGetRpcClient().invoke(methodInfo, args); &#125; private RpcClient tryGetRpcClient() &#123; if (rpcClient == null) &#123; tryInitRpcClient(true); &#125; return rpcClient; &#125; private synchronized void tryInitRpcClient(boolean throwError) &#123; if (rpcClient != null) &#123; return; &#125; try &#123; rpcClient = rpcServiceManager.lookup(rpcServiceInfo); &#125; catch (Exception e) &#123; if (throwError) &#123; throw e; &#125; &#125; &#125;&#125; 注册一个ApplicationListener，接收springboot程序准备完后的信号，然后告诉注册中心准备好了。 12345678910111213public class RpcApplicationListener implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123; private RpcServer rpcServer; public RpcApplicationListener(RpcServer rpcServer) &#123; this.rpcServer = rpcServer; &#125; @Override public void onApplicationEvent(ApplicationReadyEvent event) &#123; rpcServer.started(); &#125;&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"从0.5到1写个rpc框架 - 0:前言","slug":"acuprpc-0","date":"2018-11-29T01:00:00.000Z","updated":"2019-07-13T08:15:53.021Z","comments":true,"path":"2018/11/29/acuprpc-0/","link":"","permalink":"https://acupt.github.io/2018/11/29/acuprpc-0/","excerpt":"","text":"这不是教程，只是个人总结，有兴趣的童鞋可以搭配源码看看：acuprpc 最近在新公司开始接触微服务，在此之前并没有微服务的开发经验。对比了spring cloud和公司的rpc框架，对微服务这套东西终于有了一点粗浅的认知，为了加深理解，自己动手写个rpc框架玩玩。顺便记录下来，不然玩过的东西过段时间就忘了。 我的spring cloud的入门读物: 史上最简单的 SpringCloud 教程 我的学习成果: acuprpc 设计方案总的来说就是在现有工具上的二次开发。 服务注册/发现: eureka 这个模块spring cloud已经集成的非常易用了，实在没兴趣再整些骚操作，引入spring-cloud-starter-eureka-server依赖，启动类加个注解@EnableEurekaServer就是一个注册中心了。 远程服务调用: grpc/thrift grpc是Google开源的rpc框架，thrift是Facebook开源的rpc框架，而且他们都支持跨语言，都是很厉害的东西，需要用它们的规则定义数据结构，\b每个\b服务都定义一次是挺累的，如果只定义一个通用的服务，然后在这个服务里面通过Java反射去执行对应方法就可以少很多工作量了（把工作量变成了Java代码编写）。 至于选择这两种，因为都想试试，所以最终设计rpc框架是可以切换通信方式的，把这部分抽出来做成可扩展的即可。 目录// 只要列出来，总有一天会写完。 从0.5到1写个rpc框架 - 1:服务注册/发现(eureka) 从0.5到1写个rpc框架 - 2:远程服务调用(grpc) 从0.5到1写个rpc框架 - 3:远程服务调用(thrift) 从0.5到1写个rpc框架 - 4:request filter 从0.5到1写个rpc框架 - 5:服务监控和管理(actuator) 从0.5到1写个rpc框架 - 6:调用异常节点自动重试 从0.5到1写个rpc框架 - 7:网关支持(gateway)","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/tags/微服务/"},{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"},{"name":"eureka","slug":"eureka","permalink":"https://acupt.github.io/tags/eureka/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"thrift-Java 示例","slug":"thrift-start","date":"2018-11-20T12:00:00.000Z","updated":"2018-11-20T12:05:26.055Z","comments":true,"path":"2018/11/20/thrift-start/","link":"","permalink":"https://acupt.github.io/2018/11/20/thrift-start/","excerpt":"","text":"安装thriftmac brew install thrift 安装完成检查 thrift –version 新建maven项目pom.xml 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;libthrift&lt;/artifactId&gt; &lt;version&gt;0.11.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt; &lt;artifactId&gt;thrift-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.10.0&lt;/version&gt; &lt;configuration&gt; &lt;thriftExecutable&gt;/usr/local/bin/thrift&lt;/thriftExecutable&gt; &lt;!--thrift安装路径--&gt; &lt;thriftSourceRoot&gt;src/main/resources&lt;/thriftSourceRoot&gt; &lt;!--thrift配置文件路径--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;thrift-sources&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 定义服务新建文件 src/main/resources/service.thrift 1234namespace java com.acupt.thritf.serviceservice HelloService&#123; string hello(1:string name)&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现thrift远程调用。 target/generated-sources/thrift/com/acupt/thritf/service/HelloService.java 如果在项目中无法直接引用上面的类，IDEA右键\bthrift文件夹 -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 123456789101112131415package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TException;/** * 服务实现类 */public class HelloServiceImpl implements HelloService.Iface &#123; @Override public String hello(String name) throws TException &#123; return \"hello,\" + name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.TProcessor;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.server.TServer;import org.apache.thrift.server.TSimpleServer;import org.apache.thrift.transport.TServerSocket;/** * 服务提供方 */public class MyServer &#123; public static void main(String args[]) &#123; try &#123; TProcessor tprocessor = new HelloService.Processor&lt;HelloService.Iface&gt;(new HelloServiceImpl()); TServerSocket serverTransport = new TServerSocket(50005); TServer.Args tArgs = new TServer.Args(serverTransport); tArgs.processor(tprocessor); tArgs.protocolFactory(new TBinaryProtocol.Factory()); TServer server = new TSimpleServer(tArgs); System.out.println(\"server starting\"); //定时关闭 new Thread(() -&gt; &#123; try &#123; System.out.println(\"server wait stop\"); Thread.sleep(30000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"server stopping\"); server.stop(); System.out.println(\"server stop\"); &#125;).start(); server.serve();//会阻塞 System.out.println(\"server finish\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.acupt.thrift;import com.acupt.thritf.service.HelloService;import org.apache.thrift.protocol.TBinaryProtocol;import org.apache.thrift.protocol.TProtocol;import org.apache.thrift.transport.TSocket;import org.apache.thrift.transport.TTransport;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; TTransport transport = null; try &#123; transport = new TSocket(\"localhost\", 50005); TProtocol protocol = new TBinaryProtocol(transport); HelloService.Client client = new HelloService.Client(protocol); transport.open(); String result = client.hello(\"tom\"); System.out.println(result); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (null != transport) &#123; transport.close(); &#125; &#125; &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient。 和grpc用法\b差不多，gRPC-Java 示例","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"thrift","slug":"thrift","permalink":"https://acupt.github.io/tags/thrift/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"spring rabbitmq 异常重试源码分析","slug":"spring-rabbitmq-retry","date":"2018-11-15T03:00:00.000Z","updated":"2019-07-12T14:14:55.510Z","comments":true,"path":"2018/11/15/spring-rabbitmq-retry/","link":"","permalink":"https://acupt.github.io/2018/11/15/spring-rabbitmq-retry/","excerpt":"","text":"springboot集成rabbitMQ\b发消息123456789@Resourceprivate RabbitTemplate rabbitTemplate;@Value(\"$&#123;my.exchange&#125;\")private String exchange;public void send(Object obj) &#123; rabbitTemplate.convertAndSend(exchange, \"\", JsonUtils.toJson(obj));&#125; 处理消息1234@RabbitListener(queues = \"$&#123;msg.queue.my.exchange&#125;\")public void receive(String msg) &#123; //...&#125; 默认情况下，如果处理消息时抛出了异常，这个消息会一直重复消费（重复调用receive方法），直到没有抛异常。 消息接收/处理流程分析在@RabbitListener注解的方法里打个断点，观察下调用栈。 末端是个实现了Runnable的内部类SimpleMessageListenerContainer$AsyncMessageProcessingConsumer 123456789101112@Overridepublic void run() &#123; //…… //从这里可以看出只要这个消费者（consumer）状态满足会一直轮询去接收消息和消费消息 while (isActive(this.consumer) || this.consumer.hasDelivery() || !this.consumer.cancelled()) &#123; try &#123; boolean receivedOk = receiveAndExecute(this.consumer); // At least one message received //…… &#125; //…… &#125;&#125; 12345678910111213141516171819202122232425private boolean doReceiveAndExecute(BlockingQueueConsumer consumer) throws Throwable &#123; //NOSONAR Channel channel = consumer.getChannel(); for (int i = 0; i &lt; this.txSize; i++) &#123; logger.trace(\"Waiting for message from consumer.\"); Message message = consumer.nextMessage(this.receiveTimeout); if (message == null) &#123;break;&#125; try &#123; //如果获取到了消息就会去消费，这里最终会执行到我们写的listener方法 executeListener(channel, message); &#125; //当我们写的方法抛异常的时候就会来到这里 //发现嫌疑代码：consumer.rollbackOnExceptionIfNecessary(ex) catch (ImmediateAcknowledgeAmqpException e) &#123;/*……*/&#125; catch (Throwable ex) &#123; //NOSONAR if (causeChainHasImmediateAcknowledgeAmqpException(ex)) &#123;/*……*/&#125; if (this.transactionManager != null) &#123;/*没开事务，忽略*/&#125; else &#123; consumer.rollbackOnExceptionIfNecessary(ex); throw ex; &#125; &#125; &#125; return consumer.commitIfNecessary(isChannelLocallyTransacted(channel));&#125; 12345678910111213141516171819202122public void rollbackOnExceptionIfNecessary(Throwable ex) throws Exception &#123; boolean ackRequired = !this.acknowledgeMode.isAutoAck() &amp;&amp; !this.acknowledgeMode.isManual(); try &#123; if (this.transactional) &#123;/*……*/&#125; if (ackRequired) &#123; boolean shouldRequeue = RabbitUtils.shouldRequeue(this.defaultRequeuRejected, ex, logger); for (Long deliveryTag : this.deliveryTags) &#123; // 最终会执行到这里 // With newer RabbitMQ brokers could use basicNack here... this.channel.basicReject(deliveryTag, shouldRequeue); &#125; if (this.transactional) &#123;/*……*/&#125; &#125; &#125; catch (Exception e) &#123; logger.error(\"Application exception overridden by rollback exception\", ex); throw e; &#125; finally &#123; this.deliveryTags.clear(); &#125;&#125; 由上可看出，导致无限重试的两个值： ackRequired: 和ack模式相关 shouldRequeue: 和defaultRequeuRejected以及抛出的异常类型有关 根据需要修改acknowledgeMode或者defaultRequeuRejected即可，在配置文件中根据IDE补全提示可以找到这两个属性。 12spring.rabbitmq.listener.acknowledge-mode=nonespring.rabbitmq.listener.default-requeue-rejected=false 如果只是不想异常时重试，直接在业务代码中try…catch全部代码不让抛异常也行。 PS：验证这两个配置的时候发现不生效，一番debug发现项目里面自定义了一个工厂bean，创建消费者相关对象时用的那个工厂bean，而不是根据配置属性生成。 1234567@Beanpublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConnectionFactory(connectionFactory); factory.setMessageConverter(new Jackson2JsonMessageConverter()); return factory;&#125; 注释掉这个bean那两个配置才生效，当然也可以在这个bean里设置那两个属性。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://acupt.github.io/tags/spring/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://acupt.github.io/tags/rabbitmq/"}],"keywords":[{"name":"随笔","slug":"随笔","permalink":"https://acupt.github.io/categories/随笔/"}]},{"title":"spring cloud 自定义配置源及配置刷新","slug":"spring-cloud-source-diy","date":"2018-10-29T07:19:56.000Z","updated":"2018-11-15T09:12:42.075Z","comments":true,"path":"2018/10/29/spring-cloud-source-diy/","link":"","permalink":"https://acupt.github.io/2018/10/29/spring-cloud-source-diy/","excerpt":"","text":"通过自定义配置源可以接入自己的配置服务，配合ContextRefresher可以让应用运行中自动更新配置。 实现PropertySourceLocator123456789101112131415161718/** * 自定义配置源 */public class MyPropertySourceLocator implements PropertySourceLocator &#123; @Override public PropertySource&lt;?&gt; locate(Environment environment) &#123; String msg = new SimpleDateFormat(\"HH:mm:ss\").format(new Date()); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"demo.diy.msg\", msg); System.err.println(\"MyPropertySourceLocator, demo.diy.msg = \" + msg); //spring自带的一个简单的map结构配置集合，也可以继承PropertySource自定义 MapPropertySource source = new MapPropertySource(\"my-source\", map); return source; &#125;&#125; 配置类123456789@Configurationpublic class MyConfigBootstrapConfiguration &#123; @Bean public MyPropertySourceLocator myPropertySourceLocator() &#123; return new MyPropertySourceLocator(); &#125;&#125; 用Java代码声明bean，还需要在resources/META-INF/spring.factories中声明 12org.springframework.cloud.bootstrap.BootstrapConfiguration=\\com.netease.ag.demoweb.MyConfigBootstrapConfiguration Spring中类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 使用自定义配置123456789101112131415@RefreshScope //可更新@Component@Datapublic class ValueConfig &#123; @Value(\"$&#123;demo.copy.msg&#125;\") private String copyMsg; @Value(\"$&#123;demo.diy.msg&#125;\") private String diyMsg; public ValueConfig() &#123; System.err.println(\"ValueConfig init\"); &#125;&#125; application.properties中可以引用自定义配置 1demo.copy.msg=$&#123;demo.diy.msg&#125; springboot应用启动12345678910111213141516171819202122232425262728@SpringBootApplication@RestControllerpublic class DemowebApplication &#123; @Resource private ValueConfig valueConfig; @Resource private ContextRefresher contextRefresher; public DemowebApplication() &#123; System.err.println(\"DemowebApplication init\"); &#125; public static void main(String[] args) &#123; SpringApplication.run(DemowebApplication.class, args); &#125; @RequestMapping(\"/t\") public String t() &#123; return valueConfig.toString(); &#125; //更新bean属性 @RequestMapping(\"/r\") public Object r() &#123; return contextRefresher.refresh(); &#125; 启动日志1234567891011121314 . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)MyPropertySourceLocator, demo.diy.msg = 17:18:22...DemowebApplication init...ValueConfig init...Tomcat started on port(s): 8080 (http) 查询，多次请求返回一致 请求：http://localhost:8080/t响应：ValueConfig(copyMsg=17:18:22, diyMsg=17:18:22) 更新 请求：http://localhost:8080/r响应：[“demo.diy.msg”] 日志输出：1MyPropertySourceLocator, demo.diy.msg = 17:27:44 再次调用查询接口，发现值改变，并且输出日志 1ValueConfig init 证明更新字段实际是重新生成了一个bean","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"config","slug":"config","permalink":"https://acupt.github.io/tags/config/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"gRPC-Java 示例","slug":"grpc-start","date":"2018-10-23T12:19:56.000Z","updated":"2018-11-28T07:41:22.877Z","comments":true,"path":"2018/10/23/grpc-start/","link":"","permalink":"https://acupt.github.io/2018/10/23/grpc-start/","excerpt":"","text":"新建maven项目pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.grpc&lt;/groupId&gt; &lt;artifactId&gt;grpc-all&lt;/artifactId&gt; &lt;version&gt;1.5.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;extensions&gt; &lt;extension&gt; &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt; &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1.Final&lt;/version&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.5.0&lt;/version&gt; &lt;configuration&gt; &lt;protocArtifact&gt;com.google.protobuf:protoc:3.3.0:exe:$&#123;os.detected.classifier&#125; &lt;/protocArtifact&gt; &lt;pluginId&gt;grpc-java&lt;/pluginId&gt; &lt;pluginArtifact&gt;io.grpc:protoc-gen-grpc-java:1.5.0:exe:$&#123;os.detected.classifier&#125; &lt;/pluginArtifact&gt; &lt;!--*.proto文件目录--&gt; &lt;protoSourceRoot&gt;src/main/resources&lt;/protoSourceRoot&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;compile&lt;/goal&gt; &lt;goal&gt;compile-custom&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 定义服务新建文件 src/main/resources/test.proto 1234567891011121314151617181920syntax = \"proto3\";option java_multiple_files = true;option java_package = \"com.acupt.grpc.proto\";option java_outer_classname = \"HelloProto\";package com.acupt.grpc;service HelloService &#123; rpc hello (InvokeRequest) returns (InvokeResponse) &#123; &#125;&#125;message InvokeRequest &#123; string name = 1;&#125;message InvokeResponse &#123; string msg = 1;&#125; 构建使用maven插件根据.proto文件生成Java代码，插件已在pom.xml中配置，只需执行命令： mvn install 构建完成后可以在target中找到生成的Java代码，用这些代码\b可以实现gRPC远程调用。 但在项目中还无法直接引用上面的类，右键\b -&gt; Mark Directory as -&gt; Generated Sources Root 现在就可以在项目中引用了 代码3个类 1234567891011121314151617181920212223package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.stub.StreamObserver;/** * 服务实现类 */public class HelloService extends HelloServiceGrpc.HelloServiceImplBase &#123; @Override public void hello(InvokeRequest request, StreamObserver&lt;InvokeResponse&gt; responseObserver) &#123; System.out.println(\"request -&gt; \" + request); String name = request.getName();//自定义的字段名 name InvokeResponse response = InvokeResponse.newBuilder() .setMsg(\"hello,\" + name)//自定义的字段名 msg .build(); responseObserver.onNext(response); responseObserver.onCompleted(); &#125;&#125; 12345678910111213141516171819202122232425package com.acupt.grpc;import io.grpc.Server;import io.grpc.ServerBuilder;import java.io.IOException;/** * 服务提供方 * * @author liujie */public class MyServer &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; int port = 50051; Server server = ServerBuilder.forPort(port) .addService(new HelloService()) .build() .start(); System.out.println(\"started\"); Thread.sleep(1000 * 60 * 2); server.shutdown(); System.out.println(\"shutdown\"); &#125;&#125; 123456789101112131415161718192021package com.acupt.grpc;import com.acupt.grpc.proto.HelloServiceGrpc;import com.acupt.grpc.proto.InvokeRequest;import com.acupt.grpc.proto.InvokeResponse;import io.grpc.Channel;import io.grpc.ManagedChannelBuilder;/** * 服务调用方 */public class MyClient &#123; public static void main(String[] args) &#123; InvokeRequest request = InvokeRequest.newBuilder().setName(\"tom\").build(); Channel channel = ManagedChannelBuilder.forAddress(\"localhost\", 50051).usePlaintext(true).build(); HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel); InvokeResponse response = blockingStub.hello(request); System.out.println(response.getMsg()); &#125;&#125; 先启动MyServer，\b成功启动后再启动MyClient 请求方式1.阻塞\b同步请求，接口返回前是阻塞的。 123HelloServiceGrpc.HelloServiceBlockingStub blockingStub = HelloServiceGrpc.newBlockingStub(channel);InvokeResponse response = blockingStub.hello(request);System.out.println(response.getMsg()); 2.Future调用后返回guava包里继承了Future的接口ListenableFuture（增加了listener支持），可以控制超时时间。 12345678910111213141516HelloServiceGrpc.HelloServiceFutureStub futureStub = HelloServiceGrpc.newFutureStub(channel);ListenableFuture&lt;InvokeResponse&gt; future = futureStub.hello(request);future.addListener( () -&gt; System.out.println(\"listener 1\"), command -&gt; &#123; System.out.println(\"execute 1 \" + command); command.run(); &#125;);future.addListener( () -&gt; System.out.println(\"listener 2\"), command -&gt; &#123; System.out.println(\"execute 2 \" + command); command.run(); &#125;);System.out.println(future.get(10, TimeUnit.SECONDS)); 3.回调调用接口传入回调函数，调用后马上返回。 123456789101112131415161718192021222324MyClient.done = false;HelloServiceGrpc.HelloServiceStub stub = HelloServiceGrpc.newStub(channel);stub.hello(request, new StreamObserver&lt;InvokeResponse&gt;() &#123; @Override public void onNext(InvokeResponse value) &#123; System.out.println(\"onNext \" + value); &#125; @Override public void onError(Throwable t) &#123; System.out.println(\"onError \" + t.getMessage()); t.printStackTrace(); MyClient.done = true; &#125; @Override public void onCompleted() &#123; System.out.println(\"onCompleted\"); MyClient.done = true; &#125;&#125;);while (!MyClient.done) &#123; Thread.sleep(1000);&#125;","categories":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}],"tags":[{"name":"rpc","slug":"rpc","permalink":"https://acupt.github.io/tags/rpc/"},{"name":"grpc","slug":"grpc","permalink":"https://acupt.github.io/tags/grpc/"}],"keywords":[{"name":"微服务","slug":"微服务","permalink":"https://acupt.github.io/categories/微服务/"}]},{"title":"github+hexo搭建个人主页","slug":"github-hexo-homepage","date":"2018-05-20T07:41:09.000Z","updated":"2019-07-12T14:14:45.559Z","comments":true,"path":"2018/05/20/github-hexo-homepage/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-hexo-homepage/","excerpt":"","text":"以前也尝试过搭建个人主页，前端+后端+服务器+域名，等这些都弄过一遍后，发现系统设计的太挫没有使用的欲望（还不如在开源中国写博客，页面美观还有人点赞）。某天突然明确了我的需求，一个酷炫的主面，一个可以看自己文章的页面，这些文章的资源最好具备通用性（比如.md），即可。 hexo，快速、简洁且高效的博客框架。hexo快速搭建博客（不写代码），基本无缝接入自己的md文档，配合github，服务器和域名也有了。 macOS Sierra github git nodejs hexo github个人主页创建官方教程 新建仓库我的github用户名是acupt，新建仓库，名为 acupt.github.io， git地址为 git@github.com:acupt/acupt.github.io.git github给你的个人主页地址为 https://acupt.github.io 修改主页访问主页地址将展示根目录下的index.html，如果没有的话展示README.md，也没有？告辞！ 这时候可以在index.html里面写主页代码了，不想写的继续往下。 hexo搭建个人主页安装hexo准备工作，请自行安装 nodejs git 开始安装hexo，新建一个文件夹并进入它 123npm install hexo-cli -ghexo initnpm install 启动hexo12hexo g # 生成文件，同 hexo generatehexo s # 启动服务，同 hexo server 启动成功后在浏览器访问 http://localhost:4000 写文章主目录下执行命令可新建一个md文件，也可以自己新建到source/_posts目录下 12345678hexo new &quot;文件名&quot; #新建文章hexo new page &quot;页面名&quot; #新建页面 # 常用简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 修改主题如果默认模板就能满足，此步骤可以跳过，但不找个酷炫的模板还怎么zhuangbility。 下载主题先找到你想象中的滑板鞋（ 官方模板库 ），克隆模板到hexo的themes目录下。 12# 我好不容易找到的酷炫模板git clone https://github.com/miccall/hexo-theme-Mic_Theme.git 但这个项目名不太友好，克隆成功后需要把文件夹重命名为模板名。 1mv hexo-theme-Mic_Theme miccall 主题模板配置编辑hexo主目录下的_config.yml，修改theme参数为新的主题名miccall 12345# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#theme: yiliatheme: miccall 修改模板的配置文件，在模板文件夹内也有个_config.yml，和hexo主目录下的_config.yml负责的东西不一样，hexo的配置管通用属性，模板的配置管个性参数，模板的项目首页一般都有配置教程。 模板可能有些地方不符合自己的需求，如果没法配置的话，除了给作者提issue，还可以自己改模板代码（反正代码在本地，可以为所欲为），比如我把这个模板的group（团队）布局用来展示自己的作品，那我就不需要QQ微信微博，只要个链接就行了，看文档没有相关参数隐藏，去代码里搜索了下，注释掉了那几行代码。 重启服务如果之前启动着，Ctrl+C关闭，后台运行的就kill掉。 123hexo clean # 清除缓存，会删除主目录下的public目录和数据库数据hexo ghexo s hexo发布个人主页到github编辑hexo主目录下的_config.yml，修改deploy配置 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:acupt/acupt.github.io.git branch: master 此配置表示用部署到git上，不过需要再安装一个插件。 1npm install hexo-deployer-git --save 发布 12hexo ghexo d 访问自己的github个人页面（如 https://acupt.github.io/ )，查看效果。 感谢miccall@github提供的酷炫模板，https://github.com/miccall/hexo-theme-Mic_Theme 技术性改进虽然这个主题很酷炫，但不可能每一点都如我所愿，如果主题作者未提供可配置选项，就需要对模板源代码做些改动。 先去主题项目的github主页fork一份到自己的github，再clone到本地。 links布局配置可选此主题的团队页面布局我很喜欢，但我并没有小伙伴想贴上去，那就做成作品展示页面好了。但是这个布局设计之初是为了展示人，所以有QQ、微信等信息配置，但我只想要一个‘链接’属性，其它的显示出来有点碍事。 IDE打开本地代码，全局搜索，就用属性名做关键词，果断在一个page-links.ejs文件中发现。 123456&lt;ul class=&quot;social&quot;&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 网上查一下语法，加个if判断。 1234567891011121314&lt;ul class=&quot;social&quot;&gt; &lt;% if (site.data.links[i].link != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].link%&gt;&quot; class=&quot;fa fa-link&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].qq != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].qq%&gt;&quot; class=&quot;fa fa-qq&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].wachat != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].wachat%&gt;&quot; class=&quot;fa fa-wechat&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt; &lt;% if (site.data.links[i].weibo != null) &#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%= site.data.links[i].weibo%&gt;&quot; class=&quot;fa fa-weibo&quot;&gt;&lt;/a&gt;&lt;/li&gt; &lt;%&#125;%&gt;&lt;/ul&gt; 妥了 https站内访问http资源受限部署到github后第二天发现我酷炫的作品展示页面不再酷炫了，样式有点诡异，打开调试界面 显然最上面那两个异常是问题所在（下面那个异常没影响，有空再研究） https协议的网站如果用http访问外部资源，往往会收到这种限制，这种情况最好统一一下，大家用同样的协议即可，显然我不能改github的协议，那只能改主题代码了 还是一波全局搜索，还是那个文件 12&lt;link href=&quot;http://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;http://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 改成https，搞定 再优雅点 12&lt;link href=&quot;//cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot; rel=&quot;stylesheet&quot;&gt; 发布，验证，搞定，顺便提个pull request","categories":[{"name":"教程","slug":"教程","permalink":"https://acupt.github.io/categories/教程/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"hexo","slug":"hexo","permalink":"https://acupt.github.io/tags/hexo/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"https://acupt.github.io/categories/教程/"}]},{"title":"github搭建个人maven仓库","slug":"github-repository","date":"2018-05-20T07:00:00.000Z","updated":"2019-07-13T14:56:57.353Z","comments":true,"path":"2018/05/20/github-repository/","link":"","permalink":"https://acupt.github.io/2018/05/20/github-repository/","excerpt":"","text":"Maven对Java开发者来说是很常见的工具，有了它只需要在pom文件加几行代码就能引入第三方代码。如果想我们自己写的工具类也让别人通过这种方式使用，不妨借助github搭建个免费仓库。 核心原理就是在github上建立一个代码仓库来存储我们发布的jar包，不需要自己买服务器，买域名，这些github都能帮我们实现。 新建仓库 在github新建一个普通的仓库即可，我的仓库地址 https://github.com/acupt/repository.git 克隆到本地 123456789101112➜ github git clone https://github.com/acupt/repository.gitCloning into &apos;repository&apos;...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.➜ github cd repository ➜ repository git:(master) lsREADME.md➜ repository git:(master) pwd/Users/acupt/github/repository 发布到本地 用deploy命令发布项目，指定打包的文件输出到上一步克隆的本地仓库，在项目（我们需要发布到仓库的代码/jar包）根目录下执行以下指令 1mvn deploy -DaltDeploymentRepository=acupt-repository::default::file:/Users/acupt/github/repository/ 同步到远程仓库 不想用master可以新建个分支 123git branch snapshotgit push origin snapshotgit checkout snapshot git add/commit/push 12345678910111213141516171819202122232425262728➜ repository git:(snapshot) ✗ git add com/➜ repository git:(snapshot) ✗ git commit -m &quot;acupsession&quot;[snapshot 4409029] acupsession 12 files changed, 74 insertions(+) create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.jar.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/acupsession-1.0-20180519.110225-1.pom.sha1 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/1.0-SNAPSHOT/maven-metadata.xml.sha1 create mode 100644 com/acupt/acupsession/maven-metadata.xml create mode 100644 com/acupt/acupsession/maven-metadata.xml.md5 create mode 100644 com/acupt/acupsession/maven-metadata.xml.sha1 ➜ repository git:(snapshot) ✗ git pushCounting objects: 18, done.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), done.Writing objects: 100% (18/18), 12.50 KiB | 6.25 MiB/s, done.Total 18 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), done.To https://github.com/acupt/repository.git 3951922..4409029 snapshot -&gt; snapshot➜ repository git:(snapshot) ✗ 测试到这里已经ok了，通过GitHub提供的域名可以下载maven依赖（但无法查看列表），地址： https://raw.github.com/acupt/repository/snapshot 接下来新建一个项目试着引用前面发布的jar包，需要在pom文件中增加远程仓库地址，当然也可以在maven配置文件中做全局配置。 新建maven项目 修改pom.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupdemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;acupt-repository&lt;/id&gt; &lt;url&gt;https://raw.github.com/acupt/repository/snapshot&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.acupt&lt;/groupId&gt; &lt;artifactId&gt;acupsession&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 查看本地maven仓库，看看jar包有没有下载成功 12345678➜ acupsession cd ~/.m2/repository/com/acupt/acupsession/1.0-SNAPSHOT ➜ 1.0-SNAPSHOT lsacupsession-1.0-20180519.110225-1.jar acupsession-1.0-SNAPSHOT.jaracupsession-1.0-20180519.110225-1.jar.sha1 acupsession-1.0-SNAPSHOT.pomacupsession-1.0-20180519.110225-1.jar.tmp.sha1.tmp maven-metadata-acupt-repository.xmlacupsession-1.0-20180519.110225-1.pom maven-metadata-acupt-repository.xml.sha1acupsession-1.0-20180519.110225-1.pom.sha1 maven-metadata-acupt-repository.xml.tmp.sha1.tmpacupsession-1.0-20180519.110225-1.pom.tmp.sha1.tmp maven-metadata-snapshots.xml 可以看到已经有jar包了，至此一个属于你自己的maven仓库就完成了。 如果想让别人不需要添加你的仓库地址就能用你的jar包，那么就不能用自己搭建的私人仓库了，需要发布到大家公用的仓库里去，有专门的提供这种服务的公司，网上一搜就有，但不是免费的，告辞。","categories":[{"name":"教程","slug":"教程","permalink":"https://acupt.github.io/categories/教程/"}],"tags":[{"name":"github","slug":"github","permalink":"https://acupt.github.io/tags/github/"},{"name":"maven","slug":"maven","permalink":"https://acupt.github.io/tags/maven/"}],"keywords":[{"name":"教程","slug":"教程","permalink":"https://acupt.github.io/categories/教程/"}]}]}